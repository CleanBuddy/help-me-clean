// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0

package db

import (
	"database/sql/driver"
	"fmt"

	"github.com/jackc/pgx/v5/pgtype"
)

type BookingStatus string

const (
	BookingStatusPending            BookingStatus = "pending"
	BookingStatusAssigned           BookingStatus = "assigned"
	BookingStatusConfirmed          BookingStatus = "confirmed"
	BookingStatusInProgress         BookingStatus = "in_progress"
	BookingStatusCompleted          BookingStatus = "completed"
	BookingStatusCancelledByClient  BookingStatus = "cancelled_by_client"
	BookingStatusCancelledByCompany BookingStatus = "cancelled_by_company"
	BookingStatusCancelledByAdmin   BookingStatus = "cancelled_by_admin"
)

func (e *BookingStatus) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = BookingStatus(s)
	case string:
		*e = BookingStatus(s)
	default:
		return fmt.Errorf("unsupported scan type for BookingStatus: %T", src)
	}
	return nil
}

type NullBookingStatus struct {
	BookingStatus BookingStatus `json:"booking_status"`
	Valid         bool          `json:"valid"` // Valid is true if BookingStatus is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullBookingStatus) Scan(value interface{}) error {
	if value == nil {
		ns.BookingStatus, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.BookingStatus.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullBookingStatus) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.BookingStatus), nil
}

type CleanerStatus string

const (
	CleanerStatusInvited       CleanerStatus = "invited"
	CleanerStatusPendingReview CleanerStatus = "pending_review"
	CleanerStatusActive        CleanerStatus = "active"
	CleanerStatusInactive      CleanerStatus = "inactive"
	CleanerStatusSuspended     CleanerStatus = "suspended"
)

func (e *CleanerStatus) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = CleanerStatus(s)
	case string:
		*e = CleanerStatus(s)
	default:
		return fmt.Errorf("unsupported scan type for CleanerStatus: %T", src)
	}
	return nil
}

type NullCleanerStatus struct {
	CleanerStatus CleanerStatus `json:"cleaner_status"`
	Valid         bool          `json:"valid"` // Valid is true if CleanerStatus is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullCleanerStatus) Scan(value interface{}) error {
	if value == nil {
		ns.CleanerStatus, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.CleanerStatus.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullCleanerStatus) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.CleanerStatus), nil
}

type CompanyStatus string

const (
	CompanyStatusPendingReview CompanyStatus = "pending_review"
	CompanyStatusApproved      CompanyStatus = "approved"
	CompanyStatusRejected      CompanyStatus = "rejected"
	CompanyStatusSuspended     CompanyStatus = "suspended"
)

func (e *CompanyStatus) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = CompanyStatus(s)
	case string:
		*e = CompanyStatus(s)
	default:
		return fmt.Errorf("unsupported scan type for CompanyStatus: %T", src)
	}
	return nil
}

type NullCompanyStatus struct {
	CompanyStatus CompanyStatus `json:"company_status"`
	Valid         bool          `json:"valid"` // Valid is true if CompanyStatus is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullCompanyStatus) Scan(value interface{}) error {
	if value == nil {
		ns.CompanyStatus, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.CompanyStatus.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullCompanyStatus) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.CompanyStatus), nil
}

type CompanyType string

const (
	CompanyTypeSrl CompanyType = "srl"
	CompanyTypePfa CompanyType = "pfa"
	CompanyTypeIi  CompanyType = "ii"
)

func (e *CompanyType) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = CompanyType(s)
	case string:
		*e = CompanyType(s)
	default:
		return fmt.Errorf("unsupported scan type for CompanyType: %T", src)
	}
	return nil
}

type NullCompanyType struct {
	CompanyType CompanyType `json:"company_type"`
	Valid       bool        `json:"valid"` // Valid is true if CompanyType is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullCompanyType) Scan(value interface{}) error {
	if value == nil {
		ns.CompanyType, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.CompanyType.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullCompanyType) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.CompanyType), nil
}

type InvoiceStatus string

const (
	InvoiceStatusDraft       InvoiceStatus = "draft"
	InvoiceStatusIssued      InvoiceStatus = "issued"
	InvoiceStatusSent        InvoiceStatus = "sent"
	InvoiceStatusTransmitted InvoiceStatus = "transmitted"
	InvoiceStatusPaid        InvoiceStatus = "paid"
	InvoiceStatusCancelled   InvoiceStatus = "cancelled"
	InvoiceStatusCreditNote  InvoiceStatus = "credit_note"
)

func (e *InvoiceStatus) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = InvoiceStatus(s)
	case string:
		*e = InvoiceStatus(s)
	default:
		return fmt.Errorf("unsupported scan type for InvoiceStatus: %T", src)
	}
	return nil
}

type NullInvoiceStatus struct {
	InvoiceStatus InvoiceStatus `json:"invoice_status"`
	Valid         bool          `json:"valid"` // Valid is true if InvoiceStatus is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullInvoiceStatus) Scan(value interface{}) error {
	if value == nil {
		ns.InvoiceStatus, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.InvoiceStatus.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullInvoiceStatus) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.InvoiceStatus), nil
}

type InvoiceType string

const (
	InvoiceTypeClientService      InvoiceType = "client_service"
	InvoiceTypePlatformCommission InvoiceType = "platform_commission"
)

func (e *InvoiceType) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = InvoiceType(s)
	case string:
		*e = InvoiceType(s)
	default:
		return fmt.Errorf("unsupported scan type for InvoiceType: %T", src)
	}
	return nil
}

type NullInvoiceType struct {
	InvoiceType InvoiceType `json:"invoice_type"`
	Valid       bool        `json:"valid"` // Valid is true if InvoiceType is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullInvoiceType) Scan(value interface{}) error {
	if value == nil {
		ns.InvoiceType, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.InvoiceType.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullInvoiceType) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.InvoiceType), nil
}

type NotificationType string

const (
	NotificationTypeBookingCreated   NotificationType = "booking_created"
	NotificationTypeBookingAssigned  NotificationType = "booking_assigned"
	NotificationTypeBookingConfirmed NotificationType = "booking_confirmed"
	NotificationTypeBookingStarted   NotificationType = "booking_started"
	NotificationTypeBookingCompleted NotificationType = "booking_completed"
	NotificationTypeBookingCancelled NotificationType = "booking_cancelled"
	NotificationTypeCleanerInvited   NotificationType = "cleaner_invited"
	NotificationTypeCompanyApproved  NotificationType = "company_approved"
	NotificationTypeCompanyRejected  NotificationType = "company_rejected"
	NotificationTypeNewMessage       NotificationType = "new_message"
	NotificationTypeReviewReceived   NotificationType = "review_received"
	NotificationTypePaymentProcessed NotificationType = "payment_processed"
)

func (e *NotificationType) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = NotificationType(s)
	case string:
		*e = NotificationType(s)
	default:
		return fmt.Errorf("unsupported scan type for NotificationType: %T", src)
	}
	return nil
}

type NullNotificationType struct {
	NotificationType NotificationType `json:"notification_type"`
	Valid            bool             `json:"valid"` // Valid is true if NotificationType is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullNotificationType) Scan(value interface{}) error {
	if value == nil {
		ns.NotificationType, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.NotificationType.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullNotificationType) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.NotificationType), nil
}

type PaymentTransactionStatus string

const (
	PaymentTransactionStatusPending           PaymentTransactionStatus = "pending"
	PaymentTransactionStatusRequiresAction    PaymentTransactionStatus = "requires_action"
	PaymentTransactionStatusProcessing        PaymentTransactionStatus = "processing"
	PaymentTransactionStatusSucceeded         PaymentTransactionStatus = "succeeded"
	PaymentTransactionStatusFailed            PaymentTransactionStatus = "failed"
	PaymentTransactionStatusRefunded          PaymentTransactionStatus = "refunded"
	PaymentTransactionStatusPartiallyRefunded PaymentTransactionStatus = "partially_refunded"
	PaymentTransactionStatusCancelled         PaymentTransactionStatus = "cancelled"
)

func (e *PaymentTransactionStatus) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = PaymentTransactionStatus(s)
	case string:
		*e = PaymentTransactionStatus(s)
	default:
		return fmt.Errorf("unsupported scan type for PaymentTransactionStatus: %T", src)
	}
	return nil
}

type NullPaymentTransactionStatus struct {
	PaymentTransactionStatus PaymentTransactionStatus `json:"payment_transaction_status"`
	Valid                    bool                     `json:"valid"` // Valid is true if PaymentTransactionStatus is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullPaymentTransactionStatus) Scan(value interface{}) error {
	if value == nil {
		ns.PaymentTransactionStatus, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.PaymentTransactionStatus.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullPaymentTransactionStatus) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.PaymentTransactionStatus), nil
}

type PayoutStatus string

const (
	PayoutStatusPending    PayoutStatus = "pending"
	PayoutStatusProcessing PayoutStatus = "processing"
	PayoutStatusPaid       PayoutStatus = "paid"
	PayoutStatusFailed     PayoutStatus = "failed"
	PayoutStatusCancelled  PayoutStatus = "cancelled"
)

func (e *PayoutStatus) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = PayoutStatus(s)
	case string:
		*e = PayoutStatus(s)
	default:
		return fmt.Errorf("unsupported scan type for PayoutStatus: %T", src)
	}
	return nil
}

type NullPayoutStatus struct {
	PayoutStatus PayoutStatus `json:"payout_status"`
	Valid        bool         `json:"valid"` // Valid is true if PayoutStatus is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullPayoutStatus) Scan(value interface{}) error {
	if value == nil {
		ns.PayoutStatus, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.PayoutStatus.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullPayoutStatus) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.PayoutStatus), nil
}

type RecurrenceType string

const (
	RecurrenceTypeWeekly   RecurrenceType = "weekly"
	RecurrenceTypeBiweekly RecurrenceType = "biweekly"
	RecurrenceTypeMonthly  RecurrenceType = "monthly"
)

func (e *RecurrenceType) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = RecurrenceType(s)
	case string:
		*e = RecurrenceType(s)
	default:
		return fmt.Errorf("unsupported scan type for RecurrenceType: %T", src)
	}
	return nil
}

type NullRecurrenceType struct {
	RecurrenceType RecurrenceType `json:"recurrence_type"`
	Valid          bool           `json:"valid"` // Valid is true if RecurrenceType is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullRecurrenceType) Scan(value interface{}) error {
	if value == nil {
		ns.RecurrenceType, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.RecurrenceType.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullRecurrenceType) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.RecurrenceType), nil
}

type RefundStatus string

const (
	RefundStatusRequested RefundStatus = "requested"
	RefundStatusApproved  RefundStatus = "approved"
	RefundStatusProcessed RefundStatus = "processed"
	RefundStatusRejected  RefundStatus = "rejected"
)

func (e *RefundStatus) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = RefundStatus(s)
	case string:
		*e = RefundStatus(s)
	default:
		return fmt.Errorf("unsupported scan type for RefundStatus: %T", src)
	}
	return nil
}

type NullRefundStatus struct {
	RefundStatus RefundStatus `json:"refund_status"`
	Valid        bool         `json:"valid"` // Valid is true if RefundStatus is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullRefundStatus) Scan(value interface{}) error {
	if value == nil {
		ns.RefundStatus, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.RefundStatus.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullRefundStatus) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.RefundStatus), nil
}

type ServiceType string

const (
	ServiceTypeStandardCleaning  ServiceType = "standard_cleaning"
	ServiceTypeDeepCleaning      ServiceType = "deep_cleaning"
	ServiceTypeMoveInOutCleaning ServiceType = "move_in_out_cleaning"
	ServiceTypePostConstruction  ServiceType = "post_construction"
	ServiceTypeOfficeCleaning    ServiceType = "office_cleaning"
	ServiceTypeWindowCleaning    ServiceType = "window_cleaning"
)

func (e *ServiceType) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = ServiceType(s)
	case string:
		*e = ServiceType(s)
	default:
		return fmt.Errorf("unsupported scan type for ServiceType: %T", src)
	}
	return nil
}

type NullServiceType struct {
	ServiceType ServiceType `json:"service_type"`
	Valid       bool        `json:"valid"` // Valid is true if ServiceType is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullServiceType) Scan(value interface{}) error {
	if value == nil {
		ns.ServiceType, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.ServiceType.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullServiceType) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.ServiceType), nil
}

type UserRole string

const (
	UserRoleClient       UserRole = "client"
	UserRoleCompanyAdmin UserRole = "company_admin"
	UserRoleCleaner      UserRole = "cleaner"
	UserRoleGlobalAdmin  UserRole = "global_admin"
)

func (e *UserRole) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = UserRole(s)
	case string:
		*e = UserRole(s)
	default:
		return fmt.Errorf("unsupported scan type for UserRole: %T", src)
	}
	return nil
}

type NullUserRole struct {
	UserRole UserRole `json:"user_role"`
	Valid    bool     `json:"valid"` // Valid is true if UserRole is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullUserRole) Scan(value interface{}) error {
	if value == nil {
		ns.UserRole, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.UserRole.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullUserRole) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.UserRole), nil
}

type UserStatus string

const (
	UserStatusActive    UserStatus = "active"
	UserStatusInactive  UserStatus = "inactive"
	UserStatusSuspended UserStatus = "suspended"
	UserStatusPending   UserStatus = "pending"
)

func (e *UserStatus) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = UserStatus(s)
	case string:
		*e = UserStatus(s)
	default:
		return fmt.Errorf("unsupported scan type for UserStatus: %T", src)
	}
	return nil
}

type NullUserStatus struct {
	UserStatus UserStatus `json:"user_status"`
	Valid      bool       `json:"valid"` // Valid is true if UserStatus is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullUserStatus) Scan(value interface{}) error {
	if value == nil {
		ns.UserStatus, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.UserStatus.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullUserStatus) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.UserStatus), nil
}

type WaitlistLeadType string

const (
	WaitlistLeadTypeClient  WaitlistLeadType = "client"
	WaitlistLeadTypeCompany WaitlistLeadType = "company"
)

func (e *WaitlistLeadType) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = WaitlistLeadType(s)
	case string:
		*e = WaitlistLeadType(s)
	default:
		return fmt.Errorf("unsupported scan type for WaitlistLeadType: %T", src)
	}
	return nil
}

type NullWaitlistLeadType struct {
	WaitlistLeadType WaitlistLeadType `json:"waitlist_lead_type"`
	Valid            bool             `json:"valid"` // Valid is true if WaitlistLeadType is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullWaitlistLeadType) Scan(value interface{}) error {
	if value == nil {
		ns.WaitlistLeadType, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.WaitlistLeadType.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullWaitlistLeadType) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.WaitlistLeadType), nil
}

type Booking struct {
	ID                       pgtype.UUID        `json:"id"`
	ReferenceCode            string             `json:"reference_code"`
	ClientUserID             pgtype.UUID        `json:"client_user_id"`
	CompanyID                pgtype.UUID        `json:"company_id"`
	CleanerID                pgtype.UUID        `json:"cleaner_id"`
	AddressID                pgtype.UUID        `json:"address_id"`
	ServiceType              ServiceType        `json:"service_type"`
	ScheduledDate            pgtype.Date        `json:"scheduled_date"`
	ScheduledStartTime       pgtype.Time        `json:"scheduled_start_time"`
	EstimatedDurationHours   pgtype.Numeric     `json:"estimated_duration_hours"`
	PropertyType             pgtype.Text        `json:"property_type"`
	NumRooms                 pgtype.Int4        `json:"num_rooms"`
	NumBathrooms             pgtype.Int4        `json:"num_bathrooms"`
	AreaSqm                  pgtype.Int4        `json:"area_sqm"`
	HasPets                  pgtype.Bool        `json:"has_pets"`
	SpecialInstructions      pgtype.Text        `json:"special_instructions"`
	HourlyRate               pgtype.Numeric     `json:"hourly_rate"`
	EstimatedTotal           pgtype.Numeric     `json:"estimated_total"`
	FinalTotal               pgtype.Numeric     `json:"final_total"`
	PlatformCommissionPct    pgtype.Numeric     `json:"platform_commission_pct"`
	PlatformCommissionAmount pgtype.Numeric     `json:"platform_commission_amount"`
	Status                   BookingStatus      `json:"status"`
	StartedAt                pgtype.Timestamptz `json:"started_at"`
	CompletedAt              pgtype.Timestamptz `json:"completed_at"`
	CancelledAt              pgtype.Timestamptz `json:"cancelled_at"`
	CancellationReason       pgtype.Text        `json:"cancellation_reason"`
	StripePaymentIntentID    pgtype.Text        `json:"stripe_payment_intent_id"`
	PaymentStatus            pgtype.Text        `json:"payment_status"`
	PaidAt                   pgtype.Timestamptz `json:"paid_at"`
	CreatedAt                pgtype.Timestamptz `json:"created_at"`
	UpdatedAt                pgtype.Timestamptz `json:"updated_at"`
	RecurringGroupID         pgtype.UUID        `json:"recurring_group_id"`
	OccurrenceNumber         pgtype.Int4        `json:"occurrence_number"`
}

type BookingExtra struct {
	ID        pgtype.UUID    `json:"id"`
	BookingID pgtype.UUID    `json:"booking_id"`
	ExtraID   pgtype.UUID    `json:"extra_id"`
	Price     pgtype.Numeric `json:"price"`
	Quantity  pgtype.Int4    `json:"quantity"`
}

type BookingTimeSlot struct {
	ID         pgtype.UUID        `json:"id"`
	BookingID  pgtype.UUID        `json:"booking_id"`
	SlotDate   pgtype.Date        `json:"slot_date"`
	StartTime  pgtype.Time        `json:"start_time"`
	EndTime    pgtype.Time        `json:"end_time"`
	IsSelected bool               `json:"is_selected"`
	CreatedAt  pgtype.Timestamptz `json:"created_at"`
}

type ChatMessage struct {
	ID          pgtype.UUID        `json:"id"`
	RoomID      pgtype.UUID        `json:"room_id"`
	SenderID    pgtype.UUID        `json:"sender_id"`
	Content     string             `json:"content"`
	MessageType pgtype.Text        `json:"message_type"`
	IsRead      pgtype.Bool        `json:"is_read"`
	CreatedAt   pgtype.Timestamptz `json:"created_at"`
}

type ChatParticipant struct {
	ID       pgtype.UUID        `json:"id"`
	RoomID   pgtype.UUID        `json:"room_id"`
	UserID   pgtype.UUID        `json:"user_id"`
	JoinedAt pgtype.Timestamptz `json:"joined_at"`
}

type ChatRoom struct {
	ID        pgtype.UUID        `json:"id"`
	BookingID pgtype.UUID        `json:"booking_id"`
	RoomType  string             `json:"room_type"`
	CreatedAt pgtype.Timestamptz `json:"created_at"`
}

type CityArea struct {
	ID        pgtype.UUID        `json:"id"`
	CityID    pgtype.UUID        `json:"city_id"`
	Name      string             `json:"name"`
	CreatedAt pgtype.Timestamptz `json:"created_at"`
}

type Cleaner struct {
	ID                 pgtype.UUID        `json:"id"`
	UserID             pgtype.UUID        `json:"user_id"`
	CompanyID          pgtype.UUID        `json:"company_id"`
	Status             CleanerStatus      `json:"status"`
	IsCompanyAdmin     pgtype.Bool        `json:"is_company_admin"`
	InviteToken        pgtype.Text        `json:"invite_token"`
	InviteExpiresAt    pgtype.Timestamptz `json:"invite_expires_at"`
	RatingAvg          pgtype.Numeric     `json:"rating_avg"`
	TotalJobsCompleted pgtype.Int4        `json:"total_jobs_completed"`
	CreatedAt          pgtype.Timestamptz `json:"created_at"`
	UpdatedAt          pgtype.Timestamptz `json:"updated_at"`
	Bio                pgtype.Text        `json:"bio"`
}

type CleanerAvailability struct {
	ID          pgtype.UUID `json:"id"`
	CleanerID   pgtype.UUID `json:"cleaner_id"`
	DayOfWeek   int32       `json:"day_of_week"`
	StartTime   pgtype.Time `json:"start_time"`
	EndTime     pgtype.Time `json:"end_time"`
	IsAvailable pgtype.Bool `json:"is_available"`
}

type CleanerDateOverride struct {
	ID           pgtype.UUID        `json:"id"`
	CleanerID    pgtype.UUID        `json:"cleaner_id"`
	OverrideDate pgtype.Date        `json:"override_date"`
	IsAvailable  bool               `json:"is_available"`
	StartTime    pgtype.Time        `json:"start_time"`
	EndTime      pgtype.Time        `json:"end_time"`
	CreatedAt    pgtype.Timestamptz `json:"created_at"`
}

type CleanerDocument struct {
	ID              pgtype.UUID        `json:"id"`
	CleanerID       pgtype.UUID        `json:"cleaner_id"`
	DocumentType    string             `json:"document_type"`
	FileUrl         string             `json:"file_url"`
	FileName        string             `json:"file_name"`
	Status          string             `json:"status"`
	UploadedAt      pgtype.Timestamptz `json:"uploaded_at"`
	ReviewedAt      pgtype.Timestamptz `json:"reviewed_at"`
	ReviewedBy      pgtype.UUID        `json:"reviewed_by"`
	RejectionReason pgtype.Text        `json:"rejection_reason"`
}

type CleanerServiceArea struct {
	ID         pgtype.UUID        `json:"id"`
	CleanerID  pgtype.UUID        `json:"cleaner_id"`
	CityAreaID pgtype.UUID        `json:"city_area_id"`
	CreatedAt  pgtype.Timestamptz `json:"created_at"`
}

type ClientAddress struct {
	ID            pgtype.UUID        `json:"id"`
	UserID        pgtype.UUID        `json:"user_id"`
	Label         pgtype.Text        `json:"label"`
	StreetAddress string             `json:"street_address"`
	City          string             `json:"city"`
	County        string             `json:"county"`
	PostalCode    pgtype.Text        `json:"postal_code"`
	Floor         pgtype.Text        `json:"floor"`
	Apartment     pgtype.Text        `json:"apartment"`
	EntryCode     pgtype.Text        `json:"entry_code"`
	Latitude      pgtype.Float8      `json:"latitude"`
	Longitude     pgtype.Float8      `json:"longitude"`
	Notes         pgtype.Text        `json:"notes"`
	IsDefault     pgtype.Bool        `json:"is_default"`
	CreatedAt     pgtype.Timestamptz `json:"created_at"`
}

type ClientBillingProfile struct {
	ID          pgtype.UUID        `json:"id"`
	UserID      pgtype.UUID        `json:"user_id"`
	IsCompany   bool               `json:"is_company"`
	CompanyName pgtype.Text        `json:"company_name"`
	Cui         pgtype.Text        `json:"cui"`
	RegNumber   pgtype.Text        `json:"reg_number"`
	Address     pgtype.Text        `json:"address"`
	City        pgtype.Text        `json:"city"`
	County      pgtype.Text        `json:"county"`
	IsVatPayer  pgtype.Bool        `json:"is_vat_payer"`
	BankName    pgtype.Text        `json:"bank_name"`
	Iban        pgtype.Text        `json:"iban"`
	IsDefault   pgtype.Bool        `json:"is_default"`
	CreatedAt   pgtype.Timestamptz `json:"created_at"`
	UpdatedAt   pgtype.Timestamptz `json:"updated_at"`
}

type ClientPaymentMethod struct {
	ID                    pgtype.UUID        `json:"id"`
	UserID                pgtype.UUID        `json:"user_id"`
	StripePaymentMethodID pgtype.Text        `json:"stripe_payment_method_id"`
	CardLastFour          pgtype.Text        `json:"card_last_four"`
	CardBrand             pgtype.Text        `json:"card_brand"`
	IsDefault             pgtype.Bool        `json:"is_default"`
	CreatedAt             pgtype.Timestamptz `json:"created_at"`
	CardExpMonth          pgtype.Int4        `json:"card_exp_month"`
	CardExpYear           pgtype.Int4        `json:"card_exp_year"`
}

type Company struct {
	ID                              pgtype.UUID        `json:"id"`
	AdminUserID                     pgtype.UUID        `json:"admin_user_id"`
	CompanyName                     string             `json:"company_name"`
	Cui                             string             `json:"cui"`
	CompanyType                     CompanyType        `json:"company_type"`
	LegalRepresentative             string             `json:"legal_representative"`
	ContactEmail                    string             `json:"contact_email"`
	ContactPhone                    string             `json:"contact_phone"`
	Address                         string             `json:"address"`
	City                            string             `json:"city"`
	County                          string             `json:"county"`
	Description                     pgtype.Text        `json:"description"`
	LogoUrl                         pgtype.Text        `json:"logo_url"`
	Status                          CompanyStatus      `json:"status"`
	RejectionReason                 pgtype.Text        `json:"rejection_reason"`
	MaxServiceRadiusKm              pgtype.Int4        `json:"max_service_radius_km"`
	RatingAvg                       pgtype.Numeric     `json:"rating_avg"`
	TotalJobsCompleted              pgtype.Int4        `json:"total_jobs_completed"`
	ApprovedAt                      pgtype.Timestamptz `json:"approved_at"`
	CreatedAt                       pgtype.Timestamptz `json:"created_at"`
	UpdatedAt                       pgtype.Timestamptz `json:"updated_at"`
	ClaimToken                      pgtype.Text        `json:"claim_token"`
	StripeConnectAccountID          pgtype.Text        `json:"stripe_connect_account_id"`
	StripeConnectOnboardingComplete pgtype.Bool        `json:"stripe_connect_onboarding_complete"`
	StripeConnectChargesEnabled     pgtype.Bool        `json:"stripe_connect_charges_enabled"`
	StripeConnectPayoutsEnabled     pgtype.Bool        `json:"stripe_connect_payouts_enabled"`
}

type CompanyDocument struct {
	ID              pgtype.UUID        `json:"id"`
	CompanyID       pgtype.UUID        `json:"company_id"`
	DocumentType    string             `json:"document_type"`
	FileUrl         string             `json:"file_url"`
	FileName        string             `json:"file_name"`
	UploadedAt      pgtype.Timestamptz `json:"uploaded_at"`
	Status          string             `json:"status"`
	ReviewedAt      pgtype.Timestamptz `json:"reviewed_at"`
	ReviewedBy      pgtype.UUID        `json:"reviewed_by"`
	RejectionReason pgtype.Text        `json:"rejection_reason"`
}

type CompanyPayout struct {
	ID               pgtype.UUID        `json:"id"`
	CompanyID        pgtype.UUID        `json:"company_id"`
	StripeTransferID pgtype.Text        `json:"stripe_transfer_id"`
	StripePayoutID   pgtype.Text        `json:"stripe_payout_id"`
	Amount           int32              `json:"amount"`
	Currency         string             `json:"currency"`
	PeriodFrom       pgtype.Date        `json:"period_from"`
	PeriodTo         pgtype.Date        `json:"period_to"`
	BookingCount     int32              `json:"booking_count"`
	Status           PayoutStatus       `json:"status"`
	PaidAt           pgtype.Timestamptz `json:"paid_at"`
	FailureReason    pgtype.Text        `json:"failure_reason"`
	CreatedAt        pgtype.Timestamptz `json:"created_at"`
	UpdatedAt        pgtype.Timestamptz `json:"updated_at"`
}

type CompanyServiceArea struct {
	ID         pgtype.UUID        `json:"id"`
	CompanyID  pgtype.UUID        `json:"company_id"`
	CityAreaID pgtype.UUID        `json:"city_area_id"`
	CreatedAt  pgtype.Timestamptz `json:"created_at"`
}

type CompanyWorkSchedule struct {
	ID        pgtype.UUID `json:"id"`
	CompanyID pgtype.UUID `json:"company_id"`
	DayOfWeek int32       `json:"day_of_week"`
	StartTime pgtype.Time `json:"start_time"`
	EndTime   pgtype.Time `json:"end_time"`
	IsWorkDay bool        `json:"is_work_day"`
}

type EmailOtpCode struct {
	ID        pgtype.UUID        `json:"id"`
	Email     string             `json:"email"`
	Code      string             `json:"code"`
	Role      string             `json:"role"`
	ExpiresAt pgtype.Timestamptz `json:"expires_at"`
	UsedAt    pgtype.Timestamptz `json:"used_at"`
	CreatedAt pgtype.Timestamptz `json:"created_at"`
}

type EnabledCity struct {
	ID        pgtype.UUID        `json:"id"`
	Name      string             `json:"name"`
	County    string             `json:"county"`
	IsActive  bool               `json:"is_active"`
	CreatedAt pgtype.Timestamptz `json:"created_at"`
}

type Invoice struct {
	ID                    pgtype.UUID        `json:"id"`
	InvoiceType           InvoiceType        `json:"invoice_type"`
	InvoiceNumber         pgtype.Text        `json:"invoice_number"`
	FactureazaID          pgtype.Text        `json:"factureaza_id"`
	FactureazaDownloadUrl pgtype.Text        `json:"factureaza_download_url"`
	SellerCompanyName     string             `json:"seller_company_name"`
	SellerCui             string             `json:"seller_cui"`
	SellerRegNumber       pgtype.Text        `json:"seller_reg_number"`
	SellerAddress         string             `json:"seller_address"`
	SellerCity            string             `json:"seller_city"`
	SellerCounty          string             `json:"seller_county"`
	SellerIsVatPayer      bool               `json:"seller_is_vat_payer"`
	SellerBankName        pgtype.Text        `json:"seller_bank_name"`
	SellerIban            pgtype.Text        `json:"seller_iban"`
	BuyerName             string             `json:"buyer_name"`
	BuyerCui              pgtype.Text        `json:"buyer_cui"`
	BuyerRegNumber        pgtype.Text        `json:"buyer_reg_number"`
	BuyerAddress          pgtype.Text        `json:"buyer_address"`
	BuyerCity             pgtype.Text        `json:"buyer_city"`
	BuyerCounty           pgtype.Text        `json:"buyer_county"`
	BuyerIsVatPayer       pgtype.Bool        `json:"buyer_is_vat_payer"`
	BuyerEmail            pgtype.Text        `json:"buyer_email"`
	SubtotalAmount        int32              `json:"subtotal_amount"`
	VatRate               pgtype.Numeric     `json:"vat_rate"`
	VatAmount             int32              `json:"vat_amount"`
	TotalAmount           int32              `json:"total_amount"`
	Currency              string             `json:"currency"`
	BookingID             pgtype.UUID        `json:"booking_id"`
	PaymentTransactionID  pgtype.UUID        `json:"payment_transaction_id"`
	CompanyID             pgtype.UUID        `json:"company_id"`
	ClientUserID          pgtype.UUID        `json:"client_user_id"`
	EfacturaStatus        pgtype.Text        `json:"efactura_status"`
	EfacturaIndex         pgtype.Text        `json:"efactura_index"`
	Status                InvoiceStatus      `json:"status"`
	IssuedAt              pgtype.Timestamptz `json:"issued_at"`
	DueDate               pgtype.Date        `json:"due_date"`
	Notes                 pgtype.Text        `json:"notes"`
	CreatedAt             pgtype.Timestamptz `json:"created_at"`
	UpdatedAt             pgtype.Timestamptz `json:"updated_at"`
}

type InvoiceLineItem struct {
	ID               pgtype.UUID    `json:"id"`
	InvoiceID        pgtype.UUID    `json:"invoice_id"`
	DescriptionRo    string         `json:"description_ro"`
	DescriptionEn    pgtype.Text    `json:"description_en"`
	Quantity         pgtype.Numeric `json:"quantity"`
	UnitPrice        int32          `json:"unit_price"`
	VatRate          pgtype.Numeric `json:"vat_rate"`
	VatAmount        int32          `json:"vat_amount"`
	LineTotal        int32          `json:"line_total"`
	LineTotalWithVat int32          `json:"line_total_with_vat"`
	SortOrder        pgtype.Int4    `json:"sort_order"`
}

type InvoiceSequence struct {
	ID            pgtype.UUID `json:"id"`
	CompanyID     pgtype.UUID `json:"company_id"`
	Prefix        string      `json:"prefix"`
	CurrentNumber int32       `json:"current_number"`
	Year          int32       `json:"year"`
}

type Notification struct {
	ID        pgtype.UUID        `json:"id"`
	UserID    pgtype.UUID        `json:"user_id"`
	Type      NotificationType   `json:"type"`
	Title     string             `json:"title"`
	Body      string             `json:"body"`
	Data      []byte             `json:"data"`
	IsRead    pgtype.Bool        `json:"is_read"`
	IsPushed  pgtype.Bool        `json:"is_pushed"`
	CreatedAt pgtype.Timestamptz `json:"created_at"`
}

type PaymentTransaction struct {
	ID                    pgtype.UUID              `json:"id"`
	BookingID             pgtype.UUID              `json:"booking_id"`
	StripePaymentIntentID string                   `json:"stripe_payment_intent_id"`
	StripeChargeID        pgtype.Text              `json:"stripe_charge_id"`
	AmountTotal           int32                    `json:"amount_total"`
	AmountCompany         int32                    `json:"amount_company"`
	AmountPlatformFee     int32                    `json:"amount_platform_fee"`
	Currency              string                   `json:"currency"`
	Status                PaymentTransactionStatus `json:"status"`
	FailureReason         pgtype.Text              `json:"failure_reason"`
	RefundAmount          pgtype.Int4              `json:"refund_amount"`
	StripeRefundID        pgtype.Text              `json:"stripe_refund_id"`
	Metadata              []byte                   `json:"metadata"`
	CreatedAt             pgtype.Timestamptz       `json:"created_at"`
	UpdatedAt             pgtype.Timestamptz       `json:"updated_at"`
}

type PayoutLineItem struct {
	ID                   pgtype.UUID        `json:"id"`
	PayoutID             pgtype.UUID        `json:"payout_id"`
	PaymentTransactionID pgtype.UUID        `json:"payment_transaction_id"`
	BookingID            pgtype.UUID        `json:"booking_id"`
	AmountGross          int32              `json:"amount_gross"`
	AmountCommission     int32              `json:"amount_commission"`
	AmountNet            int32              `json:"amount_net"`
	CreatedAt            pgtype.Timestamptz `json:"created_at"`
}

type PersonalityAssessment struct {
	ID                  pgtype.UUID        `json:"id"`
	CleanerID           pgtype.UUID        `json:"cleaner_id"`
	TrustScore          int32              `json:"trust_score"`
	MoralityScore       int32              `json:"morality_score"`
	AltruismScore       int32              `json:"altruism_score"`
	OrderlinessScore    int32              `json:"orderliness_score"`
	DutifulnessScore    int32              `json:"dutifulness_score"`
	SelfDisciplineScore int32              `json:"self_discipline_score"`
	CautiousnessScore   int32              `json:"cautiousness_score"`
	IntegrityAvg        pgtype.Numeric     `json:"integrity_avg"`
	WorkQualityAvg      pgtype.Numeric     `json:"work_quality_avg"`
	HasConcerns         bool               `json:"has_concerns"`
	FlaggedFacets       []string           `json:"flagged_facets"`
	CompletedAt         pgtype.Timestamptz `json:"completed_at"`
	CreatedAt           pgtype.Timestamptz `json:"created_at"`
}

type PersonalityAssessmentAnswer struct {
	ID             pgtype.UUID `json:"id"`
	AssessmentID   pgtype.UUID `json:"assessment_id"`
	QuestionNumber int32       `json:"question_number"`
	FacetCode      string      `json:"facet_code"`
	IsReverseKeyed bool        `json:"is_reverse_keyed"`
	RawResponse    int32       `json:"raw_response"`
	ScoredValue    int32       `json:"scored_value"`
}

type PersonalityInsight struct {
	ID                pgtype.UUID        `json:"id"`
	AssessmentID      pgtype.UUID        `json:"assessment_id"`
	Summary           string             `json:"summary"`
	Strengths         []string           `json:"strengths"`
	Concerns          []string           `json:"concerns"`
	TeamFitAnalysis   string             `json:"team_fit_analysis"`
	RecommendedAction string             `json:"recommended_action"`
	Confidence        string             `json:"confidence"`
	AiModel           string             `json:"ai_model"`
	AiProvider        string             `json:"ai_provider"`
	GeneratedAt       pgtype.Timestamptz `json:"generated_at"`
}

type PlatformEvent struct {
	ID         pgtype.UUID        `json:"id"`
	EventType  string             `json:"event_type"`
	EntityType pgtype.Text        `json:"entity_type"`
	EntityID   pgtype.UUID        `json:"entity_id"`
	Metadata   []byte             `json:"metadata"`
	CreatedAt  pgtype.Timestamptz `json:"created_at"`
}

type PlatformLegalEntity struct {
	ID             pgtype.UUID        `json:"id"`
	CompanyName    string             `json:"company_name"`
	Cui            string             `json:"cui"`
	RegNumber      string             `json:"reg_number"`
	Address        string             `json:"address"`
	City           string             `json:"city"`
	County         string             `json:"county"`
	IsVatPayer     bool               `json:"is_vat_payer"`
	BankName       pgtype.Text        `json:"bank_name"`
	Iban           pgtype.Text        `json:"iban"`
	CreatedAt      pgtype.Timestamptz `json:"created_at"`
	UpdatedAt      pgtype.Timestamptz `json:"updated_at"`
	SingletonGuard bool               `json:"singleton_guard"`
}

type PlatformSetting struct {
	Key         string             `json:"key"`
	Value       string             `json:"value"`
	ValueType   string             `json:"value_type"`
	Description pgtype.Text        `json:"description"`
	UpdatedAt   pgtype.Timestamptz `json:"updated_at"`
}

type RecurringBookingGroup struct {
	ID                          pgtype.UUID        `json:"id"`
	ClientUserID                pgtype.UUID        `json:"client_user_id"`
	CompanyID                   pgtype.UUID        `json:"company_id"`
	PreferredCleanerID          pgtype.UUID        `json:"preferred_cleaner_id"`
	AddressID                   pgtype.UUID        `json:"address_id"`
	RecurrenceType              RecurrenceType     `json:"recurrence_type"`
	DayOfWeek                   pgtype.Int4        `json:"day_of_week"`
	PreferredTime               pgtype.Time        `json:"preferred_time"`
	ServiceType                 ServiceType        `json:"service_type"`
	PropertyType                pgtype.Text        `json:"property_type"`
	NumRooms                    pgtype.Int4        `json:"num_rooms"`
	NumBathrooms                pgtype.Int4        `json:"num_bathrooms"`
	AreaSqm                     pgtype.Int4        `json:"area_sqm"`
	HasPets                     pgtype.Bool        `json:"has_pets"`
	SpecialInstructions         pgtype.Text        `json:"special_instructions"`
	HourlyRate                  pgtype.Numeric     `json:"hourly_rate"`
	EstimatedTotalPerOccurrence pgtype.Numeric     `json:"estimated_total_per_occurrence"`
	IsActive                    pgtype.Bool        `json:"is_active"`
	CancelledAt                 pgtype.Timestamptz `json:"cancelled_at"`
	CancellationReason          pgtype.Text        `json:"cancellation_reason"`
	CreatedAt                   pgtype.Timestamptz `json:"created_at"`
	UpdatedAt                   pgtype.Timestamptz `json:"updated_at"`
}

type RecurringGroupExtra struct {
	ID       pgtype.UUID `json:"id"`
	GroupID  pgtype.UUID `json:"group_id"`
	ExtraID  pgtype.UUID `json:"extra_id"`
	Quantity pgtype.Int4 `json:"quantity"`
}

type RefundRequest struct {
	ID                   pgtype.UUID        `json:"id"`
	BookingID            pgtype.UUID        `json:"booking_id"`
	PaymentTransactionID pgtype.UUID        `json:"payment_transaction_id"`
	RequestedByUserID    pgtype.UUID        `json:"requested_by_user_id"`
	ApprovedByUserID     pgtype.UUID        `json:"approved_by_user_id"`
	Amount               int32              `json:"amount"`
	Reason               string             `json:"reason"`
	Status               RefundStatus       `json:"status"`
	StripeRefundID       pgtype.Text        `json:"stripe_refund_id"`
	ProcessedAt          pgtype.Timestamptz `json:"processed_at"`
	CreatedAt            pgtype.Timestamptz `json:"created_at"`
	UpdatedAt            pgtype.Timestamptz `json:"updated_at"`
}

type Review struct {
	ID                pgtype.UUID        `json:"id"`
	BookingID         pgtype.UUID        `json:"booking_id"`
	ReviewerUserID    pgtype.UUID        `json:"reviewer_user_id"`
	ReviewedUserID    pgtype.UUID        `json:"reviewed_user_id"`
	ReviewedCleanerID pgtype.UUID        `json:"reviewed_cleaner_id"`
	Rating            int32              `json:"rating"`
	Comment           pgtype.Text        `json:"comment"`
	ReviewType        string             `json:"review_type"`
	CreatedAt         pgtype.Timestamptz `json:"created_at"`
}

type ServiceDefinition struct {
	ID                 pgtype.UUID        `json:"id"`
	ServiceType        ServiceType        `json:"service_type"`
	NameRo             string             `json:"name_ro"`
	NameEn             string             `json:"name_en"`
	DescriptionRo      pgtype.Text        `json:"description_ro"`
	DescriptionEn      pgtype.Text        `json:"description_en"`
	BasePricePerHour   pgtype.Numeric     `json:"base_price_per_hour"`
	MinHours           pgtype.Numeric     `json:"min_hours"`
	Icon               pgtype.Text        `json:"icon"`
	IsActive           pgtype.Bool        `json:"is_active"`
	CreatedAt          pgtype.Timestamptz `json:"created_at"`
	HoursPerRoom       pgtype.Numeric     `json:"hours_per_room"`
	HoursPerBathroom   pgtype.Numeric     `json:"hours_per_bathroom"`
	HoursPer100Sqm     pgtype.Numeric     `json:"hours_per_100_sqm"`
	HouseMultiplier    pgtype.Numeric     `json:"house_multiplier"`
	PetDurationMinutes int32              `json:"pet_duration_minutes"`
	IncludedItems      []string           `json:"included_items"`
}

type ServiceExtra struct {
	ID              pgtype.UUID    `json:"id"`
	NameRo          string         `json:"name_ro"`
	NameEn          string         `json:"name_en"`
	Price           pgtype.Numeric `json:"price"`
	Icon            pgtype.Text    `json:"icon"`
	IsActive        pgtype.Bool    `json:"is_active"`
	DurationMinutes int32          `json:"duration_minutes"`
}

type User struct {
	ID                pgtype.UUID        `json:"id"`
	Email             string             `json:"email"`
	FullName          string             `json:"full_name"`
	Phone             pgtype.Text        `json:"phone"`
	AvatarUrl         pgtype.Text        `json:"avatar_url"`
	Role              UserRole           `json:"role"`
	Status            UserStatus         `json:"status"`
	GoogleID          pgtype.Text        `json:"google_id"`
	FcmToken          pgtype.Text        `json:"fcm_token"`
	PreferredLanguage pgtype.Text        `json:"preferred_language"`
	CreatedAt         pgtype.Timestamptz `json:"created_at"`
	UpdatedAt         pgtype.Timestamptz `json:"updated_at"`
	StripeCustomerID  pgtype.Text        `json:"stripe_customer_id"`
}

type WaitlistLead struct {
	ID          pgtype.UUID        `json:"id"`
	LeadType    WaitlistLeadType   `json:"lead_type"`
	Name        string             `json:"name"`
	Email       string             `json:"email"`
	Phone       pgtype.Text        `json:"phone"`
	City        pgtype.Text        `json:"city"`
	CompanyName pgtype.Text        `json:"company_name"`
	Message     pgtype.Text        `json:"message"`
	CreatedAt   pgtype.Timestamptz `json:"created_at"`
}
