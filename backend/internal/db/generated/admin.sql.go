// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: admin.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createPlatformEvent = `-- name: CreatePlatformEvent :exec
INSERT INTO platform_events (event_type, entity_type, entity_id, metadata) VALUES ($1, $2, $3, $4)
`

type CreatePlatformEventParams struct {
	EventType  string      `json:"event_type"`
	EntityType pgtype.Text `json:"entity_type"`
	EntityID   pgtype.UUID `json:"entity_id"`
	Metadata   []byte      `json:"metadata"`
}

func (q *Queries) CreatePlatformEvent(ctx context.Context, arg CreatePlatformEventParams) error {
	_, err := q.db.Exec(ctx, createPlatformEvent,
		arg.EventType,
		arg.EntityType,
		arg.EntityID,
		arg.Metadata,
	)
	return err
}

const getBookingCountByStatus = `-- name: GetBookingCountByStatus :many
SELECT status, COUNT(*) AS count FROM bookings GROUP BY status
`

type GetBookingCountByStatusRow struct {
	Status BookingStatus `json:"status"`
	Count  int64         `json:"count"`
}

func (q *Queries) GetBookingCountByStatus(ctx context.Context) ([]GetBookingCountByStatusRow, error) {
	rows, err := q.db.Query(ctx, getBookingCountByStatus)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetBookingCountByStatusRow
	for rows.Next() {
		var i GetBookingCountByStatusRow
		if err := rows.Scan(&i.Status, &i.Count); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCompanyPerformance = `-- name: GetCompanyPerformance :many
SELECT
    c.id, c.company_name, c.rating_avg, c.total_jobs_completed,
    COUNT(b.id) AS active_bookings
FROM companies c
LEFT JOIN bookings b ON c.id = b.company_id AND b.status IN ('assigned', 'confirmed', 'in_progress')
WHERE c.status = 'approved'
GROUP BY c.id
ORDER BY c.total_jobs_completed DESC
LIMIT $1 OFFSET $2
`

type GetCompanyPerformanceParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

type GetCompanyPerformanceRow struct {
	ID                 pgtype.UUID    `json:"id"`
	CompanyName        string         `json:"company_name"`
	RatingAvg          pgtype.Numeric `json:"rating_avg"`
	TotalJobsCompleted pgtype.Int4    `json:"total_jobs_completed"`
	ActiveBookings     int64          `json:"active_bookings"`
}

func (q *Queries) GetCompanyPerformance(ctx context.Context, arg GetCompanyPerformanceParams) ([]GetCompanyPerformanceRow, error) {
	rows, err := q.db.Query(ctx, getCompanyPerformance, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetCompanyPerformanceRow
	for rows.Next() {
		var i GetCompanyPerformanceRow
		if err := rows.Scan(
			&i.ID,
			&i.CompanyName,
			&i.RatingAvg,
			&i.TotalJobsCompleted,
			&i.ActiveBookings,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPlatformStats = `-- name: GetPlatformStats :one
SELECT
    (SELECT COUNT(*) FROM users) AS total_users,
    (SELECT COUNT(*) FROM companies WHERE status = 'approved') AS active_companies,
    (SELECT COUNT(*) FROM cleaners WHERE status = 'active') AS active_cleaners,
    (SELECT COUNT(*) FROM bookings) AS total_bookings,
    (SELECT COUNT(*) FROM bookings WHERE status = 'completed') AS completed_bookings,
    (SELECT COALESCE(SUM(COALESCE(final_total, estimated_total)), 0) FROM bookings WHERE status = 'completed') AS total_revenue,
    (SELECT COALESCE(SUM(platform_commission_amount), 0) FROM bookings WHERE status = 'completed') AS total_commission,
    (SELECT COUNT(*) FROM bookings WHERE created_at >= DATE_TRUNC('month', CURRENT_DATE)) AS bookings_this_month,
    (SELECT COALESCE(SUM(COALESCE(final_total, estimated_total)), 0) FROM bookings WHERE status = 'completed' AND completed_at >= DATE_TRUNC('month', CURRENT_DATE)) AS revenue_this_month,
    (SELECT COALESCE(SUM(platform_commission_amount), 0) FROM bookings WHERE status = 'completed' AND completed_at >= DATE_TRUNC('month', CURRENT_DATE)) AS commission_this_month,
    (SELECT COUNT(*) FROM users WHERE created_at >= DATE_TRUNC('month', CURRENT_DATE)) AS new_clients_this_month,
    (SELECT COUNT(*) FROM companies WHERE created_at >= DATE_TRUNC('month', CURRENT_DATE)) AS new_companies_this_month,
    (SELECT COALESCE(AVG(rating), 0) FROM reviews) AS average_rating
`

type GetPlatformStatsRow struct {
	TotalUsers            int64       `json:"total_users"`
	ActiveCompanies       int64       `json:"active_companies"`
	ActiveCleaners        int64       `json:"active_cleaners"`
	TotalBookings         int64       `json:"total_bookings"`
	CompletedBookings     int64       `json:"completed_bookings"`
	TotalRevenue          interface{} `json:"total_revenue"`
	TotalCommission       interface{} `json:"total_commission"`
	BookingsThisMonth     int64       `json:"bookings_this_month"`
	RevenueThisMonth      interface{} `json:"revenue_this_month"`
	CommissionThisMonth   interface{} `json:"commission_this_month"`
	NewClientsThisMonth   int64       `json:"new_clients_this_month"`
	NewCompaniesThisMonth int64       `json:"new_companies_this_month"`
	AverageRating         interface{} `json:"average_rating"`
}

func (q *Queries) GetPlatformStats(ctx context.Context) (GetPlatformStatsRow, error) {
	row := q.db.QueryRow(ctx, getPlatformStats)
	var i GetPlatformStatsRow
	err := row.Scan(
		&i.TotalUsers,
		&i.ActiveCompanies,
		&i.ActiveCleaners,
		&i.TotalBookings,
		&i.CompletedBookings,
		&i.TotalRevenue,
		&i.TotalCommission,
		&i.BookingsThisMonth,
		&i.RevenueThisMonth,
		&i.CommissionThisMonth,
		&i.NewClientsThisMonth,
		&i.NewCompaniesThisMonth,
		&i.AverageRating,
	)
	return i, err
}

const getRevenueByMonth = `-- name: GetRevenueByMonth :many
SELECT
    TO_CHAR(DATE_TRUNC('month', completed_at), 'YYYY-MM') AS month,
    COALESCE(SUM(COALESCE(final_total, estimated_total)), 0)::bigint AS total_revenue,
    COALESCE(SUM(COALESCE(platform_commission_amount, 0)), 0)::bigint AS commission_revenue,
    COUNT(*) AS booking_count
FROM bookings
WHERE status = 'completed' AND completed_at IS NOT NULL
GROUP BY TO_CHAR(DATE_TRUNC('month', completed_at), 'YYYY-MM')
ORDER BY month DESC
LIMIT $1
`

type GetRevenueByMonthRow struct {
	Month             string `json:"month"`
	TotalRevenue      int64  `json:"total_revenue"`
	CommissionRevenue int64  `json:"commission_revenue"`
	BookingCount      int64  `json:"booking_count"`
}

func (q *Queries) GetRevenueByMonth(ctx context.Context, limit int32) ([]GetRevenueByMonthRow, error) {
	rows, err := q.db.Query(ctx, getRevenueByMonth, limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetRevenueByMonthRow
	for rows.Next() {
		var i GetRevenueByMonthRow
		if err := rows.Scan(
			&i.Month,
			&i.TotalRevenue,
			&i.CommissionRevenue,
			&i.BookingCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listAllBookings = `-- name: ListAllBookings :many
SELECT id, reference_code, client_user_id, company_id, cleaner_id, address_id, service_type, scheduled_date, scheduled_start_time, estimated_duration_hours, property_type, num_rooms, num_bathrooms, area_sqm, has_pets, special_instructions, hourly_rate, estimated_total, final_total, platform_commission_pct, platform_commission_amount, status, started_at, completed_at, cancelled_at, cancellation_reason, stripe_payment_intent_id, payment_status, paid_at, created_at, updated_at, recurring_group_id, occurrence_number FROM bookings ORDER BY created_at DESC LIMIT $1 OFFSET $2
`

type ListAllBookingsParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

func (q *Queries) ListAllBookings(ctx context.Context, arg ListAllBookingsParams) ([]Booking, error) {
	rows, err := q.db.Query(ctx, listAllBookings, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Booking
	for rows.Next() {
		var i Booking
		if err := rows.Scan(
			&i.ID,
			&i.ReferenceCode,
			&i.ClientUserID,
			&i.CompanyID,
			&i.CleanerID,
			&i.AddressID,
			&i.ServiceType,
			&i.ScheduledDate,
			&i.ScheduledStartTime,
			&i.EstimatedDurationHours,
			&i.PropertyType,
			&i.NumRooms,
			&i.NumBathrooms,
			&i.AreaSqm,
			&i.HasPets,
			&i.SpecialInstructions,
			&i.HourlyRate,
			&i.EstimatedTotal,
			&i.FinalTotal,
			&i.PlatformCommissionPct,
			&i.PlatformCommissionAmount,
			&i.Status,
			&i.StartedAt,
			&i.CompletedAt,
			&i.CancelledAt,
			&i.CancellationReason,
			&i.StripePaymentIntentID,
			&i.PaymentStatus,
			&i.PaidAt,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.RecurringGroupID,
			&i.OccurrenceNumber,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
