// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: payments.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const countPaymentHistoryByUser = `-- name: CountPaymentHistoryByUser :one
SELECT COUNT(*) FROM payment_transactions pt
JOIN bookings b ON b.id = pt.booking_id
WHERE b.client_user_id = $1
`

func (q *Queries) CountPaymentHistoryByUser(ctx context.Context, clientUserID pgtype.UUID) (int64, error) {
	row := q.db.QueryRow(ctx, countPaymentHistoryByUser, clientUserID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createCompanyPayout = `-- name: CreateCompanyPayout :one

INSERT INTO company_payouts (company_id, amount, currency, period_from, period_to, booking_count, status)
VALUES ($1, $2, $3, $4, $5, $6, $7)
RETURNING id, company_id, stripe_transfer_id, stripe_payout_id, amount, currency, period_from, period_to, booking_count, status, paid_at, failure_reason, created_at, updated_at
`

type CreateCompanyPayoutParams struct {
	CompanyID    pgtype.UUID  `json:"company_id"`
	Amount       int32        `json:"amount"`
	Currency     string       `json:"currency"`
	PeriodFrom   pgtype.Date  `json:"period_from"`
	PeriodTo     pgtype.Date  `json:"period_to"`
	BookingCount int32        `json:"booking_count"`
	Status       PayoutStatus `json:"status"`
}

// ============================================
// COMPANY PAYOUTS
// ============================================
func (q *Queries) CreateCompanyPayout(ctx context.Context, arg CreateCompanyPayoutParams) (CompanyPayout, error) {
	row := q.db.QueryRow(ctx, createCompanyPayout,
		arg.CompanyID,
		arg.Amount,
		arg.Currency,
		arg.PeriodFrom,
		arg.PeriodTo,
		arg.BookingCount,
		arg.Status,
	)
	var i CompanyPayout
	err := row.Scan(
		&i.ID,
		&i.CompanyID,
		&i.StripeTransferID,
		&i.StripePayoutID,
		&i.Amount,
		&i.Currency,
		&i.PeriodFrom,
		&i.PeriodTo,
		&i.BookingCount,
		&i.Status,
		&i.PaidAt,
		&i.FailureReason,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createPaymentMethod = `-- name: CreatePaymentMethod :one
INSERT INTO client_payment_methods (user_id, stripe_payment_method_id, card_last_four, card_brand, is_default, card_exp_month, card_exp_year)
VALUES ($1, $2, $3, $4, $5, $6, $7)
RETURNING id, user_id, stripe_payment_method_id, card_last_four, card_brand, is_default, created_at, card_exp_month, card_exp_year
`

type CreatePaymentMethodParams struct {
	UserID                pgtype.UUID `json:"user_id"`
	StripePaymentMethodID pgtype.Text `json:"stripe_payment_method_id"`
	CardLastFour          pgtype.Text `json:"card_last_four"`
	CardBrand             pgtype.Text `json:"card_brand"`
	IsDefault             pgtype.Bool `json:"is_default"`
	CardExpMonth          pgtype.Int4 `json:"card_exp_month"`
	CardExpYear           pgtype.Int4 `json:"card_exp_year"`
}

func (q *Queries) CreatePaymentMethod(ctx context.Context, arg CreatePaymentMethodParams) (ClientPaymentMethod, error) {
	row := q.db.QueryRow(ctx, createPaymentMethod,
		arg.UserID,
		arg.StripePaymentMethodID,
		arg.CardLastFour,
		arg.CardBrand,
		arg.IsDefault,
		arg.CardExpMonth,
		arg.CardExpYear,
	)
	var i ClientPaymentMethod
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.StripePaymentMethodID,
		&i.CardLastFour,
		&i.CardBrand,
		&i.IsDefault,
		&i.CreatedAt,
		&i.CardExpMonth,
		&i.CardExpYear,
	)
	return i, err
}

const createPaymentTransaction = `-- name: CreatePaymentTransaction :one

INSERT INTO payment_transactions (
  booking_id, stripe_payment_intent_id, amount_total, amount_company,
  amount_platform_fee, currency, status, metadata
) VALUES ($1, $2, $3, $4, $5, $6, $7, $8)
RETURNING id, booking_id, stripe_payment_intent_id, stripe_charge_id, amount_total, amount_company, amount_platform_fee, currency, status, failure_reason, refund_amount, stripe_refund_id, metadata, created_at, updated_at
`

type CreatePaymentTransactionParams struct {
	BookingID             pgtype.UUID              `json:"booking_id"`
	StripePaymentIntentID string                   `json:"stripe_payment_intent_id"`
	AmountTotal           int32                    `json:"amount_total"`
	AmountCompany         int32                    `json:"amount_company"`
	AmountPlatformFee     int32                    `json:"amount_platform_fee"`
	Currency              string                   `json:"currency"`
	Status                PaymentTransactionStatus `json:"status"`
	Metadata              []byte                   `json:"metadata"`
}

// ============================================
// PAYMENT TRANSACTIONS
// ============================================
func (q *Queries) CreatePaymentTransaction(ctx context.Context, arg CreatePaymentTransactionParams) (PaymentTransaction, error) {
	row := q.db.QueryRow(ctx, createPaymentTransaction,
		arg.BookingID,
		arg.StripePaymentIntentID,
		arg.AmountTotal,
		arg.AmountCompany,
		arg.AmountPlatformFee,
		arg.Currency,
		arg.Status,
		arg.Metadata,
	)
	var i PaymentTransaction
	err := row.Scan(
		&i.ID,
		&i.BookingID,
		&i.StripePaymentIntentID,
		&i.StripeChargeID,
		&i.AmountTotal,
		&i.AmountCompany,
		&i.AmountPlatformFee,
		&i.Currency,
		&i.Status,
		&i.FailureReason,
		&i.RefundAmount,
		&i.StripeRefundID,
		&i.Metadata,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createPayoutLineItem = `-- name: CreatePayoutLineItem :one

INSERT INTO payout_line_items (payout_id, payment_transaction_id, booking_id, amount_gross, amount_commission, amount_net)
VALUES ($1, $2, $3, $4, $5, $6) RETURNING id, payout_id, payment_transaction_id, booking_id, amount_gross, amount_commission, amount_net, created_at
`

type CreatePayoutLineItemParams struct {
	PayoutID             pgtype.UUID `json:"payout_id"`
	PaymentTransactionID pgtype.UUID `json:"payment_transaction_id"`
	BookingID            pgtype.UUID `json:"booking_id"`
	AmountGross          int32       `json:"amount_gross"`
	AmountCommission     int32       `json:"amount_commission"`
	AmountNet            int32       `json:"amount_net"`
}

// ============================================
// PAYOUT LINE ITEMS
// ============================================
func (q *Queries) CreatePayoutLineItem(ctx context.Context, arg CreatePayoutLineItemParams) (PayoutLineItem, error) {
	row := q.db.QueryRow(ctx, createPayoutLineItem,
		arg.PayoutID,
		arg.PaymentTransactionID,
		arg.BookingID,
		arg.AmountGross,
		arg.AmountCommission,
		arg.AmountNet,
	)
	var i PayoutLineItem
	err := row.Scan(
		&i.ID,
		&i.PayoutID,
		&i.PaymentTransactionID,
		&i.BookingID,
		&i.AmountGross,
		&i.AmountCommission,
		&i.AmountNet,
		&i.CreatedAt,
	)
	return i, err
}

const createRefundRequest = `-- name: CreateRefundRequest :one

INSERT INTO refund_requests (booking_id, payment_transaction_id, requested_by_user_id, amount, reason, status)
VALUES ($1, $2, $3, $4, $5, $6) RETURNING id, booking_id, payment_transaction_id, requested_by_user_id, approved_by_user_id, amount, reason, status, stripe_refund_id, processed_at, created_at, updated_at
`

type CreateRefundRequestParams struct {
	BookingID            pgtype.UUID  `json:"booking_id"`
	PaymentTransactionID pgtype.UUID  `json:"payment_transaction_id"`
	RequestedByUserID    pgtype.UUID  `json:"requested_by_user_id"`
	Amount               int32        `json:"amount"`
	Reason               string       `json:"reason"`
	Status               RefundStatus `json:"status"`
}

// ============================================
// REFUND REQUESTS
// ============================================
func (q *Queries) CreateRefundRequest(ctx context.Context, arg CreateRefundRequestParams) (RefundRequest, error) {
	row := q.db.QueryRow(ctx, createRefundRequest,
		arg.BookingID,
		arg.PaymentTransactionID,
		arg.RequestedByUserID,
		arg.Amount,
		arg.Reason,
		arg.Status,
	)
	var i RefundRequest
	err := row.Scan(
		&i.ID,
		&i.BookingID,
		&i.PaymentTransactionID,
		&i.RequestedByUserID,
		&i.ApprovedByUserID,
		&i.Amount,
		&i.Reason,
		&i.Status,
		&i.StripeRefundID,
		&i.ProcessedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deletePaymentMethod = `-- name: DeletePaymentMethod :exec
DELETE FROM client_payment_methods WHERE id = $1
`

func (q *Queries) DeletePaymentMethod(ctx context.Context, id pgtype.UUID) error {
	_, err := q.db.Exec(ctx, deletePaymentMethod, id)
	return err
}

const getCompanyStripeConnect = `-- name: GetCompanyStripeConnect :one

SELECT stripe_connect_account_id, stripe_connect_onboarding_complete, stripe_connect_charges_enabled, stripe_connect_payouts_enabled
FROM companies WHERE id = $1
`

type GetCompanyStripeConnectRow struct {
	StripeConnectAccountID          pgtype.Text `json:"stripe_connect_account_id"`
	StripeConnectOnboardingComplete pgtype.Bool `json:"stripe_connect_onboarding_complete"`
	StripeConnectChargesEnabled     pgtype.Bool `json:"stripe_connect_charges_enabled"`
	StripeConnectPayoutsEnabled     pgtype.Bool `json:"stripe_connect_payouts_enabled"`
}

// ============================================
// STRIPE CONNECT (Companies)
// ============================================
func (q *Queries) GetCompanyStripeConnect(ctx context.Context, id pgtype.UUID) (GetCompanyStripeConnectRow, error) {
	row := q.db.QueryRow(ctx, getCompanyStripeConnect, id)
	var i GetCompanyStripeConnectRow
	err := row.Scan(
		&i.StripeConnectAccountID,
		&i.StripeConnectOnboardingComplete,
		&i.StripeConnectChargesEnabled,
		&i.StripeConnectPayoutsEnabled,
	)
	return i, err
}

const getPaymentMethodByStripeID = `-- name: GetPaymentMethodByStripeID :one
SELECT id, user_id, stripe_payment_method_id, card_last_four, card_brand, is_default, created_at, card_exp_month, card_exp_year FROM client_payment_methods WHERE stripe_payment_method_id = $1
`

func (q *Queries) GetPaymentMethodByStripeID(ctx context.Context, stripePaymentMethodID pgtype.Text) (ClientPaymentMethod, error) {
	row := q.db.QueryRow(ctx, getPaymentMethodByStripeID, stripePaymentMethodID)
	var i ClientPaymentMethod
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.StripePaymentMethodID,
		&i.CardLastFour,
		&i.CardBrand,
		&i.IsDefault,
		&i.CreatedAt,
		&i.CardExpMonth,
		&i.CardExpYear,
	)
	return i, err
}

const getPaymentTransactionByBookingID = `-- name: GetPaymentTransactionByBookingID :one
SELECT id, booking_id, stripe_payment_intent_id, stripe_charge_id, amount_total, amount_company, amount_platform_fee, currency, status, failure_reason, refund_amount, stripe_refund_id, metadata, created_at, updated_at FROM payment_transactions WHERE booking_id = $1 ORDER BY created_at DESC LIMIT 1
`

func (q *Queries) GetPaymentTransactionByBookingID(ctx context.Context, bookingID pgtype.UUID) (PaymentTransaction, error) {
	row := q.db.QueryRow(ctx, getPaymentTransactionByBookingID, bookingID)
	var i PaymentTransaction
	err := row.Scan(
		&i.ID,
		&i.BookingID,
		&i.StripePaymentIntentID,
		&i.StripeChargeID,
		&i.AmountTotal,
		&i.AmountCompany,
		&i.AmountPlatformFee,
		&i.Currency,
		&i.Status,
		&i.FailureReason,
		&i.RefundAmount,
		&i.StripeRefundID,
		&i.Metadata,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getPaymentTransactionByStripePI = `-- name: GetPaymentTransactionByStripePI :one
SELECT id, booking_id, stripe_payment_intent_id, stripe_charge_id, amount_total, amount_company, amount_platform_fee, currency, status, failure_reason, refund_amount, stripe_refund_id, metadata, created_at, updated_at FROM payment_transactions WHERE stripe_payment_intent_id = $1
`

func (q *Queries) GetPaymentTransactionByStripePI(ctx context.Context, stripePaymentIntentID string) (PaymentTransaction, error) {
	row := q.db.QueryRow(ctx, getPaymentTransactionByStripePI, stripePaymentIntentID)
	var i PaymentTransaction
	err := row.Scan(
		&i.ID,
		&i.BookingID,
		&i.StripePaymentIntentID,
		&i.StripeChargeID,
		&i.AmountTotal,
		&i.AmountCompany,
		&i.AmountPlatformFee,
		&i.Currency,
		&i.Status,
		&i.FailureReason,
		&i.RefundAmount,
		&i.StripeRefundID,
		&i.Metadata,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getPayoutByID = `-- name: GetPayoutByID :one
SELECT id, company_id, stripe_transfer_id, stripe_payout_id, amount, currency, period_from, period_to, booking_count, status, paid_at, failure_reason, created_at, updated_at FROM company_payouts WHERE id = $1
`

func (q *Queries) GetPayoutByID(ctx context.Context, id pgtype.UUID) (CompanyPayout, error) {
	row := q.db.QueryRow(ctx, getPayoutByID, id)
	var i CompanyPayout
	err := row.Scan(
		&i.ID,
		&i.CompanyID,
		&i.StripeTransferID,
		&i.StripePayoutID,
		&i.Amount,
		&i.Currency,
		&i.PeriodFrom,
		&i.PeriodTo,
		&i.BookingCount,
		&i.Status,
		&i.PaidAt,
		&i.FailureReason,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getPlatformRevenueReport = `-- name: GetPlatformRevenueReport :one

SELECT
  COALESCE(SUM(pt.amount_total), 0)::BIGINT as total_revenue,
  COALESCE(SUM(pt.amount_platform_fee), 0)::BIGINT as total_commission,
  COUNT(DISTINCT pt.id)::BIGINT as booking_count
FROM payment_transactions pt
WHERE pt.status = 'succeeded'
  AND pt.created_at >= $1 AND pt.created_at <= $2
`

type GetPlatformRevenueReportParams struct {
	CreatedAt   pgtype.Timestamptz `json:"created_at"`
	CreatedAt_2 pgtype.Timestamptz `json:"created_at_2"`
}

type GetPlatformRevenueReportRow struct {
	TotalRevenue    int64 `json:"total_revenue"`
	TotalCommission int64 `json:"total_commission"`
	BookingCount    int64 `json:"booking_count"`
}

// ============================================
// PLATFORM REVENUE (Admin reporting)
// ============================================
func (q *Queries) GetPlatformRevenueReport(ctx context.Context, arg GetPlatformRevenueReportParams) (GetPlatformRevenueReportRow, error) {
	row := q.db.QueryRow(ctx, getPlatformRevenueReport, arg.CreatedAt, arg.CreatedAt_2)
	var i GetPlatformRevenueReportRow
	err := row.Scan(&i.TotalRevenue, &i.TotalCommission, &i.BookingCount)
	return i, err
}

const getRefundRequestByBookingID = `-- name: GetRefundRequestByBookingID :one
SELECT id, booking_id, payment_transaction_id, requested_by_user_id, approved_by_user_id, amount, reason, status, stripe_refund_id, processed_at, created_at, updated_at FROM refund_requests WHERE booking_id = $1 ORDER BY created_at DESC LIMIT 1
`

func (q *Queries) GetRefundRequestByBookingID(ctx context.Context, bookingID pgtype.UUID) (RefundRequest, error) {
	row := q.db.QueryRow(ctx, getRefundRequestByBookingID, bookingID)
	var i RefundRequest
	err := row.Scan(
		&i.ID,
		&i.BookingID,
		&i.PaymentTransactionID,
		&i.RequestedByUserID,
		&i.ApprovedByUserID,
		&i.Amount,
		&i.Reason,
		&i.Status,
		&i.StripeRefundID,
		&i.ProcessedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getRefundRequestByID = `-- name: GetRefundRequestByID :one
SELECT id, booking_id, payment_transaction_id, requested_by_user_id, approved_by_user_id, amount, reason, status, stripe_refund_id, processed_at, created_at, updated_at FROM refund_requests WHERE id = $1
`

func (q *Queries) GetRefundRequestByID(ctx context.Context, id pgtype.UUID) (RefundRequest, error) {
	row := q.db.QueryRow(ctx, getRefundRequestByID, id)
	var i RefundRequest
	err := row.Scan(
		&i.ID,
		&i.BookingID,
		&i.PaymentTransactionID,
		&i.RequestedByUserID,
		&i.ApprovedByUserID,
		&i.Amount,
		&i.Reason,
		&i.Status,
		&i.StripeRefundID,
		&i.ProcessedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getTotalPayoutsInPeriod = `-- name: GetTotalPayoutsInPeriod :one
SELECT
  COALESCE(SUM(CASE WHEN status = 'paid' THEN amount ELSE 0 END), 0)::BIGINT as total_paid,
  COALESCE(SUM(CASE WHEN status = 'pending' THEN amount ELSE 0 END), 0)::BIGINT as total_pending
FROM company_payouts
WHERE created_at >= $1 AND created_at <= $2
`

type GetTotalPayoutsInPeriodParams struct {
	CreatedAt   pgtype.Timestamptz `json:"created_at"`
	CreatedAt_2 pgtype.Timestamptz `json:"created_at_2"`
}

type GetTotalPayoutsInPeriodRow struct {
	TotalPaid    int64 `json:"total_paid"`
	TotalPending int64 `json:"total_pending"`
}

func (q *Queries) GetTotalPayoutsInPeriod(ctx context.Context, arg GetTotalPayoutsInPeriodParams) (GetTotalPayoutsInPeriodRow, error) {
	row := q.db.QueryRow(ctx, getTotalPayoutsInPeriod, arg.CreatedAt, arg.CreatedAt_2)
	var i GetTotalPayoutsInPeriodRow
	err := row.Scan(&i.TotalPaid, &i.TotalPending)
	return i, err
}

const getTotalRefundsInPeriod = `-- name: GetTotalRefundsInPeriod :one
SELECT COALESCE(SUM(amount), 0)::BIGINT as total_refunds
FROM refund_requests
WHERE status = 'processed' AND processed_at >= $1 AND processed_at <= $2
`

type GetTotalRefundsInPeriodParams struct {
	ProcessedAt   pgtype.Timestamptz `json:"processed_at"`
	ProcessedAt_2 pgtype.Timestamptz `json:"processed_at_2"`
}

func (q *Queries) GetTotalRefundsInPeriod(ctx context.Context, arg GetTotalRefundsInPeriodParams) (int64, error) {
	row := q.db.QueryRow(ctx, getTotalRefundsInPeriod, arg.ProcessedAt, arg.ProcessedAt_2)
	var total_refunds int64
	err := row.Scan(&total_refunds)
	return total_refunds, err
}

const getUserStripeCustomerID = `-- name: GetUserStripeCustomerID :one

SELECT stripe_customer_id FROM users WHERE id = $1
`

// ============================================
// STRIPE CUSTOMER
// ============================================
func (q *Queries) GetUserStripeCustomerID(ctx context.Context, id pgtype.UUID) (pgtype.Text, error) {
	row := q.db.QueryRow(ctx, getUserStripeCustomerID, id)
	var stripe_customer_id pgtype.Text
	err := row.Scan(&stripe_customer_id)
	return stripe_customer_id, err
}

const listAllPaymentTransactions = `-- name: ListAllPaymentTransactions :many
SELECT id, booking_id, stripe_payment_intent_id, stripe_charge_id, amount_total, amount_company, amount_platform_fee, currency, status, failure_reason, refund_amount, stripe_refund_id, metadata, created_at, updated_at FROM payment_transactions ORDER BY created_at DESC LIMIT $1 OFFSET $2
`

type ListAllPaymentTransactionsParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

func (q *Queries) ListAllPaymentTransactions(ctx context.Context, arg ListAllPaymentTransactionsParams) ([]PaymentTransaction, error) {
	rows, err := q.db.Query(ctx, listAllPaymentTransactions, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []PaymentTransaction
	for rows.Next() {
		var i PaymentTransaction
		if err := rows.Scan(
			&i.ID,
			&i.BookingID,
			&i.StripePaymentIntentID,
			&i.StripeChargeID,
			&i.AmountTotal,
			&i.AmountCompany,
			&i.AmountPlatformFee,
			&i.Currency,
			&i.Status,
			&i.FailureReason,
			&i.RefundAmount,
			&i.StripeRefundID,
			&i.Metadata,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listAllPayouts = `-- name: ListAllPayouts :many
SELECT id, company_id, stripe_transfer_id, stripe_payout_id, amount, currency, period_from, period_to, booking_count, status, paid_at, failure_reason, created_at, updated_at FROM company_payouts ORDER BY created_at DESC LIMIT $1 OFFSET $2
`

type ListAllPayoutsParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

func (q *Queries) ListAllPayouts(ctx context.Context, arg ListAllPayoutsParams) ([]CompanyPayout, error) {
	rows, err := q.db.Query(ctx, listAllPayouts, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []CompanyPayout
	for rows.Next() {
		var i CompanyPayout
		if err := rows.Scan(
			&i.ID,
			&i.CompanyID,
			&i.StripeTransferID,
			&i.StripePayoutID,
			&i.Amount,
			&i.Currency,
			&i.PeriodFrom,
			&i.PeriodTo,
			&i.BookingCount,
			&i.Status,
			&i.PaidAt,
			&i.FailureReason,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listAllRefundRequests = `-- name: ListAllRefundRequests :many
SELECT id, booking_id, payment_transaction_id, requested_by_user_id, approved_by_user_id, amount, reason, status, stripe_refund_id, processed_at, created_at, updated_at FROM refund_requests ORDER BY created_at DESC LIMIT $1 OFFSET $2
`

type ListAllRefundRequestsParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

func (q *Queries) ListAllRefundRequests(ctx context.Context, arg ListAllRefundRequestsParams) ([]RefundRequest, error) {
	rows, err := q.db.Query(ctx, listAllRefundRequests, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []RefundRequest
	for rows.Next() {
		var i RefundRequest
		if err := rows.Scan(
			&i.ID,
			&i.BookingID,
			&i.PaymentTransactionID,
			&i.RequestedByUserID,
			&i.ApprovedByUserID,
			&i.Amount,
			&i.Reason,
			&i.Status,
			&i.StripeRefundID,
			&i.ProcessedAt,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listPaymentHistoryByUser = `-- name: ListPaymentHistoryByUser :many

SELECT pt.id, pt.booking_id, pt.stripe_payment_intent_id, pt.stripe_charge_id, pt.amount_total, pt.amount_company, pt.amount_platform_fee, pt.currency, pt.status, pt.failure_reason, pt.refund_amount, pt.stripe_refund_id, pt.metadata, pt.created_at, pt.updated_at FROM payment_transactions pt
JOIN bookings b ON b.id = pt.booking_id
WHERE b.client_user_id = $1
ORDER BY pt.created_at DESC
LIMIT $2 OFFSET $3
`

type ListPaymentHistoryByUserParams struct {
	ClientUserID pgtype.UUID `json:"client_user_id"`
	Limit        int32       `json:"limit"`
	Offset       int32       `json:"offset"`
}

// ============================================
// PAYMENT HISTORY (Client-facing)
// ============================================
func (q *Queries) ListPaymentHistoryByUser(ctx context.Context, arg ListPaymentHistoryByUserParams) ([]PaymentTransaction, error) {
	rows, err := q.db.Query(ctx, listPaymentHistoryByUser, arg.ClientUserID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []PaymentTransaction
	for rows.Next() {
		var i PaymentTransaction
		if err := rows.Scan(
			&i.ID,
			&i.BookingID,
			&i.StripePaymentIntentID,
			&i.StripeChargeID,
			&i.AmountTotal,
			&i.AmountCompany,
			&i.AmountPlatformFee,
			&i.Currency,
			&i.Status,
			&i.FailureReason,
			&i.RefundAmount,
			&i.StripeRefundID,
			&i.Metadata,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listPaymentMethodsByUser = `-- name: ListPaymentMethodsByUser :many

SELECT id, user_id, stripe_payment_method_id, card_last_four, card_brand, is_default, created_at, card_exp_month, card_exp_year FROM client_payment_methods WHERE user_id = $1 ORDER BY is_default DESC, created_at DESC
`

// ============================================
// CLIENT PAYMENT METHODS
// ============================================
func (q *Queries) ListPaymentMethodsByUser(ctx context.Context, userID pgtype.UUID) ([]ClientPaymentMethod, error) {
	rows, err := q.db.Query(ctx, listPaymentMethodsByUser, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ClientPaymentMethod
	for rows.Next() {
		var i ClientPaymentMethod
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.StripePaymentMethodID,
			&i.CardLastFour,
			&i.CardBrand,
			&i.IsDefault,
			&i.CreatedAt,
			&i.CardExpMonth,
			&i.CardExpYear,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listPaymentTransactionsByBooking = `-- name: ListPaymentTransactionsByBooking :many
SELECT id, booking_id, stripe_payment_intent_id, stripe_charge_id, amount_total, amount_company, amount_platform_fee, currency, status, failure_reason, refund_amount, stripe_refund_id, metadata, created_at, updated_at FROM payment_transactions WHERE booking_id = $1 ORDER BY created_at DESC
`

func (q *Queries) ListPaymentTransactionsByBooking(ctx context.Context, bookingID pgtype.UUID) ([]PaymentTransaction, error) {
	rows, err := q.db.Query(ctx, listPaymentTransactionsByBooking, bookingID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []PaymentTransaction
	for rows.Next() {
		var i PaymentTransaction
		if err := rows.Scan(
			&i.ID,
			&i.BookingID,
			&i.StripePaymentIntentID,
			&i.StripeChargeID,
			&i.AmountTotal,
			&i.AmountCompany,
			&i.AmountPlatformFee,
			&i.Currency,
			&i.Status,
			&i.FailureReason,
			&i.RefundAmount,
			&i.StripeRefundID,
			&i.Metadata,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listPaymentTransactionsByStatus = `-- name: ListPaymentTransactionsByStatus :many
SELECT id, booking_id, stripe_payment_intent_id, stripe_charge_id, amount_total, amount_company, amount_platform_fee, currency, status, failure_reason, refund_amount, stripe_refund_id, metadata, created_at, updated_at FROM payment_transactions WHERE status = $1 ORDER BY created_at DESC LIMIT $2 OFFSET $3
`

type ListPaymentTransactionsByStatusParams struct {
	Status PaymentTransactionStatus `json:"status"`
	Limit  int32                    `json:"limit"`
	Offset int32                    `json:"offset"`
}

func (q *Queries) ListPaymentTransactionsByStatus(ctx context.Context, arg ListPaymentTransactionsByStatusParams) ([]PaymentTransaction, error) {
	rows, err := q.db.Query(ctx, listPaymentTransactionsByStatus, arg.Status, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []PaymentTransaction
	for rows.Next() {
		var i PaymentTransaction
		if err := rows.Scan(
			&i.ID,
			&i.BookingID,
			&i.StripePaymentIntentID,
			&i.StripeChargeID,
			&i.AmountTotal,
			&i.AmountCompany,
			&i.AmountPlatformFee,
			&i.Currency,
			&i.Status,
			&i.FailureReason,
			&i.RefundAmount,
			&i.StripeRefundID,
			&i.Metadata,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listPayoutLineItems = `-- name: ListPayoutLineItems :many
SELECT id, payout_id, payment_transaction_id, booking_id, amount_gross, amount_commission, amount_net, created_at FROM payout_line_items WHERE payout_id = $1 ORDER BY created_at
`

func (q *Queries) ListPayoutLineItems(ctx context.Context, payoutID pgtype.UUID) ([]PayoutLineItem, error) {
	rows, err := q.db.Query(ctx, listPayoutLineItems, payoutID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []PayoutLineItem
	for rows.Next() {
		var i PayoutLineItem
		if err := rows.Scan(
			&i.ID,
			&i.PayoutID,
			&i.PaymentTransactionID,
			&i.BookingID,
			&i.AmountGross,
			&i.AmountCommission,
			&i.AmountNet,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listPayoutsByCompany = `-- name: ListPayoutsByCompany :many
SELECT id, company_id, stripe_transfer_id, stripe_payout_id, amount, currency, period_from, period_to, booking_count, status, paid_at, failure_reason, created_at, updated_at FROM company_payouts WHERE company_id = $1 ORDER BY created_at DESC LIMIT $2 OFFSET $3
`

type ListPayoutsByCompanyParams struct {
	CompanyID pgtype.UUID `json:"company_id"`
	Limit     int32       `json:"limit"`
	Offset    int32       `json:"offset"`
}

func (q *Queries) ListPayoutsByCompany(ctx context.Context, arg ListPayoutsByCompanyParams) ([]CompanyPayout, error) {
	rows, err := q.db.Query(ctx, listPayoutsByCompany, arg.CompanyID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []CompanyPayout
	for rows.Next() {
		var i CompanyPayout
		if err := rows.Scan(
			&i.ID,
			&i.CompanyID,
			&i.StripeTransferID,
			&i.StripePayoutID,
			&i.Amount,
			&i.Currency,
			&i.PeriodFrom,
			&i.PeriodTo,
			&i.BookingCount,
			&i.Status,
			&i.PaidAt,
			&i.FailureReason,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listPayoutsByCompanyAndStatus = `-- name: ListPayoutsByCompanyAndStatus :many
SELECT id, company_id, stripe_transfer_id, stripe_payout_id, amount, currency, period_from, period_to, booking_count, status, paid_at, failure_reason, created_at, updated_at FROM company_payouts WHERE company_id = $1 AND status = $2 ORDER BY created_at DESC LIMIT $3 OFFSET $4
`

type ListPayoutsByCompanyAndStatusParams struct {
	CompanyID pgtype.UUID  `json:"company_id"`
	Status    PayoutStatus `json:"status"`
	Limit     int32        `json:"limit"`
	Offset    int32        `json:"offset"`
}

func (q *Queries) ListPayoutsByCompanyAndStatus(ctx context.Context, arg ListPayoutsByCompanyAndStatusParams) ([]CompanyPayout, error) {
	rows, err := q.db.Query(ctx, listPayoutsByCompanyAndStatus,
		arg.CompanyID,
		arg.Status,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []CompanyPayout
	for rows.Next() {
		var i CompanyPayout
		if err := rows.Scan(
			&i.ID,
			&i.CompanyID,
			&i.StripeTransferID,
			&i.StripePayoutID,
			&i.Amount,
			&i.Currency,
			&i.PeriodFrom,
			&i.PeriodTo,
			&i.BookingCount,
			&i.Status,
			&i.PaidAt,
			&i.FailureReason,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listPayoutsByStatus = `-- name: ListPayoutsByStatus :many
SELECT id, company_id, stripe_transfer_id, stripe_payout_id, amount, currency, period_from, period_to, booking_count, status, paid_at, failure_reason, created_at, updated_at FROM company_payouts WHERE status = $1 ORDER BY created_at DESC LIMIT $2 OFFSET $3
`

type ListPayoutsByStatusParams struct {
	Status PayoutStatus `json:"status"`
	Limit  int32        `json:"limit"`
	Offset int32        `json:"offset"`
}

func (q *Queries) ListPayoutsByStatus(ctx context.Context, arg ListPayoutsByStatusParams) ([]CompanyPayout, error) {
	rows, err := q.db.Query(ctx, listPayoutsByStatus, arg.Status, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []CompanyPayout
	for rows.Next() {
		var i CompanyPayout
		if err := rows.Scan(
			&i.ID,
			&i.CompanyID,
			&i.StripeTransferID,
			&i.StripePayoutID,
			&i.Amount,
			&i.Currency,
			&i.PeriodFrom,
			&i.PeriodTo,
			&i.BookingCount,
			&i.Status,
			&i.PaidAt,
			&i.FailureReason,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listRefundRequestsByStatus = `-- name: ListRefundRequestsByStatus :many
SELECT id, booking_id, payment_transaction_id, requested_by_user_id, approved_by_user_id, amount, reason, status, stripe_refund_id, processed_at, created_at, updated_at FROM refund_requests WHERE status = $1 ORDER BY created_at DESC LIMIT $2 OFFSET $3
`

type ListRefundRequestsByStatusParams struct {
	Status RefundStatus `json:"status"`
	Limit  int32        `json:"limit"`
	Offset int32        `json:"offset"`
}

func (q *Queries) ListRefundRequestsByStatus(ctx context.Context, arg ListRefundRequestsByStatusParams) ([]RefundRequest, error) {
	rows, err := q.db.Query(ctx, listRefundRequestsByStatus, arg.Status, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []RefundRequest
	for rows.Next() {
		var i RefundRequest
		if err := rows.Scan(
			&i.ID,
			&i.BookingID,
			&i.PaymentTransactionID,
			&i.RequestedByUserID,
			&i.ApprovedByUserID,
			&i.Amount,
			&i.Reason,
			&i.Status,
			&i.StripeRefundID,
			&i.ProcessedAt,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listUnpaidCompanyTransactions = `-- name: ListUnpaidCompanyTransactions :many

SELECT pt.id, pt.booking_id, pt.stripe_payment_intent_id, pt.stripe_charge_id, pt.amount_total, pt.amount_company, pt.amount_platform_fee, pt.currency, pt.status, pt.failure_reason, pt.refund_amount, pt.stripe_refund_id, pt.metadata, pt.created_at, pt.updated_at FROM payment_transactions pt
JOIN bookings b ON b.id = pt.booking_id
LEFT JOIN payout_line_items pli ON pli.payment_transaction_id = pt.id
WHERE b.company_id = $1
  AND pt.status = 'succeeded'
  AND pli.id IS NULL
  AND pt.created_at >= $2 AND pt.created_at <= $3
ORDER BY pt.created_at
`

type ListUnpaidCompanyTransactionsParams struct {
	CompanyID   pgtype.UUID        `json:"company_id"`
	CreatedAt   pgtype.Timestamptz `json:"created_at"`
	CreatedAt_2 pgtype.Timestamptz `json:"created_at_2"`
}

// ============================================
// UNPAID TRANSACTIONS (Payout calculation)
// ============================================
func (q *Queries) ListUnpaidCompanyTransactions(ctx context.Context, arg ListUnpaidCompanyTransactionsParams) ([]PaymentTransaction, error) {
	rows, err := q.db.Query(ctx, listUnpaidCompanyTransactions, arg.CompanyID, arg.CreatedAt, arg.CreatedAt_2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []PaymentTransaction
	for rows.Next() {
		var i PaymentTransaction
		if err := rows.Scan(
			&i.ID,
			&i.BookingID,
			&i.StripePaymentIntentID,
			&i.StripeChargeID,
			&i.AmountTotal,
			&i.AmountCompany,
			&i.AmountPlatformFee,
			&i.Currency,
			&i.Status,
			&i.FailureReason,
			&i.RefundAmount,
			&i.StripeRefundID,
			&i.Metadata,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const markBookingPaid = `-- name: MarkBookingPaid :one
UPDATE bookings SET payment_status = 'paid', paid_at = NOW(), updated_at = NOW()
WHERE id = $1 RETURNING id, reference_code, client_user_id, company_id, cleaner_id, address_id, service_type, scheduled_date, scheduled_start_time, estimated_duration_hours, property_type, num_rooms, num_bathrooms, area_sqm, has_pets, special_instructions, hourly_rate, estimated_total, final_total, platform_commission_pct, platform_commission_amount, status, started_at, completed_at, cancelled_at, cancellation_reason, stripe_payment_intent_id, payment_status, paid_at, created_at, updated_at, recurring_group_id, occurrence_number
`

func (q *Queries) MarkBookingPaid(ctx context.Context, id pgtype.UUID) (Booking, error) {
	row := q.db.QueryRow(ctx, markBookingPaid, id)
	var i Booking
	err := row.Scan(
		&i.ID,
		&i.ReferenceCode,
		&i.ClientUserID,
		&i.CompanyID,
		&i.CleanerID,
		&i.AddressID,
		&i.ServiceType,
		&i.ScheduledDate,
		&i.ScheduledStartTime,
		&i.EstimatedDurationHours,
		&i.PropertyType,
		&i.NumRooms,
		&i.NumBathrooms,
		&i.AreaSqm,
		&i.HasPets,
		&i.SpecialInstructions,
		&i.HourlyRate,
		&i.EstimatedTotal,
		&i.FinalTotal,
		&i.PlatformCommissionPct,
		&i.PlatformCommissionAmount,
		&i.Status,
		&i.StartedAt,
		&i.CompletedAt,
		&i.CancelledAt,
		&i.CancellationReason,
		&i.StripePaymentIntentID,
		&i.PaymentStatus,
		&i.PaidAt,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.RecurringGroupID,
		&i.OccurrenceNumber,
	)
	return i, err
}

const markBookingPaidAndConfirmed = `-- name: MarkBookingPaidAndConfirmed :one
UPDATE bookings
SET payment_status = 'paid', paid_at = NOW(),
    status = CASE WHEN status IN ('pending', 'assigned') THEN 'confirmed'::booking_status ELSE status END,
    updated_at = NOW()
WHERE id = $1 RETURNING id, reference_code, client_user_id, company_id, cleaner_id, address_id, service_type, scheduled_date, scheduled_start_time, estimated_duration_hours, property_type, num_rooms, num_bathrooms, area_sqm, has_pets, special_instructions, hourly_rate, estimated_total, final_total, platform_commission_pct, platform_commission_amount, status, started_at, completed_at, cancelled_at, cancellation_reason, stripe_payment_intent_id, payment_status, paid_at, created_at, updated_at, recurring_group_id, occurrence_number
`

// Atomically marks a booking as paid AND auto-confirms it if still pending/assigned.
// Idempotent: if booking is already confirmed or later, status is left unchanged.
func (q *Queries) MarkBookingPaidAndConfirmed(ctx context.Context, id pgtype.UUID) (Booking, error) {
	row := q.db.QueryRow(ctx, markBookingPaidAndConfirmed, id)
	var i Booking
	err := row.Scan(
		&i.ID,
		&i.ReferenceCode,
		&i.ClientUserID,
		&i.CompanyID,
		&i.CleanerID,
		&i.AddressID,
		&i.ServiceType,
		&i.ScheduledDate,
		&i.ScheduledStartTime,
		&i.EstimatedDurationHours,
		&i.PropertyType,
		&i.NumRooms,
		&i.NumBathrooms,
		&i.AreaSqm,
		&i.HasPets,
		&i.SpecialInstructions,
		&i.HourlyRate,
		&i.EstimatedTotal,
		&i.FinalTotal,
		&i.PlatformCommissionPct,
		&i.PlatformCommissionAmount,
		&i.Status,
		&i.StartedAt,
		&i.CompletedAt,
		&i.CancelledAt,
		&i.CancellationReason,
		&i.StripePaymentIntentID,
		&i.PaymentStatus,
		&i.PaidAt,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.RecurringGroupID,
		&i.OccurrenceNumber,
	)
	return i, err
}

const setCompanyStripeConnect = `-- name: SetCompanyStripeConnect :exec
UPDATE companies SET
  stripe_connect_account_id = $2,
  stripe_connect_onboarding_complete = $3,
  stripe_connect_charges_enabled = $4,
  stripe_connect_payouts_enabled = $5,
  updated_at = NOW()
WHERE id = $1
`

type SetCompanyStripeConnectParams struct {
	ID                              pgtype.UUID `json:"id"`
	StripeConnectAccountID          pgtype.Text `json:"stripe_connect_account_id"`
	StripeConnectOnboardingComplete pgtype.Bool `json:"stripe_connect_onboarding_complete"`
	StripeConnectChargesEnabled     pgtype.Bool `json:"stripe_connect_charges_enabled"`
	StripeConnectPayoutsEnabled     pgtype.Bool `json:"stripe_connect_payouts_enabled"`
}

func (q *Queries) SetCompanyStripeConnect(ctx context.Context, arg SetCompanyStripeConnectParams) error {
	_, err := q.db.Exec(ctx, setCompanyStripeConnect,
		arg.ID,
		arg.StripeConnectAccountID,
		arg.StripeConnectOnboardingComplete,
		arg.StripeConnectChargesEnabled,
		arg.StripeConnectPayoutsEnabled,
	)
	return err
}

const setDefaultPaymentMethod = `-- name: SetDefaultPaymentMethod :exec
UPDATE client_payment_methods SET is_default = (id = $2) WHERE user_id = $1
`

type SetDefaultPaymentMethodParams struct {
	UserID pgtype.UUID `json:"user_id"`
	ID     pgtype.UUID `json:"id"`
}

func (q *Queries) SetDefaultPaymentMethod(ctx context.Context, arg SetDefaultPaymentMethodParams) error {
	_, err := q.db.Exec(ctx, setDefaultPaymentMethod, arg.UserID, arg.ID)
	return err
}

const setUserStripeCustomerID = `-- name: SetUserStripeCustomerID :exec
UPDATE users SET stripe_customer_id = $2, updated_at = NOW() WHERE id = $1
`

type SetUserStripeCustomerIDParams struct {
	ID               pgtype.UUID `json:"id"`
	StripeCustomerID pgtype.Text `json:"stripe_customer_id"`
}

func (q *Queries) SetUserStripeCustomerID(ctx context.Context, arg SetUserStripeCustomerIDParams) error {
	_, err := q.db.Exec(ctx, setUserStripeCustomerID, arg.ID, arg.StripeCustomerID)
	return err
}

const sumCompanyEarnings = `-- name: SumCompanyEarnings :one

SELECT
  COALESCE(SUM(pt.amount_total), 0)::BIGINT as total_gross,
  COALESCE(SUM(pt.amount_platform_fee), 0)::BIGINT as total_commission,
  COALESCE(SUM(pt.amount_company), 0)::BIGINT as total_net,
  COUNT(pt.id)::BIGINT as booking_count
FROM payment_transactions pt
JOIN bookings b ON b.id = pt.booking_id
WHERE b.company_id = $1 AND pt.status = 'succeeded'
  AND pt.created_at >= $2 AND pt.created_at <= $3
`

type SumCompanyEarningsParams struct {
	CompanyID   pgtype.UUID        `json:"company_id"`
	CreatedAt   pgtype.Timestamptz `json:"created_at"`
	CreatedAt_2 pgtype.Timestamptz `json:"created_at_2"`
}

type SumCompanyEarningsRow struct {
	TotalGross      int64 `json:"total_gross"`
	TotalCommission int64 `json:"total_commission"`
	TotalNet        int64 `json:"total_net"`
	BookingCount    int64 `json:"booking_count"`
}

// ============================================
// COMPANY EARNINGS (Reporting)
// ============================================
func (q *Queries) SumCompanyEarnings(ctx context.Context, arg SumCompanyEarningsParams) (SumCompanyEarningsRow, error) {
	row := q.db.QueryRow(ctx, sumCompanyEarnings, arg.CompanyID, arg.CreatedAt, arg.CreatedAt_2)
	var i SumCompanyEarningsRow
	err := row.Scan(
		&i.TotalGross,
		&i.TotalCommission,
		&i.TotalNet,
		&i.BookingCount,
	)
	return i, err
}

const updateBookingPayment = `-- name: UpdateBookingPayment :one

UPDATE bookings SET stripe_payment_intent_id = $2, payment_status = $3, updated_at = NOW()
WHERE id = $1 RETURNING id, reference_code, client_user_id, company_id, cleaner_id, address_id, service_type, scheduled_date, scheduled_start_time, estimated_duration_hours, property_type, num_rooms, num_bathrooms, area_sqm, has_pets, special_instructions, hourly_rate, estimated_total, final_total, platform_commission_pct, platform_commission_amount, status, started_at, completed_at, cancelled_at, cancellation_reason, stripe_payment_intent_id, payment_status, paid_at, created_at, updated_at, recurring_group_id, occurrence_number
`

type UpdateBookingPaymentParams struct {
	ID                    pgtype.UUID `json:"id"`
	StripePaymentIntentID pgtype.Text `json:"stripe_payment_intent_id"`
	PaymentStatus         pgtype.Text `json:"payment_status"`
}

// ============================================
// BOOKING PAYMENT STATUS
// ============================================
func (q *Queries) UpdateBookingPayment(ctx context.Context, arg UpdateBookingPaymentParams) (Booking, error) {
	row := q.db.QueryRow(ctx, updateBookingPayment, arg.ID, arg.StripePaymentIntentID, arg.PaymentStatus)
	var i Booking
	err := row.Scan(
		&i.ID,
		&i.ReferenceCode,
		&i.ClientUserID,
		&i.CompanyID,
		&i.CleanerID,
		&i.AddressID,
		&i.ServiceType,
		&i.ScheduledDate,
		&i.ScheduledStartTime,
		&i.EstimatedDurationHours,
		&i.PropertyType,
		&i.NumRooms,
		&i.NumBathrooms,
		&i.AreaSqm,
		&i.HasPets,
		&i.SpecialInstructions,
		&i.HourlyRate,
		&i.EstimatedTotal,
		&i.FinalTotal,
		&i.PlatformCommissionPct,
		&i.PlatformCommissionAmount,
		&i.Status,
		&i.StartedAt,
		&i.CompletedAt,
		&i.CancelledAt,
		&i.CancellationReason,
		&i.StripePaymentIntentID,
		&i.PaymentStatus,
		&i.PaidAt,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.RecurringGroupID,
		&i.OccurrenceNumber,
	)
	return i, err
}

const updatePaymentTransactionFailed = `-- name: UpdatePaymentTransactionFailed :one
UPDATE payment_transactions SET status = 'failed', failure_reason = $2, updated_at = NOW()
WHERE stripe_payment_intent_id = $1 RETURNING id, booking_id, stripe_payment_intent_id, stripe_charge_id, amount_total, amount_company, amount_platform_fee, currency, status, failure_reason, refund_amount, stripe_refund_id, metadata, created_at, updated_at
`

type UpdatePaymentTransactionFailedParams struct {
	StripePaymentIntentID string      `json:"stripe_payment_intent_id"`
	FailureReason         pgtype.Text `json:"failure_reason"`
}

func (q *Queries) UpdatePaymentTransactionFailed(ctx context.Context, arg UpdatePaymentTransactionFailedParams) (PaymentTransaction, error) {
	row := q.db.QueryRow(ctx, updatePaymentTransactionFailed, arg.StripePaymentIntentID, arg.FailureReason)
	var i PaymentTransaction
	err := row.Scan(
		&i.ID,
		&i.BookingID,
		&i.StripePaymentIntentID,
		&i.StripeChargeID,
		&i.AmountTotal,
		&i.AmountCompany,
		&i.AmountPlatformFee,
		&i.Currency,
		&i.Status,
		&i.FailureReason,
		&i.RefundAmount,
		&i.StripeRefundID,
		&i.Metadata,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updatePaymentTransactionRefund = `-- name: UpdatePaymentTransactionRefund :one
UPDATE payment_transactions SET status = $2, refund_amount = $3, stripe_refund_id = $4, updated_at = NOW()
WHERE stripe_payment_intent_id = $1 RETURNING id, booking_id, stripe_payment_intent_id, stripe_charge_id, amount_total, amount_company, amount_platform_fee, currency, status, failure_reason, refund_amount, stripe_refund_id, metadata, created_at, updated_at
`

type UpdatePaymentTransactionRefundParams struct {
	StripePaymentIntentID string                   `json:"stripe_payment_intent_id"`
	Status                PaymentTransactionStatus `json:"status"`
	RefundAmount          pgtype.Int4              `json:"refund_amount"`
	StripeRefundID        pgtype.Text              `json:"stripe_refund_id"`
}

func (q *Queries) UpdatePaymentTransactionRefund(ctx context.Context, arg UpdatePaymentTransactionRefundParams) (PaymentTransaction, error) {
	row := q.db.QueryRow(ctx, updatePaymentTransactionRefund,
		arg.StripePaymentIntentID,
		arg.Status,
		arg.RefundAmount,
		arg.StripeRefundID,
	)
	var i PaymentTransaction
	err := row.Scan(
		&i.ID,
		&i.BookingID,
		&i.StripePaymentIntentID,
		&i.StripeChargeID,
		&i.AmountTotal,
		&i.AmountCompany,
		&i.AmountPlatformFee,
		&i.Currency,
		&i.Status,
		&i.FailureReason,
		&i.RefundAmount,
		&i.StripeRefundID,
		&i.Metadata,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updatePaymentTransactionStatus = `-- name: UpdatePaymentTransactionStatus :one
UPDATE payment_transactions SET status = $2, stripe_charge_id = $3, updated_at = NOW()
WHERE stripe_payment_intent_id = $1 RETURNING id, booking_id, stripe_payment_intent_id, stripe_charge_id, amount_total, amount_company, amount_platform_fee, currency, status, failure_reason, refund_amount, stripe_refund_id, metadata, created_at, updated_at
`

type UpdatePaymentTransactionStatusParams struct {
	StripePaymentIntentID string                   `json:"stripe_payment_intent_id"`
	Status                PaymentTransactionStatus `json:"status"`
	StripeChargeID        pgtype.Text              `json:"stripe_charge_id"`
}

func (q *Queries) UpdatePaymentTransactionStatus(ctx context.Context, arg UpdatePaymentTransactionStatusParams) (PaymentTransaction, error) {
	row := q.db.QueryRow(ctx, updatePaymentTransactionStatus, arg.StripePaymentIntentID, arg.Status, arg.StripeChargeID)
	var i PaymentTransaction
	err := row.Scan(
		&i.ID,
		&i.BookingID,
		&i.StripePaymentIntentID,
		&i.StripeChargeID,
		&i.AmountTotal,
		&i.AmountCompany,
		&i.AmountPlatformFee,
		&i.Currency,
		&i.Status,
		&i.FailureReason,
		&i.RefundAmount,
		&i.StripeRefundID,
		&i.Metadata,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updatePayoutStatus = `-- name: UpdatePayoutStatus :one
UPDATE company_payouts SET status = $2, stripe_transfer_id = $3, paid_at = CASE WHEN $2 = 'paid' THEN NOW() ELSE paid_at END, updated_at = NOW()
WHERE id = $1 RETURNING id, company_id, stripe_transfer_id, stripe_payout_id, amount, currency, period_from, period_to, booking_count, status, paid_at, failure_reason, created_at, updated_at
`

type UpdatePayoutStatusParams struct {
	ID               pgtype.UUID  `json:"id"`
	Status           PayoutStatus `json:"status"`
	StripeTransferID pgtype.Text  `json:"stripe_transfer_id"`
}

func (q *Queries) UpdatePayoutStatus(ctx context.Context, arg UpdatePayoutStatusParams) (CompanyPayout, error) {
	row := q.db.QueryRow(ctx, updatePayoutStatus, arg.ID, arg.Status, arg.StripeTransferID)
	var i CompanyPayout
	err := row.Scan(
		&i.ID,
		&i.CompanyID,
		&i.StripeTransferID,
		&i.StripePayoutID,
		&i.Amount,
		&i.Currency,
		&i.PeriodFrom,
		&i.PeriodTo,
		&i.BookingCount,
		&i.Status,
		&i.PaidAt,
		&i.FailureReason,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateRefundRequestStatus = `-- name: UpdateRefundRequestStatus :one
UPDATE refund_requests SET status = $2, approved_by_user_id = $3, stripe_refund_id = $4,
  processed_at = CASE WHEN $2 IN ('processed', 'rejected') THEN NOW() ELSE processed_at END,
  updated_at = NOW()
WHERE id = $1 RETURNING id, booking_id, payment_transaction_id, requested_by_user_id, approved_by_user_id, amount, reason, status, stripe_refund_id, processed_at, created_at, updated_at
`

type UpdateRefundRequestStatusParams struct {
	ID               pgtype.UUID  `json:"id"`
	Status           RefundStatus `json:"status"`
	ApprovedByUserID pgtype.UUID  `json:"approved_by_user_id"`
	StripeRefundID   pgtype.Text  `json:"stripe_refund_id"`
}

func (q *Queries) UpdateRefundRequestStatus(ctx context.Context, arg UpdateRefundRequestStatusParams) (RefundRequest, error) {
	row := q.db.QueryRow(ctx, updateRefundRequestStatus,
		arg.ID,
		arg.Status,
		arg.ApprovedByUserID,
		arg.StripeRefundID,
	)
	var i RefundRequest
	err := row.Scan(
		&i.ID,
		&i.BookingID,
		&i.PaymentTransactionID,
		&i.RequestedByUserID,
		&i.ApprovedByUserID,
		&i.Amount,
		&i.Reason,
		&i.Status,
		&i.StripeRefundID,
		&i.ProcessedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
