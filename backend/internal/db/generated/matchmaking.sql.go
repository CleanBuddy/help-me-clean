// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: matchmaking.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const findMatchingCleaners = `-- name: FindMatchingCleaners :many
SELECT DISTINCT c.id, c.full_name, c.rating_avg, c.total_jobs_completed,
       co.company_name, co.id AS company_id
FROM cleaners c
JOIN companies co ON c.company_id = co.id
JOIN company_service_areas csa ON csa.company_id = co.id AND csa.city_area_id = $1
JOIN cleaner_service_areas cla ON cla.cleaner_id = c.id AND cla.city_area_id = $1
WHERE c.status = 'active'
  AND co.status = 'approved'
ORDER BY c.rating_avg DESC, c.total_jobs_completed DESC
`

type FindMatchingCleanersRow struct {
	ID                 pgtype.UUID    `json:"id"`
	FullName           string         `json:"full_name"`
	RatingAvg          pgtype.Numeric `json:"rating_avg"`
	TotalJobsCompleted pgtype.Int4    `json:"total_jobs_completed"`
	CompanyName        string         `json:"company_name"`
	CompanyID          pgtype.UUID    `json:"company_id"`
}

func (q *Queries) FindMatchingCleaners(ctx context.Context, cityAreaID pgtype.UUID) ([]FindMatchingCleanersRow, error) {
	rows, err := q.db.Query(ctx, findMatchingCleaners, cityAreaID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []FindMatchingCleanersRow
	for rows.Next() {
		var i FindMatchingCleanersRow
		if err := rows.Scan(
			&i.ID,
			&i.FullName,
			&i.RatingAvg,
			&i.TotalJobsCompleted,
			&i.CompanyName,
			&i.CompanyID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listCleanerBookingsForDate = `-- name: ListCleanerBookingsForDate :many
SELECT id, scheduled_start_time, estimated_duration_hours
FROM bookings
WHERE cleaner_id = $1
  AND scheduled_date = $2
  AND status NOT IN ('cancelled_by_client', 'cancelled_by_company', 'cancelled_by_admin')
ORDER BY scheduled_start_time
`

type ListCleanerBookingsForDateParams struct {
	CleanerID     pgtype.UUID `json:"cleaner_id"`
	ScheduledDate pgtype.Date `json:"scheduled_date"`
}

type ListCleanerBookingsForDateRow struct {
	ID                     pgtype.UUID    `json:"id"`
	ScheduledStartTime     pgtype.Time    `json:"scheduled_start_time"`
	EstimatedDurationHours pgtype.Numeric `json:"estimated_duration_hours"`
}

func (q *Queries) ListCleanerBookingsForDate(ctx context.Context, arg ListCleanerBookingsForDateParams) ([]ListCleanerBookingsForDateRow, error) {
	rows, err := q.db.Query(ctx, listCleanerBookingsForDate, arg.CleanerID, arg.ScheduledDate)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListCleanerBookingsForDateRow
	for rows.Next() {
		var i ListCleanerBookingsForDateRow
		if err := rows.Scan(&i.ID, &i.ScheduledStartTime, &i.EstimatedDurationHours); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
