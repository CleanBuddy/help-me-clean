// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: bookings.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const assignCleanerToBooking = `-- name: AssignCleanerToBooking :one
UPDATE bookings SET company_id = $2, cleaner_id = $3, status = 'assigned', updated_at = NOW()
WHERE id = $1 RETURNING id, reference_code, client_user_id, company_id, cleaner_id, address_id, service_type, scheduled_date, scheduled_start_time, estimated_duration_hours, property_type, num_rooms, num_bathrooms, area_sqm, has_pets, special_instructions, hourly_rate, estimated_total, final_total, platform_commission_pct, platform_commission_amount, status, started_at, completed_at, cancelled_at, cancellation_reason, stripe_payment_intent_id, payment_status, paid_at, created_at, updated_at, recurring_group_id, occurrence_number
`

type AssignCleanerToBookingParams struct {
	ID        pgtype.UUID `json:"id"`
	CompanyID pgtype.UUID `json:"company_id"`
	CleanerID pgtype.UUID `json:"cleaner_id"`
}

func (q *Queries) AssignCleanerToBooking(ctx context.Context, arg AssignCleanerToBookingParams) (Booking, error) {
	row := q.db.QueryRow(ctx, assignCleanerToBooking, arg.ID, arg.CompanyID, arg.CleanerID)
	var i Booking
	err := row.Scan(
		&i.ID,
		&i.ReferenceCode,
		&i.ClientUserID,
		&i.CompanyID,
		&i.CleanerID,
		&i.AddressID,
		&i.ServiceType,
		&i.ScheduledDate,
		&i.ScheduledStartTime,
		&i.EstimatedDurationHours,
		&i.PropertyType,
		&i.NumRooms,
		&i.NumBathrooms,
		&i.AreaSqm,
		&i.HasPets,
		&i.SpecialInstructions,
		&i.HourlyRate,
		&i.EstimatedTotal,
		&i.FinalTotal,
		&i.PlatformCommissionPct,
		&i.PlatformCommissionAmount,
		&i.Status,
		&i.StartedAt,
		&i.CompletedAt,
		&i.CancelledAt,
		&i.CancellationReason,
		&i.StripePaymentIntentID,
		&i.PaymentStatus,
		&i.PaidAt,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.RecurringGroupID,
		&i.OccurrenceNumber,
	)
	return i, err
}

const cancelBookingWithReason = `-- name: CancelBookingWithReason :one
UPDATE bookings SET status = $2, cancelled_at = NOW(), cancellation_reason = $3, updated_at = NOW()
WHERE id = $1 RETURNING id, reference_code, client_user_id, company_id, cleaner_id, address_id, service_type, scheduled_date, scheduled_start_time, estimated_duration_hours, property_type, num_rooms, num_bathrooms, area_sqm, has_pets, special_instructions, hourly_rate, estimated_total, final_total, platform_commission_pct, platform_commission_amount, status, started_at, completed_at, cancelled_at, cancellation_reason, stripe_payment_intent_id, payment_status, paid_at, created_at, updated_at, recurring_group_id, occurrence_number
`

type CancelBookingWithReasonParams struct {
	ID                 pgtype.UUID   `json:"id"`
	Status             BookingStatus `json:"status"`
	CancellationReason pgtype.Text   `json:"cancellation_reason"`
}

func (q *Queries) CancelBookingWithReason(ctx context.Context, arg CancelBookingWithReasonParams) (Booking, error) {
	row := q.db.QueryRow(ctx, cancelBookingWithReason, arg.ID, arg.Status, arg.CancellationReason)
	var i Booking
	err := row.Scan(
		&i.ID,
		&i.ReferenceCode,
		&i.ClientUserID,
		&i.CompanyID,
		&i.CleanerID,
		&i.AddressID,
		&i.ServiceType,
		&i.ScheduledDate,
		&i.ScheduledStartTime,
		&i.EstimatedDurationHours,
		&i.PropertyType,
		&i.NumRooms,
		&i.NumBathrooms,
		&i.AreaSqm,
		&i.HasPets,
		&i.SpecialInstructions,
		&i.HourlyRate,
		&i.EstimatedTotal,
		&i.FinalTotal,
		&i.PlatformCommissionPct,
		&i.PlatformCommissionAmount,
		&i.Status,
		&i.StartedAt,
		&i.CompletedAt,
		&i.CancelledAt,
		&i.CancellationReason,
		&i.StripePaymentIntentID,
		&i.PaymentStatus,
		&i.PaidAt,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.RecurringGroupID,
		&i.OccurrenceNumber,
	)
	return i, err
}

const completeBooking = `-- name: CompleteBooking :one
UPDATE bookings SET status = 'completed', completed_at = NOW(), updated_at = NOW()
WHERE id = $1 RETURNING id, reference_code, client_user_id, company_id, cleaner_id, address_id, service_type, scheduled_date, scheduled_start_time, estimated_duration_hours, property_type, num_rooms, num_bathrooms, area_sqm, has_pets, special_instructions, hourly_rate, estimated_total, final_total, platform_commission_pct, platform_commission_amount, status, started_at, completed_at, cancelled_at, cancellation_reason, stripe_payment_intent_id, payment_status, paid_at, created_at, updated_at, recurring_group_id, occurrence_number
`

func (q *Queries) CompleteBooking(ctx context.Context, id pgtype.UUID) (Booking, error) {
	row := q.db.QueryRow(ctx, completeBooking, id)
	var i Booking
	err := row.Scan(
		&i.ID,
		&i.ReferenceCode,
		&i.ClientUserID,
		&i.CompanyID,
		&i.CleanerID,
		&i.AddressID,
		&i.ServiceType,
		&i.ScheduledDate,
		&i.ScheduledStartTime,
		&i.EstimatedDurationHours,
		&i.PropertyType,
		&i.NumRooms,
		&i.NumBathrooms,
		&i.AreaSqm,
		&i.HasPets,
		&i.SpecialInstructions,
		&i.HourlyRate,
		&i.EstimatedTotal,
		&i.FinalTotal,
		&i.PlatformCommissionPct,
		&i.PlatformCommissionAmount,
		&i.Status,
		&i.StartedAt,
		&i.CompletedAt,
		&i.CancelledAt,
		&i.CancellationReason,
		&i.StripePaymentIntentID,
		&i.PaymentStatus,
		&i.PaidAt,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.RecurringGroupID,
		&i.OccurrenceNumber,
	)
	return i, err
}

const countAllBookings = `-- name: CountAllBookings :one
SELECT COUNT(*) FROM bookings
`

func (q *Queries) CountAllBookings(ctx context.Context) (int64, error) {
	row := q.db.QueryRow(ctx, countAllBookings)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countBookingsByStatus = `-- name: CountBookingsByStatus :one
SELECT COUNT(*) FROM bookings WHERE status = $1
`

func (q *Queries) CountBookingsByStatus(ctx context.Context, status BookingStatus) (int64, error) {
	row := q.db.QueryRow(ctx, countBookingsByStatus, status)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countCompletedJobsByCleaner = `-- name: CountCompletedJobsByCleaner :one
SELECT COUNT(*) FROM bookings WHERE cleaner_id = $1 AND status = 'completed'
`

func (q *Queries) CountCompletedJobsByCleaner(ctx context.Context, cleanerID pgtype.UUID) (int64, error) {
	row := q.db.QueryRow(ctx, countCompletedJobsByCleaner, cleanerID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countSearchBookings = `-- name: CountSearchBookings :one
SELECT COUNT(*) FROM bookings WHERE
    ($1::text = '' OR reference_code ILIKE '%' || $1::text || '%')
    AND ($2::text = '' OR status::text = $2::text)
`

type CountSearchBookingsParams struct {
	Query        string `json:"query"`
	StatusFilter string `json:"status_filter"`
}

func (q *Queries) CountSearchBookings(ctx context.Context, arg CountSearchBookingsParams) (int64, error) {
	row := q.db.QueryRow(ctx, countSearchBookings, arg.Query, arg.StatusFilter)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countSearchCleanerBookings = `-- name: CountSearchCleanerBookings :one
SELECT COUNT(*) FROM bookings WHERE
    cleaner_id = $1
    AND ($2::text = '' OR reference_code ILIKE '%' || $2::text || '%')
    AND ($3::text = '' OR status::text = $3::text OR ($3::text = 'cancelled' AND status::text LIKE 'cancelled%'))
    AND ($4::date = '0001-01-01' OR scheduled_date >= $4::date)
    AND ($5::date = '0001-01-01' OR scheduled_date <= $5::date)
`

type CountSearchCleanerBookingsParams struct {
	CleanerID    pgtype.UUID `json:"cleaner_id"`
	Query        string      `json:"query"`
	StatusFilter string      `json:"status_filter"`
	DateFrom     pgtype.Date `json:"date_from"`
	DateTo       pgtype.Date `json:"date_to"`
}

func (q *Queries) CountSearchCleanerBookings(ctx context.Context, arg CountSearchCleanerBookingsParams) (int64, error) {
	row := q.db.QueryRow(ctx, countSearchCleanerBookings,
		arg.CleanerID,
		arg.Query,
		arg.StatusFilter,
		arg.DateFrom,
		arg.DateTo,
	)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countSearchCompanyBookings = `-- name: CountSearchCompanyBookings :one
SELECT COUNT(*) FROM bookings WHERE
    company_id = $1
    AND ($2::text = '' OR reference_code ILIKE '%' || $2::text || '%')
    AND ($3::text = '' OR status::text = $3::text OR ($3::text = 'cancelled' AND status::text LIKE 'cancelled%'))
    AND ($4::date = '0001-01-01' OR scheduled_date >= $4::date)
    AND ($5::date = '0001-01-01' OR scheduled_date <= $5::date)
`

type CountSearchCompanyBookingsParams struct {
	CompanyID    pgtype.UUID `json:"company_id"`
	Query        string      `json:"query"`
	StatusFilter string      `json:"status_filter"`
	DateFrom     pgtype.Date `json:"date_from"`
	DateTo       pgtype.Date `json:"date_to"`
}

func (q *Queries) CountSearchCompanyBookings(ctx context.Context, arg CountSearchCompanyBookingsParams) (int64, error) {
	row := q.db.QueryRow(ctx, countSearchCompanyBookings,
		arg.CompanyID,
		arg.Query,
		arg.StatusFilter,
		arg.DateFrom,
		arg.DateTo,
	)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countThisMonthJobsByCleaner = `-- name: CountThisMonthJobsByCleaner :one
SELECT COUNT(*) FROM bookings
WHERE cleaner_id = $1
  AND scheduled_date >= date_trunc('month', CURRENT_DATE)::date
  AND status NOT IN ('cancelled_by_client', 'cancelled_by_company', 'cancelled_by_admin')
`

func (q *Queries) CountThisMonthJobsByCleaner(ctx context.Context, cleanerID pgtype.UUID) (int64, error) {
	row := q.db.QueryRow(ctx, countThisMonthJobsByCleaner, cleanerID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createBooking = `-- name: CreateBooking :one
INSERT INTO bookings (
    reference_code, client_user_id, address_id, service_type, scheduled_date,
    scheduled_start_time, estimated_duration_hours, property_type, num_rooms,
    num_bathrooms, area_sqm, has_pets, special_instructions, hourly_rate, estimated_total,
    recurring_group_id, occurrence_number
) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16, $17)
RETURNING id, reference_code, client_user_id, company_id, cleaner_id, address_id, service_type, scheduled_date, scheduled_start_time, estimated_duration_hours, property_type, num_rooms, num_bathrooms, area_sqm, has_pets, special_instructions, hourly_rate, estimated_total, final_total, platform_commission_pct, platform_commission_amount, status, started_at, completed_at, cancelled_at, cancellation_reason, stripe_payment_intent_id, payment_status, paid_at, created_at, updated_at, recurring_group_id, occurrence_number
`

type CreateBookingParams struct {
	ReferenceCode          string         `json:"reference_code"`
	ClientUserID           pgtype.UUID    `json:"client_user_id"`
	AddressID              pgtype.UUID    `json:"address_id"`
	ServiceType            ServiceType    `json:"service_type"`
	ScheduledDate          pgtype.Date    `json:"scheduled_date"`
	ScheduledStartTime     pgtype.Time    `json:"scheduled_start_time"`
	EstimatedDurationHours pgtype.Numeric `json:"estimated_duration_hours"`
	PropertyType           pgtype.Text    `json:"property_type"`
	NumRooms               pgtype.Int4    `json:"num_rooms"`
	NumBathrooms           pgtype.Int4    `json:"num_bathrooms"`
	AreaSqm                pgtype.Int4    `json:"area_sqm"`
	HasPets                pgtype.Bool    `json:"has_pets"`
	SpecialInstructions    pgtype.Text    `json:"special_instructions"`
	HourlyRate             pgtype.Numeric `json:"hourly_rate"`
	EstimatedTotal         pgtype.Numeric `json:"estimated_total"`
	RecurringGroupID       pgtype.UUID    `json:"recurring_group_id"`
	OccurrenceNumber       pgtype.Int4    `json:"occurrence_number"`
}

func (q *Queries) CreateBooking(ctx context.Context, arg CreateBookingParams) (Booking, error) {
	row := q.db.QueryRow(ctx, createBooking,
		arg.ReferenceCode,
		arg.ClientUserID,
		arg.AddressID,
		arg.ServiceType,
		arg.ScheduledDate,
		arg.ScheduledStartTime,
		arg.EstimatedDurationHours,
		arg.PropertyType,
		arg.NumRooms,
		arg.NumBathrooms,
		arg.AreaSqm,
		arg.HasPets,
		arg.SpecialInstructions,
		arg.HourlyRate,
		arg.EstimatedTotal,
		arg.RecurringGroupID,
		arg.OccurrenceNumber,
	)
	var i Booking
	err := row.Scan(
		&i.ID,
		&i.ReferenceCode,
		&i.ClientUserID,
		&i.CompanyID,
		&i.CleanerID,
		&i.AddressID,
		&i.ServiceType,
		&i.ScheduledDate,
		&i.ScheduledStartTime,
		&i.EstimatedDurationHours,
		&i.PropertyType,
		&i.NumRooms,
		&i.NumBathrooms,
		&i.AreaSqm,
		&i.HasPets,
		&i.SpecialInstructions,
		&i.HourlyRate,
		&i.EstimatedTotal,
		&i.FinalTotal,
		&i.PlatformCommissionPct,
		&i.PlatformCommissionAmount,
		&i.Status,
		&i.StartedAt,
		&i.CompletedAt,
		&i.CancelledAt,
		&i.CancellationReason,
		&i.StripePaymentIntentID,
		&i.PaymentStatus,
		&i.PaidAt,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.RecurringGroupID,
		&i.OccurrenceNumber,
	)
	return i, err
}

const getBookingByID = `-- name: GetBookingByID :one
SELECT id, reference_code, client_user_id, company_id, cleaner_id, address_id, service_type, scheduled_date, scheduled_start_time, estimated_duration_hours, property_type, num_rooms, num_bathrooms, area_sqm, has_pets, special_instructions, hourly_rate, estimated_total, final_total, platform_commission_pct, platform_commission_amount, status, started_at, completed_at, cancelled_at, cancellation_reason, stripe_payment_intent_id, payment_status, paid_at, created_at, updated_at, recurring_group_id, occurrence_number FROM bookings WHERE id = $1
`

func (q *Queries) GetBookingByID(ctx context.Context, id pgtype.UUID) (Booking, error) {
	row := q.db.QueryRow(ctx, getBookingByID, id)
	var i Booking
	err := row.Scan(
		&i.ID,
		&i.ReferenceCode,
		&i.ClientUserID,
		&i.CompanyID,
		&i.CleanerID,
		&i.AddressID,
		&i.ServiceType,
		&i.ScheduledDate,
		&i.ScheduledStartTime,
		&i.EstimatedDurationHours,
		&i.PropertyType,
		&i.NumRooms,
		&i.NumBathrooms,
		&i.AreaSqm,
		&i.HasPets,
		&i.SpecialInstructions,
		&i.HourlyRate,
		&i.EstimatedTotal,
		&i.FinalTotal,
		&i.PlatformCommissionPct,
		&i.PlatformCommissionAmount,
		&i.Status,
		&i.StartedAt,
		&i.CompletedAt,
		&i.CancelledAt,
		&i.CancellationReason,
		&i.StripePaymentIntentID,
		&i.PaymentStatus,
		&i.PaidAt,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.RecurringGroupID,
		&i.OccurrenceNumber,
	)
	return i, err
}

const getBookingByReferenceCode = `-- name: GetBookingByReferenceCode :one
SELECT id, reference_code, client_user_id, company_id, cleaner_id, address_id, service_type, scheduled_date, scheduled_start_time, estimated_duration_hours, property_type, num_rooms, num_bathrooms, area_sqm, has_pets, special_instructions, hourly_rate, estimated_total, final_total, platform_commission_pct, platform_commission_amount, status, started_at, completed_at, cancelled_at, cancellation_reason, stripe_payment_intent_id, payment_status, paid_at, created_at, updated_at, recurring_group_id, occurrence_number FROM bookings WHERE reference_code = $1
`

func (q *Queries) GetBookingByReferenceCode(ctx context.Context, referenceCode string) (Booking, error) {
	row := q.db.QueryRow(ctx, getBookingByReferenceCode, referenceCode)
	var i Booking
	err := row.Scan(
		&i.ID,
		&i.ReferenceCode,
		&i.ClientUserID,
		&i.CompanyID,
		&i.CleanerID,
		&i.AddressID,
		&i.ServiceType,
		&i.ScheduledDate,
		&i.ScheduledStartTime,
		&i.EstimatedDurationHours,
		&i.PropertyType,
		&i.NumRooms,
		&i.NumBathrooms,
		&i.AreaSqm,
		&i.HasPets,
		&i.SpecialInstructions,
		&i.HourlyRate,
		&i.EstimatedTotal,
		&i.FinalTotal,
		&i.PlatformCommissionPct,
		&i.PlatformCommissionAmount,
		&i.Status,
		&i.StartedAt,
		&i.CompletedAt,
		&i.CancelledAt,
		&i.CancellationReason,
		&i.StripePaymentIntentID,
		&i.PaymentStatus,
		&i.PaidAt,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.RecurringGroupID,
		&i.OccurrenceNumber,
	)
	return i, err
}

const insertBookingExtra = `-- name: InsertBookingExtra :exec
INSERT INTO booking_extras (booking_id, extra_id, price, quantity)
VALUES ($1, $2, $3, $4)
`

type InsertBookingExtraParams struct {
	BookingID pgtype.UUID    `json:"booking_id"`
	ExtraID   pgtype.UUID    `json:"extra_id"`
	Price     pgtype.Numeric `json:"price"`
	Quantity  pgtype.Int4    `json:"quantity"`
}

func (q *Queries) InsertBookingExtra(ctx context.Context, arg InsertBookingExtraParams) error {
	_, err := q.db.Exec(ctx, insertBookingExtra,
		arg.BookingID,
		arg.ExtraID,
		arg.Price,
		arg.Quantity,
	)
	return err
}

const listBookingsByCleaner = `-- name: ListBookingsByCleaner :many
SELECT id, reference_code, client_user_id, company_id, cleaner_id, address_id, service_type, scheduled_date, scheduled_start_time, estimated_duration_hours, property_type, num_rooms, num_bathrooms, area_sqm, has_pets, special_instructions, hourly_rate, estimated_total, final_total, platform_commission_pct, platform_commission_amount, status, started_at, completed_at, cancelled_at, cancellation_reason, stripe_payment_intent_id, payment_status, paid_at, created_at, updated_at, recurring_group_id, occurrence_number FROM bookings WHERE cleaner_id = $1 ORDER BY scheduled_date DESC
`

func (q *Queries) ListBookingsByCleaner(ctx context.Context, cleanerID pgtype.UUID) ([]Booking, error) {
	rows, err := q.db.Query(ctx, listBookingsByCleaner, cleanerID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Booking
	for rows.Next() {
		var i Booking
		if err := rows.Scan(
			&i.ID,
			&i.ReferenceCode,
			&i.ClientUserID,
			&i.CompanyID,
			&i.CleanerID,
			&i.AddressID,
			&i.ServiceType,
			&i.ScheduledDate,
			&i.ScheduledStartTime,
			&i.EstimatedDurationHours,
			&i.PropertyType,
			&i.NumRooms,
			&i.NumBathrooms,
			&i.AreaSqm,
			&i.HasPets,
			&i.SpecialInstructions,
			&i.HourlyRate,
			&i.EstimatedTotal,
			&i.FinalTotal,
			&i.PlatformCommissionPct,
			&i.PlatformCommissionAmount,
			&i.Status,
			&i.StartedAt,
			&i.CompletedAt,
			&i.CancelledAt,
			&i.CancellationReason,
			&i.StripePaymentIntentID,
			&i.PaymentStatus,
			&i.PaidAt,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.RecurringGroupID,
			&i.OccurrenceNumber,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listBookingsByCleanerAndDateRange = `-- name: ListBookingsByCleanerAndDateRange :many
SELECT id, reference_code, client_user_id, company_id, cleaner_id, address_id, service_type, scheduled_date, scheduled_start_time, estimated_duration_hours, property_type, num_rooms, num_bathrooms, area_sqm, has_pets, special_instructions, hourly_rate, estimated_total, final_total, platform_commission_pct, platform_commission_amount, status, started_at, completed_at, cancelled_at, cancellation_reason, stripe_payment_intent_id, payment_status, paid_at, created_at, updated_at, recurring_group_id, occurrence_number FROM bookings
WHERE cleaner_id = $1
  AND scheduled_date >= $2::date
  AND scheduled_date <= $3::date
  AND status NOT IN ('cancelled_by_client', 'cancelled_by_company', 'cancelled_by_admin')
ORDER BY scheduled_date, scheduled_start_time
`

type ListBookingsByCleanerAndDateRangeParams struct {
	CleanerID pgtype.UUID `json:"cleaner_id"`
	DateFrom  pgtype.Date `json:"date_from"`
	DateTo    pgtype.Date `json:"date_to"`
}

func (q *Queries) ListBookingsByCleanerAndDateRange(ctx context.Context, arg ListBookingsByCleanerAndDateRangeParams) ([]Booking, error) {
	rows, err := q.db.Query(ctx, listBookingsByCleanerAndDateRange, arg.CleanerID, arg.DateFrom, arg.DateTo)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Booking
	for rows.Next() {
		var i Booking
		if err := rows.Scan(
			&i.ID,
			&i.ReferenceCode,
			&i.ClientUserID,
			&i.CompanyID,
			&i.CleanerID,
			&i.AddressID,
			&i.ServiceType,
			&i.ScheduledDate,
			&i.ScheduledStartTime,
			&i.EstimatedDurationHours,
			&i.PropertyType,
			&i.NumRooms,
			&i.NumBathrooms,
			&i.AreaSqm,
			&i.HasPets,
			&i.SpecialInstructions,
			&i.HourlyRate,
			&i.EstimatedTotal,
			&i.FinalTotal,
			&i.PlatformCommissionPct,
			&i.PlatformCommissionAmount,
			&i.Status,
			&i.StartedAt,
			&i.CompletedAt,
			&i.CancelledAt,
			&i.CancellationReason,
			&i.StripePaymentIntentID,
			&i.PaymentStatus,
			&i.PaidAt,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.RecurringGroupID,
			&i.OccurrenceNumber,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listBookingsByClient = `-- name: ListBookingsByClient :many
SELECT id, reference_code, client_user_id, company_id, cleaner_id, address_id, service_type, scheduled_date, scheduled_start_time, estimated_duration_hours, property_type, num_rooms, num_bathrooms, area_sqm, has_pets, special_instructions, hourly_rate, estimated_total, final_total, platform_commission_pct, platform_commission_amount, status, started_at, completed_at, cancelled_at, cancellation_reason, stripe_payment_intent_id, payment_status, paid_at, created_at, updated_at, recurring_group_id, occurrence_number FROM bookings WHERE client_user_id = $1 ORDER BY created_at DESC LIMIT $2 OFFSET $3
`

type ListBookingsByClientParams struct {
	ClientUserID pgtype.UUID `json:"client_user_id"`
	Limit        int32       `json:"limit"`
	Offset       int32       `json:"offset"`
}

func (q *Queries) ListBookingsByClient(ctx context.Context, arg ListBookingsByClientParams) ([]Booking, error) {
	rows, err := q.db.Query(ctx, listBookingsByClient, arg.ClientUserID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Booking
	for rows.Next() {
		var i Booking
		if err := rows.Scan(
			&i.ID,
			&i.ReferenceCode,
			&i.ClientUserID,
			&i.CompanyID,
			&i.CleanerID,
			&i.AddressID,
			&i.ServiceType,
			&i.ScheduledDate,
			&i.ScheduledStartTime,
			&i.EstimatedDurationHours,
			&i.PropertyType,
			&i.NumRooms,
			&i.NumBathrooms,
			&i.AreaSqm,
			&i.HasPets,
			&i.SpecialInstructions,
			&i.HourlyRate,
			&i.EstimatedTotal,
			&i.FinalTotal,
			&i.PlatformCommissionPct,
			&i.PlatformCommissionAmount,
			&i.Status,
			&i.StartedAt,
			&i.CompletedAt,
			&i.CancelledAt,
			&i.CancellationReason,
			&i.StripePaymentIntentID,
			&i.PaymentStatus,
			&i.PaidAt,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.RecurringGroupID,
			&i.OccurrenceNumber,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listBookingsByClientAndStatus = `-- name: ListBookingsByClientAndStatus :many
SELECT id, reference_code, client_user_id, company_id, cleaner_id, address_id, service_type, scheduled_date, scheduled_start_time, estimated_duration_hours, property_type, num_rooms, num_bathrooms, area_sqm, has_pets, special_instructions, hourly_rate, estimated_total, final_total, platform_commission_pct, platform_commission_amount, status, started_at, completed_at, cancelled_at, cancellation_reason, stripe_payment_intent_id, payment_status, paid_at, created_at, updated_at, recurring_group_id, occurrence_number FROM bookings WHERE client_user_id = $1 AND status = $2 ORDER BY created_at DESC LIMIT $3 OFFSET $4
`

type ListBookingsByClientAndStatusParams struct {
	ClientUserID pgtype.UUID   `json:"client_user_id"`
	Status       BookingStatus `json:"status"`
	Limit        int32         `json:"limit"`
	Offset       int32         `json:"offset"`
}

func (q *Queries) ListBookingsByClientAndStatus(ctx context.Context, arg ListBookingsByClientAndStatusParams) ([]Booking, error) {
	rows, err := q.db.Query(ctx, listBookingsByClientAndStatus,
		arg.ClientUserID,
		arg.Status,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Booking
	for rows.Next() {
		var i Booking
		if err := rows.Scan(
			&i.ID,
			&i.ReferenceCode,
			&i.ClientUserID,
			&i.CompanyID,
			&i.CleanerID,
			&i.AddressID,
			&i.ServiceType,
			&i.ScheduledDate,
			&i.ScheduledStartTime,
			&i.EstimatedDurationHours,
			&i.PropertyType,
			&i.NumRooms,
			&i.NumBathrooms,
			&i.AreaSqm,
			&i.HasPets,
			&i.SpecialInstructions,
			&i.HourlyRate,
			&i.EstimatedTotal,
			&i.FinalTotal,
			&i.PlatformCommissionPct,
			&i.PlatformCommissionAmount,
			&i.Status,
			&i.StartedAt,
			&i.CompletedAt,
			&i.CancelledAt,
			&i.CancellationReason,
			&i.StripePaymentIntentID,
			&i.PaymentStatus,
			&i.PaidAt,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.RecurringGroupID,
			&i.OccurrenceNumber,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listBookingsByCompany = `-- name: ListBookingsByCompany :many
SELECT id, reference_code, client_user_id, company_id, cleaner_id, address_id, service_type, scheduled_date, scheduled_start_time, estimated_duration_hours, property_type, num_rooms, num_bathrooms, area_sqm, has_pets, special_instructions, hourly_rate, estimated_total, final_total, platform_commission_pct, platform_commission_amount, status, started_at, completed_at, cancelled_at, cancellation_reason, stripe_payment_intent_id, payment_status, paid_at, created_at, updated_at, recurring_group_id, occurrence_number FROM bookings WHERE company_id = $1 ORDER BY created_at DESC LIMIT $2 OFFSET $3
`

type ListBookingsByCompanyParams struct {
	CompanyID pgtype.UUID `json:"company_id"`
	Limit     int32       `json:"limit"`
	Offset    int32       `json:"offset"`
}

func (q *Queries) ListBookingsByCompany(ctx context.Context, arg ListBookingsByCompanyParams) ([]Booking, error) {
	rows, err := q.db.Query(ctx, listBookingsByCompany, arg.CompanyID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Booking
	for rows.Next() {
		var i Booking
		if err := rows.Scan(
			&i.ID,
			&i.ReferenceCode,
			&i.ClientUserID,
			&i.CompanyID,
			&i.CleanerID,
			&i.AddressID,
			&i.ServiceType,
			&i.ScheduledDate,
			&i.ScheduledStartTime,
			&i.EstimatedDurationHours,
			&i.PropertyType,
			&i.NumRooms,
			&i.NumBathrooms,
			&i.AreaSqm,
			&i.HasPets,
			&i.SpecialInstructions,
			&i.HourlyRate,
			&i.EstimatedTotal,
			&i.FinalTotal,
			&i.PlatformCommissionPct,
			&i.PlatformCommissionAmount,
			&i.Status,
			&i.StartedAt,
			&i.CompletedAt,
			&i.CancelledAt,
			&i.CancellationReason,
			&i.StripePaymentIntentID,
			&i.PaymentStatus,
			&i.PaidAt,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.RecurringGroupID,
			&i.OccurrenceNumber,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listBookingsByCompanyAndDateRange = `-- name: ListBookingsByCompanyAndDateRange :many
SELECT id, reference_code, client_user_id, company_id, cleaner_id, address_id, service_type, scheduled_date, scheduled_start_time, estimated_duration_hours, property_type, num_rooms, num_bathrooms, area_sqm, has_pets, special_instructions, hourly_rate, estimated_total, final_total, platform_commission_pct, platform_commission_amount, status, started_at, completed_at, cancelled_at, cancellation_reason, stripe_payment_intent_id, payment_status, paid_at, created_at, updated_at, recurring_group_id, occurrence_number FROM bookings
WHERE company_id = $1
  AND scheduled_date >= $2::date
  AND scheduled_date <= $3::date
  AND status NOT IN ('cancelled_by_client', 'cancelled_by_company', 'cancelled_by_admin')
ORDER BY scheduled_date, scheduled_start_time
`

type ListBookingsByCompanyAndDateRangeParams struct {
	CompanyID pgtype.UUID `json:"company_id"`
	DateFrom  pgtype.Date `json:"date_from"`
	DateTo    pgtype.Date `json:"date_to"`
}

func (q *Queries) ListBookingsByCompanyAndDateRange(ctx context.Context, arg ListBookingsByCompanyAndDateRangeParams) ([]Booking, error) {
	rows, err := q.db.Query(ctx, listBookingsByCompanyAndDateRange, arg.CompanyID, arg.DateFrom, arg.DateTo)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Booking
	for rows.Next() {
		var i Booking
		if err := rows.Scan(
			&i.ID,
			&i.ReferenceCode,
			&i.ClientUserID,
			&i.CompanyID,
			&i.CleanerID,
			&i.AddressID,
			&i.ServiceType,
			&i.ScheduledDate,
			&i.ScheduledStartTime,
			&i.EstimatedDurationHours,
			&i.PropertyType,
			&i.NumRooms,
			&i.NumBathrooms,
			&i.AreaSqm,
			&i.HasPets,
			&i.SpecialInstructions,
			&i.HourlyRate,
			&i.EstimatedTotal,
			&i.FinalTotal,
			&i.PlatformCommissionPct,
			&i.PlatformCommissionAmount,
			&i.Status,
			&i.StartedAt,
			&i.CompletedAt,
			&i.CancelledAt,
			&i.CancellationReason,
			&i.StripePaymentIntentID,
			&i.PaymentStatus,
			&i.PaidAt,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.RecurringGroupID,
			&i.OccurrenceNumber,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listBookingsByCompanyAndStatus = `-- name: ListBookingsByCompanyAndStatus :many
SELECT id, reference_code, client_user_id, company_id, cleaner_id, address_id, service_type, scheduled_date, scheduled_start_time, estimated_duration_hours, property_type, num_rooms, num_bathrooms, area_sqm, has_pets, special_instructions, hourly_rate, estimated_total, final_total, platform_commission_pct, platform_commission_amount, status, started_at, completed_at, cancelled_at, cancellation_reason, stripe_payment_intent_id, payment_status, paid_at, created_at, updated_at, recurring_group_id, occurrence_number FROM bookings WHERE company_id = $1 AND status = $2 ORDER BY created_at DESC LIMIT $3 OFFSET $4
`

type ListBookingsByCompanyAndStatusParams struct {
	CompanyID pgtype.UUID   `json:"company_id"`
	Status    BookingStatus `json:"status"`
	Limit     int32         `json:"limit"`
	Offset    int32         `json:"offset"`
}

func (q *Queries) ListBookingsByCompanyAndStatus(ctx context.Context, arg ListBookingsByCompanyAndStatusParams) ([]Booking, error) {
	rows, err := q.db.Query(ctx, listBookingsByCompanyAndStatus,
		arg.CompanyID,
		arg.Status,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Booking
	for rows.Next() {
		var i Booking
		if err := rows.Scan(
			&i.ID,
			&i.ReferenceCode,
			&i.ClientUserID,
			&i.CompanyID,
			&i.CleanerID,
			&i.AddressID,
			&i.ServiceType,
			&i.ScheduledDate,
			&i.ScheduledStartTime,
			&i.EstimatedDurationHours,
			&i.PropertyType,
			&i.NumRooms,
			&i.NumBathrooms,
			&i.AreaSqm,
			&i.HasPets,
			&i.SpecialInstructions,
			&i.HourlyRate,
			&i.EstimatedTotal,
			&i.FinalTotal,
			&i.PlatformCommissionPct,
			&i.PlatformCommissionAmount,
			&i.Status,
			&i.StartedAt,
			&i.CompletedAt,
			&i.CancelledAt,
			&i.CancellationReason,
			&i.StripePaymentIntentID,
			&i.PaymentStatus,
			&i.PaidAt,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.RecurringGroupID,
			&i.OccurrenceNumber,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listBookingsByStatus = `-- name: ListBookingsByStatus :many
SELECT id, reference_code, client_user_id, company_id, cleaner_id, address_id, service_type, scheduled_date, scheduled_start_time, estimated_duration_hours, property_type, num_rooms, num_bathrooms, area_sqm, has_pets, special_instructions, hourly_rate, estimated_total, final_total, platform_commission_pct, platform_commission_amount, status, started_at, completed_at, cancelled_at, cancellation_reason, stripe_payment_intent_id, payment_status, paid_at, created_at, updated_at, recurring_group_id, occurrence_number FROM bookings WHERE status = $1 ORDER BY created_at DESC LIMIT $2 OFFSET $3
`

type ListBookingsByStatusParams struct {
	Status BookingStatus `json:"status"`
	Limit  int32         `json:"limit"`
	Offset int32         `json:"offset"`
}

func (q *Queries) ListBookingsByStatus(ctx context.Context, arg ListBookingsByStatusParams) ([]Booking, error) {
	rows, err := q.db.Query(ctx, listBookingsByStatus, arg.Status, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Booking
	for rows.Next() {
		var i Booking
		if err := rows.Scan(
			&i.ID,
			&i.ReferenceCode,
			&i.ClientUserID,
			&i.CompanyID,
			&i.CleanerID,
			&i.AddressID,
			&i.ServiceType,
			&i.ScheduledDate,
			&i.ScheduledStartTime,
			&i.EstimatedDurationHours,
			&i.PropertyType,
			&i.NumRooms,
			&i.NumBathrooms,
			&i.AreaSqm,
			&i.HasPets,
			&i.SpecialInstructions,
			&i.HourlyRate,
			&i.EstimatedTotal,
			&i.FinalTotal,
			&i.PlatformCommissionPct,
			&i.PlatformCommissionAmount,
			&i.Status,
			&i.StartedAt,
			&i.CompletedAt,
			&i.CancelledAt,
			&i.CancellationReason,
			&i.StripePaymentIntentID,
			&i.PaymentStatus,
			&i.PaidAt,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.RecurringGroupID,
			&i.OccurrenceNumber,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listTodaysJobsByCleaner = `-- name: ListTodaysJobsByCleaner :many
SELECT id, reference_code, client_user_id, company_id, cleaner_id, address_id, service_type, scheduled_date, scheduled_start_time, estimated_duration_hours, property_type, num_rooms, num_bathrooms, area_sqm, has_pets, special_instructions, hourly_rate, estimated_total, final_total, platform_commission_pct, platform_commission_amount, status, started_at, completed_at, cancelled_at, cancellation_reason, stripe_payment_intent_id, payment_status, paid_at, created_at, updated_at, recurring_group_id, occurrence_number FROM bookings WHERE cleaner_id = $1 AND scheduled_date = CURRENT_DATE ORDER BY scheduled_start_time
`

func (q *Queries) ListTodaysJobsByCleaner(ctx context.Context, cleanerID pgtype.UUID) ([]Booking, error) {
	rows, err := q.db.Query(ctx, listTodaysJobsByCleaner, cleanerID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Booking
	for rows.Next() {
		var i Booking
		if err := rows.Scan(
			&i.ID,
			&i.ReferenceCode,
			&i.ClientUserID,
			&i.CompanyID,
			&i.CleanerID,
			&i.AddressID,
			&i.ServiceType,
			&i.ScheduledDate,
			&i.ScheduledStartTime,
			&i.EstimatedDurationHours,
			&i.PropertyType,
			&i.NumRooms,
			&i.NumBathrooms,
			&i.AreaSqm,
			&i.HasPets,
			&i.SpecialInstructions,
			&i.HourlyRate,
			&i.EstimatedTotal,
			&i.FinalTotal,
			&i.PlatformCommissionPct,
			&i.PlatformCommissionAmount,
			&i.Status,
			&i.StartedAt,
			&i.CompletedAt,
			&i.CancelledAt,
			&i.CancellationReason,
			&i.StripePaymentIntentID,
			&i.PaymentStatus,
			&i.PaidAt,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.RecurringGroupID,
			&i.OccurrenceNumber,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchBookings = `-- name: SearchBookings :many
SELECT id, reference_code, client_user_id, company_id, cleaner_id, address_id, service_type, scheduled_date, scheduled_start_time, estimated_duration_hours, property_type, num_rooms, num_bathrooms, area_sqm, has_pets, special_instructions, hourly_rate, estimated_total, final_total, platform_commission_pct, platform_commission_amount, status, started_at, completed_at, cancelled_at, cancellation_reason, stripe_payment_intent_id, payment_status, paid_at, created_at, updated_at, recurring_group_id, occurrence_number FROM bookings WHERE
    ($3::text = '' OR reference_code ILIKE '%' || $3::text || '%')
    AND ($4::text = '' OR status::text = $4::text)
ORDER BY created_at DESC LIMIT $1 OFFSET $2
`

type SearchBookingsParams struct {
	Limit        int32  `json:"limit"`
	Offset       int32  `json:"offset"`
	Query        string `json:"query"`
	StatusFilter string `json:"status_filter"`
}

func (q *Queries) SearchBookings(ctx context.Context, arg SearchBookingsParams) ([]Booking, error) {
	rows, err := q.db.Query(ctx, searchBookings,
		arg.Limit,
		arg.Offset,
		arg.Query,
		arg.StatusFilter,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Booking
	for rows.Next() {
		var i Booking
		if err := rows.Scan(
			&i.ID,
			&i.ReferenceCode,
			&i.ClientUserID,
			&i.CompanyID,
			&i.CleanerID,
			&i.AddressID,
			&i.ServiceType,
			&i.ScheduledDate,
			&i.ScheduledStartTime,
			&i.EstimatedDurationHours,
			&i.PropertyType,
			&i.NumRooms,
			&i.NumBathrooms,
			&i.AreaSqm,
			&i.HasPets,
			&i.SpecialInstructions,
			&i.HourlyRate,
			&i.EstimatedTotal,
			&i.FinalTotal,
			&i.PlatformCommissionPct,
			&i.PlatformCommissionAmount,
			&i.Status,
			&i.StartedAt,
			&i.CompletedAt,
			&i.CancelledAt,
			&i.CancellationReason,
			&i.StripePaymentIntentID,
			&i.PaymentStatus,
			&i.PaidAt,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.RecurringGroupID,
			&i.OccurrenceNumber,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchCleanerBookings = `-- name: SearchCleanerBookings :many
SELECT id, reference_code, client_user_id, company_id, cleaner_id, address_id, service_type, scheduled_date, scheduled_start_time, estimated_duration_hours, property_type, num_rooms, num_bathrooms, area_sqm, has_pets, special_instructions, hourly_rate, estimated_total, final_total, platform_commission_pct, platform_commission_amount, status, started_at, completed_at, cancelled_at, cancellation_reason, stripe_payment_intent_id, payment_status, paid_at, created_at, updated_at, recurring_group_id, occurrence_number FROM bookings WHERE
    cleaner_id = $1
    AND ($4::text = '' OR reference_code ILIKE '%' || $4::text || '%')
    AND ($5::text = '' OR status::text = $5::text OR ($5::text = 'cancelled' AND status::text LIKE 'cancelled%'))
    AND ($6::date = '0001-01-01' OR scheduled_date >= $6::date)
    AND ($7::date = '0001-01-01' OR scheduled_date <= $7::date)
ORDER BY created_at DESC LIMIT $2 OFFSET $3
`

type SearchCleanerBookingsParams struct {
	CleanerID    pgtype.UUID `json:"cleaner_id"`
	Limit        int32       `json:"limit"`
	Offset       int32       `json:"offset"`
	Query        string      `json:"query"`
	StatusFilter string      `json:"status_filter"`
	DateFrom     pgtype.Date `json:"date_from"`
	DateTo       pgtype.Date `json:"date_to"`
}

func (q *Queries) SearchCleanerBookings(ctx context.Context, arg SearchCleanerBookingsParams) ([]Booking, error) {
	rows, err := q.db.Query(ctx, searchCleanerBookings,
		arg.CleanerID,
		arg.Limit,
		arg.Offset,
		arg.Query,
		arg.StatusFilter,
		arg.DateFrom,
		arg.DateTo,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Booking
	for rows.Next() {
		var i Booking
		if err := rows.Scan(
			&i.ID,
			&i.ReferenceCode,
			&i.ClientUserID,
			&i.CompanyID,
			&i.CleanerID,
			&i.AddressID,
			&i.ServiceType,
			&i.ScheduledDate,
			&i.ScheduledStartTime,
			&i.EstimatedDurationHours,
			&i.PropertyType,
			&i.NumRooms,
			&i.NumBathrooms,
			&i.AreaSqm,
			&i.HasPets,
			&i.SpecialInstructions,
			&i.HourlyRate,
			&i.EstimatedTotal,
			&i.FinalTotal,
			&i.PlatformCommissionPct,
			&i.PlatformCommissionAmount,
			&i.Status,
			&i.StartedAt,
			&i.CompletedAt,
			&i.CancelledAt,
			&i.CancellationReason,
			&i.StripePaymentIntentID,
			&i.PaymentStatus,
			&i.PaidAt,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.RecurringGroupID,
			&i.OccurrenceNumber,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchCompanyBookings = `-- name: SearchCompanyBookings :many
SELECT id, reference_code, client_user_id, company_id, cleaner_id, address_id, service_type, scheduled_date, scheduled_start_time, estimated_duration_hours, property_type, num_rooms, num_bathrooms, area_sqm, has_pets, special_instructions, hourly_rate, estimated_total, final_total, platform_commission_pct, platform_commission_amount, status, started_at, completed_at, cancelled_at, cancellation_reason, stripe_payment_intent_id, payment_status, paid_at, created_at, updated_at, recurring_group_id, occurrence_number FROM bookings WHERE
    company_id = $1
    AND ($4::text = '' OR reference_code ILIKE '%' || $4::text || '%')
    AND ($5::text = '' OR status::text = $5::text OR ($5::text = 'cancelled' AND status::text LIKE 'cancelled%'))
    AND ($6::date = '0001-01-01' OR scheduled_date >= $6::date)
    AND ($7::date = '0001-01-01' OR scheduled_date <= $7::date)
ORDER BY created_at DESC LIMIT $2 OFFSET $3
`

type SearchCompanyBookingsParams struct {
	CompanyID    pgtype.UUID `json:"company_id"`
	Limit        int32       `json:"limit"`
	Offset       int32       `json:"offset"`
	Query        string      `json:"query"`
	StatusFilter string      `json:"status_filter"`
	DateFrom     pgtype.Date `json:"date_from"`
	DateTo       pgtype.Date `json:"date_to"`
}

func (q *Queries) SearchCompanyBookings(ctx context.Context, arg SearchCompanyBookingsParams) ([]Booking, error) {
	rows, err := q.db.Query(ctx, searchCompanyBookings,
		arg.CompanyID,
		arg.Limit,
		arg.Offset,
		arg.Query,
		arg.StatusFilter,
		arg.DateFrom,
		arg.DateTo,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Booking
	for rows.Next() {
		var i Booking
		if err := rows.Scan(
			&i.ID,
			&i.ReferenceCode,
			&i.ClientUserID,
			&i.CompanyID,
			&i.CleanerID,
			&i.AddressID,
			&i.ServiceType,
			&i.ScheduledDate,
			&i.ScheduledStartTime,
			&i.EstimatedDurationHours,
			&i.PropertyType,
			&i.NumRooms,
			&i.NumBathrooms,
			&i.AreaSqm,
			&i.HasPets,
			&i.SpecialInstructions,
			&i.HourlyRate,
			&i.EstimatedTotal,
			&i.FinalTotal,
			&i.PlatformCommissionPct,
			&i.PlatformCommissionAmount,
			&i.Status,
			&i.StartedAt,
			&i.CompletedAt,
			&i.CancelledAt,
			&i.CancellationReason,
			&i.StripePaymentIntentID,
			&i.PaymentStatus,
			&i.PaidAt,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.RecurringGroupID,
			&i.OccurrenceNumber,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const setBookingFinalTotal = `-- name: SetBookingFinalTotal :one
UPDATE bookings SET final_total = $2, platform_commission_amount = $3, updated_at = NOW()
WHERE id = $1 RETURNING id, reference_code, client_user_id, company_id, cleaner_id, address_id, service_type, scheduled_date, scheduled_start_time, estimated_duration_hours, property_type, num_rooms, num_bathrooms, area_sqm, has_pets, special_instructions, hourly_rate, estimated_total, final_total, platform_commission_pct, platform_commission_amount, status, started_at, completed_at, cancelled_at, cancellation_reason, stripe_payment_intent_id, payment_status, paid_at, created_at, updated_at, recurring_group_id, occurrence_number
`

type SetBookingFinalTotalParams struct {
	ID                       pgtype.UUID    `json:"id"`
	FinalTotal               pgtype.Numeric `json:"final_total"`
	PlatformCommissionAmount pgtype.Numeric `json:"platform_commission_amount"`
}

func (q *Queries) SetBookingFinalTotal(ctx context.Context, arg SetBookingFinalTotalParams) (Booking, error) {
	row := q.db.QueryRow(ctx, setBookingFinalTotal, arg.ID, arg.FinalTotal, arg.PlatformCommissionAmount)
	var i Booking
	err := row.Scan(
		&i.ID,
		&i.ReferenceCode,
		&i.ClientUserID,
		&i.CompanyID,
		&i.CleanerID,
		&i.AddressID,
		&i.ServiceType,
		&i.ScheduledDate,
		&i.ScheduledStartTime,
		&i.EstimatedDurationHours,
		&i.PropertyType,
		&i.NumRooms,
		&i.NumBathrooms,
		&i.AreaSqm,
		&i.HasPets,
		&i.SpecialInstructions,
		&i.HourlyRate,
		&i.EstimatedTotal,
		&i.FinalTotal,
		&i.PlatformCommissionPct,
		&i.PlatformCommissionAmount,
		&i.Status,
		&i.StartedAt,
		&i.CompletedAt,
		&i.CancelledAt,
		&i.CancellationReason,
		&i.StripePaymentIntentID,
		&i.PaymentStatus,
		&i.PaidAt,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.RecurringGroupID,
		&i.OccurrenceNumber,
	)
	return i, err
}

const setBookingPreferredCleaner = `-- name: SetBookingPreferredCleaner :one
UPDATE bookings SET company_id = $2, cleaner_id = $3, updated_at = NOW()
WHERE id = $1 RETURNING id, reference_code, client_user_id, company_id, cleaner_id, address_id, service_type, scheduled_date, scheduled_start_time, estimated_duration_hours, property_type, num_rooms, num_bathrooms, area_sqm, has_pets, special_instructions, hourly_rate, estimated_total, final_total, platform_commission_pct, platform_commission_amount, status, started_at, completed_at, cancelled_at, cancellation_reason, stripe_payment_intent_id, payment_status, paid_at, created_at, updated_at, recurring_group_id, occurrence_number
`

type SetBookingPreferredCleanerParams struct {
	ID        pgtype.UUID `json:"id"`
	CompanyID pgtype.UUID `json:"company_id"`
	CleanerID pgtype.UUID `json:"cleaner_id"`
}

func (q *Queries) SetBookingPreferredCleaner(ctx context.Context, arg SetBookingPreferredCleanerParams) (Booking, error) {
	row := q.db.QueryRow(ctx, setBookingPreferredCleaner, arg.ID, arg.CompanyID, arg.CleanerID)
	var i Booking
	err := row.Scan(
		&i.ID,
		&i.ReferenceCode,
		&i.ClientUserID,
		&i.CompanyID,
		&i.CleanerID,
		&i.AddressID,
		&i.ServiceType,
		&i.ScheduledDate,
		&i.ScheduledStartTime,
		&i.EstimatedDurationHours,
		&i.PropertyType,
		&i.NumRooms,
		&i.NumBathrooms,
		&i.AreaSqm,
		&i.HasPets,
		&i.SpecialInstructions,
		&i.HourlyRate,
		&i.EstimatedTotal,
		&i.FinalTotal,
		&i.PlatformCommissionPct,
		&i.PlatformCommissionAmount,
		&i.Status,
		&i.StartedAt,
		&i.CompletedAt,
		&i.CancelledAt,
		&i.CancellationReason,
		&i.StripePaymentIntentID,
		&i.PaymentStatus,
		&i.PaidAt,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.RecurringGroupID,
		&i.OccurrenceNumber,
	)
	return i, err
}

const startBooking = `-- name: StartBooking :one
UPDATE bookings SET status = 'in_progress', started_at = NOW(), updated_at = NOW()
WHERE id = $1 RETURNING id, reference_code, client_user_id, company_id, cleaner_id, address_id, service_type, scheduled_date, scheduled_start_time, estimated_duration_hours, property_type, num_rooms, num_bathrooms, area_sqm, has_pets, special_instructions, hourly_rate, estimated_total, final_total, platform_commission_pct, platform_commission_amount, status, started_at, completed_at, cancelled_at, cancellation_reason, stripe_payment_intent_id, payment_status, paid_at, created_at, updated_at, recurring_group_id, occurrence_number
`

func (q *Queries) StartBooking(ctx context.Context, id pgtype.UUID) (Booking, error) {
	row := q.db.QueryRow(ctx, startBooking, id)
	var i Booking
	err := row.Scan(
		&i.ID,
		&i.ReferenceCode,
		&i.ClientUserID,
		&i.CompanyID,
		&i.CleanerID,
		&i.AddressID,
		&i.ServiceType,
		&i.ScheduledDate,
		&i.ScheduledStartTime,
		&i.EstimatedDurationHours,
		&i.PropertyType,
		&i.NumRooms,
		&i.NumBathrooms,
		&i.AreaSqm,
		&i.HasPets,
		&i.SpecialInstructions,
		&i.HourlyRate,
		&i.EstimatedTotal,
		&i.FinalTotal,
		&i.PlatformCommissionPct,
		&i.PlatformCommissionAmount,
		&i.Status,
		&i.StartedAt,
		&i.CompletedAt,
		&i.CancelledAt,
		&i.CancellationReason,
		&i.StripePaymentIntentID,
		&i.PaymentStatus,
		&i.PaidAt,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.RecurringGroupID,
		&i.OccurrenceNumber,
	)
	return i, err
}

const sumThisMonthEarningsByCleaner = `-- name: SumThisMonthEarningsByCleaner :one
SELECT COALESCE(SUM(COALESCE(final_total, estimated_total)), 0)::numeric AS total
FROM bookings
WHERE cleaner_id = $1
  AND status = 'completed'
  AND completed_at >= date_trunc('month', CURRENT_DATE)
`

func (q *Queries) SumThisMonthEarningsByCleaner(ctx context.Context, cleanerID pgtype.UUID) (pgtype.Numeric, error) {
	row := q.db.QueryRow(ctx, sumThisMonthEarningsByCleaner, cleanerID)
	var total pgtype.Numeric
	err := row.Scan(&total)
	return total, err
}

const updateBookingSchedule = `-- name: UpdateBookingSchedule :one
UPDATE bookings SET scheduled_date = $2, scheduled_start_time = $3, updated_at = NOW()
WHERE id = $1 RETURNING id, reference_code, client_user_id, company_id, cleaner_id, address_id, service_type, scheduled_date, scheduled_start_time, estimated_duration_hours, property_type, num_rooms, num_bathrooms, area_sqm, has_pets, special_instructions, hourly_rate, estimated_total, final_total, platform_commission_pct, platform_commission_amount, status, started_at, completed_at, cancelled_at, cancellation_reason, stripe_payment_intent_id, payment_status, paid_at, created_at, updated_at, recurring_group_id, occurrence_number
`

type UpdateBookingScheduleParams struct {
	ID                 pgtype.UUID `json:"id"`
	ScheduledDate      pgtype.Date `json:"scheduled_date"`
	ScheduledStartTime pgtype.Time `json:"scheduled_start_time"`
}

func (q *Queries) UpdateBookingSchedule(ctx context.Context, arg UpdateBookingScheduleParams) (Booking, error) {
	row := q.db.QueryRow(ctx, updateBookingSchedule, arg.ID, arg.ScheduledDate, arg.ScheduledStartTime)
	var i Booking
	err := row.Scan(
		&i.ID,
		&i.ReferenceCode,
		&i.ClientUserID,
		&i.CompanyID,
		&i.CleanerID,
		&i.AddressID,
		&i.ServiceType,
		&i.ScheduledDate,
		&i.ScheduledStartTime,
		&i.EstimatedDurationHours,
		&i.PropertyType,
		&i.NumRooms,
		&i.NumBathrooms,
		&i.AreaSqm,
		&i.HasPets,
		&i.SpecialInstructions,
		&i.HourlyRate,
		&i.EstimatedTotal,
		&i.FinalTotal,
		&i.PlatformCommissionPct,
		&i.PlatformCommissionAmount,
		&i.Status,
		&i.StartedAt,
		&i.CompletedAt,
		&i.CancelledAt,
		&i.CancellationReason,
		&i.StripePaymentIntentID,
		&i.PaymentStatus,
		&i.PaidAt,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.RecurringGroupID,
		&i.OccurrenceNumber,
	)
	return i, err
}

const updateBookingStatus = `-- name: UpdateBookingStatus :one
UPDATE bookings SET status = $2, updated_at = NOW() WHERE id = $1 RETURNING id, reference_code, client_user_id, company_id, cleaner_id, address_id, service_type, scheduled_date, scheduled_start_time, estimated_duration_hours, property_type, num_rooms, num_bathrooms, area_sqm, has_pets, special_instructions, hourly_rate, estimated_total, final_total, platform_commission_pct, platform_commission_amount, status, started_at, completed_at, cancelled_at, cancellation_reason, stripe_payment_intent_id, payment_status, paid_at, created_at, updated_at, recurring_group_id, occurrence_number
`

type UpdateBookingStatusParams struct {
	ID     pgtype.UUID   `json:"id"`
	Status BookingStatus `json:"status"`
}

func (q *Queries) UpdateBookingStatus(ctx context.Context, arg UpdateBookingStatusParams) (Booking, error) {
	row := q.db.QueryRow(ctx, updateBookingStatus, arg.ID, arg.Status)
	var i Booking
	err := row.Scan(
		&i.ID,
		&i.ReferenceCode,
		&i.ClientUserID,
		&i.CompanyID,
		&i.CleanerID,
		&i.AddressID,
		&i.ServiceType,
		&i.ScheduledDate,
		&i.ScheduledStartTime,
		&i.EstimatedDurationHours,
		&i.PropertyType,
		&i.NumRooms,
		&i.NumBathrooms,
		&i.AreaSqm,
		&i.HasPets,
		&i.SpecialInstructions,
		&i.HourlyRate,
		&i.EstimatedTotal,
		&i.FinalTotal,
		&i.PlatformCommissionPct,
		&i.PlatformCommissionAmount,
		&i.Status,
		&i.StartedAt,
		&i.CompletedAt,
		&i.CancelledAt,
		&i.CancellationReason,
		&i.StripePaymentIntentID,
		&i.PaymentStatus,
		&i.PaidAt,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.RecurringGroupID,
		&i.OccurrenceNumber,
	)
	return i, err
}
