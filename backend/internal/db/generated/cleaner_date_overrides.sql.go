// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: cleaner_date_overrides.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const deleteCleanerDateOverride = `-- name: DeleteCleanerDateOverride :exec
DELETE FROM cleaner_date_overrides WHERE cleaner_id = $1 AND override_date = $2
`

type DeleteCleanerDateOverrideParams struct {
	CleanerID    pgtype.UUID `json:"cleaner_id"`
	OverrideDate pgtype.Date `json:"override_date"`
}

func (q *Queries) DeleteCleanerDateOverride(ctx context.Context, arg DeleteCleanerDateOverrideParams) error {
	_, err := q.db.Exec(ctx, deleteCleanerDateOverride, arg.CleanerID, arg.OverrideDate)
	return err
}

const listCleanerDateOverrides = `-- name: ListCleanerDateOverrides :many
SELECT id, cleaner_id, override_date, is_available, start_time, end_time, created_at FROM cleaner_date_overrides
WHERE cleaner_id = $1 AND override_date >= $2 AND override_date <= $3
ORDER BY override_date
`

type ListCleanerDateOverridesParams struct {
	CleanerID      pgtype.UUID `json:"cleaner_id"`
	OverrideDate   pgtype.Date `json:"override_date"`
	OverrideDate_2 pgtype.Date `json:"override_date_2"`
}

func (q *Queries) ListCleanerDateOverrides(ctx context.Context, arg ListCleanerDateOverridesParams) ([]CleanerDateOverride, error) {
	rows, err := q.db.Query(ctx, listCleanerDateOverrides, arg.CleanerID, arg.OverrideDate, arg.OverrideDate_2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []CleanerDateOverride
	for rows.Next() {
		var i CleanerDateOverride
		if err := rows.Scan(
			&i.ID,
			&i.CleanerID,
			&i.OverrideDate,
			&i.IsAvailable,
			&i.StartTime,
			&i.EndTime,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const upsertCleanerDateOverride = `-- name: UpsertCleanerDateOverride :one
INSERT INTO cleaner_date_overrides (cleaner_id, override_date, is_available, start_time, end_time)
VALUES ($1, $2, $3, $4, $5)
ON CONFLICT (cleaner_id, override_date)
DO UPDATE SET is_available = EXCLUDED.is_available, start_time = EXCLUDED.start_time, end_time = EXCLUDED.end_time
RETURNING id, cleaner_id, override_date, is_available, start_time, end_time, created_at
`

type UpsertCleanerDateOverrideParams struct {
	CleanerID    pgtype.UUID `json:"cleaner_id"`
	OverrideDate pgtype.Date `json:"override_date"`
	IsAvailable  bool        `json:"is_available"`
	StartTime    pgtype.Time `json:"start_time"`
	EndTime      pgtype.Time `json:"end_time"`
}

func (q *Queries) UpsertCleanerDateOverride(ctx context.Context, arg UpsertCleanerDateOverrideParams) (CleanerDateOverride, error) {
	row := q.db.QueryRow(ctx, upsertCleanerDateOverride,
		arg.CleanerID,
		arg.OverrideDate,
		arg.IsAvailable,
		arg.StartTime,
		arg.EndTime,
	)
	var i CleanerDateOverride
	err := row.Scan(
		&i.ID,
		&i.CleanerID,
		&i.OverrideDate,
		&i.IsAvailable,
		&i.StartTime,
		&i.EndTime,
		&i.CreatedAt,
	)
	return i, err
}
