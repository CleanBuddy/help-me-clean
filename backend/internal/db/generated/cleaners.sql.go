// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: cleaners.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const activateCleanerStatus = `-- name: ActivateCleanerStatus :one
UPDATE cleaners SET status = 'active', updated_at = NOW() WHERE id = $1 RETURNING id, user_id, company_id, full_name, phone, email, status, is_company_admin, invite_token, invite_expires_at, rating_avg, total_jobs_completed, created_at, updated_at, bio
`

func (q *Queries) ActivateCleanerStatus(ctx context.Context, id pgtype.UUID) (Cleaner, error) {
	row := q.db.QueryRow(ctx, activateCleanerStatus, id)
	var i Cleaner
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.CompanyID,
		&i.FullName,
		&i.Phone,
		&i.Email,
		&i.Status,
		&i.IsCompanyAdmin,
		&i.InviteToken,
		&i.InviteExpiresAt,
		&i.RatingAvg,
		&i.TotalJobsCompleted,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Bio,
	)
	return i, err
}

const createCleaner = `-- name: CreateCleaner :one
INSERT INTO cleaners (company_id, full_name, phone, email, status, is_company_admin, invite_token, invite_expires_at)
VALUES ($1, $2, $3, $4, $5, $6, $7, $8)
RETURNING id, user_id, company_id, full_name, phone, email, status, is_company_admin, invite_token, invite_expires_at, rating_avg, total_jobs_completed, created_at, updated_at, bio
`

type CreateCleanerParams struct {
	CompanyID       pgtype.UUID        `json:"company_id"`
	FullName        string             `json:"full_name"`
	Phone           pgtype.Text        `json:"phone"`
	Email           pgtype.Text        `json:"email"`
	Status          CleanerStatus      `json:"status"`
	IsCompanyAdmin  pgtype.Bool        `json:"is_company_admin"`
	InviteToken     pgtype.Text        `json:"invite_token"`
	InviteExpiresAt pgtype.Timestamptz `json:"invite_expires_at"`
}

func (q *Queries) CreateCleaner(ctx context.Context, arg CreateCleanerParams) (Cleaner, error) {
	row := q.db.QueryRow(ctx, createCleaner,
		arg.CompanyID,
		arg.FullName,
		arg.Phone,
		arg.Email,
		arg.Status,
		arg.IsCompanyAdmin,
		arg.InviteToken,
		arg.InviteExpiresAt,
	)
	var i Cleaner
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.CompanyID,
		&i.FullName,
		&i.Phone,
		&i.Email,
		&i.Status,
		&i.IsCompanyAdmin,
		&i.InviteToken,
		&i.InviteExpiresAt,
		&i.RatingAvg,
		&i.TotalJobsCompleted,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Bio,
	)
	return i, err
}

const getCleanerByID = `-- name: GetCleanerByID :one
SELECT id, user_id, company_id, full_name, phone, email, status, is_company_admin, invite_token, invite_expires_at, rating_avg, total_jobs_completed, created_at, updated_at, bio FROM cleaners WHERE id = $1
`

func (q *Queries) GetCleanerByID(ctx context.Context, id pgtype.UUID) (Cleaner, error) {
	row := q.db.QueryRow(ctx, getCleanerByID, id)
	var i Cleaner
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.CompanyID,
		&i.FullName,
		&i.Phone,
		&i.Email,
		&i.Status,
		&i.IsCompanyAdmin,
		&i.InviteToken,
		&i.InviteExpiresAt,
		&i.RatingAvg,
		&i.TotalJobsCompleted,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Bio,
	)
	return i, err
}

const getCleanerByInviteToken = `-- name: GetCleanerByInviteToken :one
SELECT id, user_id, company_id, full_name, phone, email, status, is_company_admin, invite_token, invite_expires_at, rating_avg, total_jobs_completed, created_at, updated_at, bio FROM cleaners WHERE invite_token = $1
`

func (q *Queries) GetCleanerByInviteToken(ctx context.Context, inviteToken pgtype.Text) (Cleaner, error) {
	row := q.db.QueryRow(ctx, getCleanerByInviteToken, inviteToken)
	var i Cleaner
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.CompanyID,
		&i.FullName,
		&i.Phone,
		&i.Email,
		&i.Status,
		&i.IsCompanyAdmin,
		&i.InviteToken,
		&i.InviteExpiresAt,
		&i.RatingAvg,
		&i.TotalJobsCompleted,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Bio,
	)
	return i, err
}

const getCleanerByUserID = `-- name: GetCleanerByUserID :one
SELECT id, user_id, company_id, full_name, phone, email, status, is_company_admin, invite_token, invite_expires_at, rating_avg, total_jobs_completed, created_at, updated_at, bio FROM cleaners WHERE user_id = $1
`

func (q *Queries) GetCleanerByUserID(ctx context.Context, userID pgtype.UUID) (Cleaner, error) {
	row := q.db.QueryRow(ctx, getCleanerByUserID, userID)
	var i Cleaner
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.CompanyID,
		&i.FullName,
		&i.Phone,
		&i.Email,
		&i.Status,
		&i.IsCompanyAdmin,
		&i.InviteToken,
		&i.InviteExpiresAt,
		&i.RatingAvg,
		&i.TotalJobsCompleted,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Bio,
	)
	return i, err
}

const getCleanerPerformanceStats = `-- name: GetCleanerPerformanceStats :one
SELECT
    c.id,
    c.full_name,
    c.rating_avg,
    COUNT(b.id) FILTER (WHERE b.status = 'completed')::bigint AS total_completed_jobs,
    COUNT(b.id) FILTER (WHERE b.status = 'completed' AND b.completed_at >= date_trunc('month', CURRENT_DATE))::bigint AS this_month_completed,
    COALESCE(SUM(COALESCE(b.final_total, b.estimated_total)) FILTER (WHERE b.status = 'completed'), 0)::numeric AS total_earnings,
    COALESCE(SUM(COALESCE(b.final_total, b.estimated_total)) FILTER (WHERE b.status = 'completed' AND b.completed_at >= date_trunc('month', CURRENT_DATE)), 0)::numeric AS this_month_earnings
FROM cleaners c
LEFT JOIN bookings b ON b.cleaner_id = c.id
WHERE c.id = $1
GROUP BY c.id, c.full_name, c.rating_avg
`

type GetCleanerPerformanceStatsRow struct {
	ID                 pgtype.UUID    `json:"id"`
	FullName           string         `json:"full_name"`
	RatingAvg          pgtype.Numeric `json:"rating_avg"`
	TotalCompletedJobs int64          `json:"total_completed_jobs"`
	ThisMonthCompleted int64          `json:"this_month_completed"`
	TotalEarnings      pgtype.Numeric `json:"total_earnings"`
	ThisMonthEarnings  pgtype.Numeric `json:"this_month_earnings"`
}

func (q *Queries) GetCleanerPerformanceStats(ctx context.Context, id pgtype.UUID) (GetCleanerPerformanceStatsRow, error) {
	row := q.db.QueryRow(ctx, getCleanerPerformanceStats, id)
	var i GetCleanerPerformanceStatsRow
	err := row.Scan(
		&i.ID,
		&i.FullName,
		&i.RatingAvg,
		&i.TotalCompletedJobs,
		&i.ThisMonthCompleted,
		&i.TotalEarnings,
		&i.ThisMonthEarnings,
	)
	return i, err
}

const linkCleanerToUser = `-- name: LinkCleanerToUser :one
UPDATE cleaners SET user_id = $2, status = 'pending_review', updated_at = NOW() WHERE id = $1 RETURNING id, user_id, company_id, full_name, phone, email, status, is_company_admin, invite_token, invite_expires_at, rating_avg, total_jobs_completed, created_at, updated_at, bio
`

type LinkCleanerToUserParams struct {
	ID     pgtype.UUID `json:"id"`
	UserID pgtype.UUID `json:"user_id"`
}

func (q *Queries) LinkCleanerToUser(ctx context.Context, arg LinkCleanerToUserParams) (Cleaner, error) {
	row := q.db.QueryRow(ctx, linkCleanerToUser, arg.ID, arg.UserID)
	var i Cleaner
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.CompanyID,
		&i.FullName,
		&i.Phone,
		&i.Email,
		&i.Status,
		&i.IsCompanyAdmin,
		&i.InviteToken,
		&i.InviteExpiresAt,
		&i.RatingAvg,
		&i.TotalJobsCompleted,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Bio,
	)
	return i, err
}

const listAllActiveCleaners = `-- name: ListAllActiveCleaners :many
SELECT id, user_id, company_id, full_name, phone, email, status, is_company_admin, invite_token, invite_expires_at, rating_avg, total_jobs_completed, created_at, updated_at, bio FROM cleaners WHERE status = 'active' ORDER BY full_name ASC
`

func (q *Queries) ListAllActiveCleaners(ctx context.Context) ([]Cleaner, error) {
	rows, err := q.db.Query(ctx, listAllActiveCleaners)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Cleaner
	for rows.Next() {
		var i Cleaner
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.CompanyID,
			&i.FullName,
			&i.Phone,
			&i.Email,
			&i.Status,
			&i.IsCompanyAdmin,
			&i.InviteToken,
			&i.InviteExpiresAt,
			&i.RatingAvg,
			&i.TotalJobsCompleted,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Bio,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listCleanersByCompany = `-- name: ListCleanersByCompany :many
SELECT id, user_id, company_id, full_name, phone, email, status, is_company_admin, invite_token, invite_expires_at, rating_avg, total_jobs_completed, created_at, updated_at, bio FROM cleaners WHERE company_id = $1 ORDER BY created_at DESC
`

func (q *Queries) ListCleanersByCompany(ctx context.Context, companyID pgtype.UUID) ([]Cleaner, error) {
	rows, err := q.db.Query(ctx, listCleanersByCompany, companyID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Cleaner
	for rows.Next() {
		var i Cleaner
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.CompanyID,
			&i.FullName,
			&i.Phone,
			&i.Email,
			&i.Status,
			&i.IsCompanyAdmin,
			&i.InviteToken,
			&i.InviteExpiresAt,
			&i.RatingAvg,
			&i.TotalJobsCompleted,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Bio,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateCleanerOwnProfile = `-- name: UpdateCleanerOwnProfile :one
UPDATE cleaners SET
    phone = $2::text,
    bio = $3::text,
    updated_at = NOW()
WHERE id = $1 RETURNING id, user_id, company_id, full_name, phone, email, status, is_company_admin, invite_token, invite_expires_at, rating_avg, total_jobs_completed, created_at, updated_at, bio
`

type UpdateCleanerOwnProfileParams struct {
	ID       pgtype.UUID `json:"id"`
	NewPhone string      `json:"new_phone"`
	NewBio   string      `json:"new_bio"`
}

func (q *Queries) UpdateCleanerOwnProfile(ctx context.Context, arg UpdateCleanerOwnProfileParams) (Cleaner, error) {
	row := q.db.QueryRow(ctx, updateCleanerOwnProfile, arg.ID, arg.NewPhone, arg.NewBio)
	var i Cleaner
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.CompanyID,
		&i.FullName,
		&i.Phone,
		&i.Email,
		&i.Status,
		&i.IsCompanyAdmin,
		&i.InviteToken,
		&i.InviteExpiresAt,
		&i.RatingAvg,
		&i.TotalJobsCompleted,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Bio,
	)
	return i, err
}

const updateCleanerStatus = `-- name: UpdateCleanerStatus :one
UPDATE cleaners SET status = $2, updated_at = NOW() WHERE id = $1 RETURNING id, user_id, company_id, full_name, phone, email, status, is_company_admin, invite_token, invite_expires_at, rating_avg, total_jobs_completed, created_at, updated_at, bio
`

type UpdateCleanerStatusParams struct {
	ID     pgtype.UUID   `json:"id"`
	Status CleanerStatus `json:"status"`
}

func (q *Queries) UpdateCleanerStatus(ctx context.Context, arg UpdateCleanerStatusParams) (Cleaner, error) {
	row := q.db.QueryRow(ctx, updateCleanerStatus, arg.ID, arg.Status)
	var i Cleaner
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.CompanyID,
		&i.FullName,
		&i.Phone,
		&i.Email,
		&i.Status,
		&i.IsCompanyAdmin,
		&i.InviteToken,
		&i.InviteExpiresAt,
		&i.RatingAvg,
		&i.TotalJobsCompleted,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Bio,
	)
	return i, err
}
