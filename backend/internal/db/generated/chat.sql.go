// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: chat.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const addChatParticipant = `-- name: AddChatParticipant :one
INSERT INTO chat_participants (room_id, user_id) VALUES ($1, $2) RETURNING id, room_id, user_id, joined_at
`

type AddChatParticipantParams struct {
	RoomID pgtype.UUID `json:"room_id"`
	UserID pgtype.UUID `json:"user_id"`
}

func (q *Queries) AddChatParticipant(ctx context.Context, arg AddChatParticipantParams) (ChatParticipant, error) {
	row := q.db.QueryRow(ctx, addChatParticipant, arg.RoomID, arg.UserID)
	var i ChatParticipant
	err := row.Scan(
		&i.ID,
		&i.RoomID,
		&i.UserID,
		&i.JoinedAt,
	)
	return i, err
}

const checkChatParticipant = `-- name: CheckChatParticipant :one
SELECT COUNT(*) FROM chat_participants WHERE room_id = $1 AND user_id = $2
`

type CheckChatParticipantParams struct {
	RoomID pgtype.UUID `json:"room_id"`
	UserID pgtype.UUID `json:"user_id"`
}

func (q *Queries) CheckChatParticipant(ctx context.Context, arg CheckChatParticipantParams) (int64, error) {
	row := q.db.QueryRow(ctx, checkChatParticipant, arg.RoomID, arg.UserID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createChatMessage = `-- name: CreateChatMessage :one
INSERT INTO chat_messages (room_id, sender_id, content, message_type) VALUES ($1, $2, $3, $4) RETURNING id, room_id, sender_id, content, message_type, is_read, created_at
`

type CreateChatMessageParams struct {
	RoomID      pgtype.UUID `json:"room_id"`
	SenderID    pgtype.UUID `json:"sender_id"`
	Content     string      `json:"content"`
	MessageType pgtype.Text `json:"message_type"`
}

func (q *Queries) CreateChatMessage(ctx context.Context, arg CreateChatMessageParams) (ChatMessage, error) {
	row := q.db.QueryRow(ctx, createChatMessage,
		arg.RoomID,
		arg.SenderID,
		arg.Content,
		arg.MessageType,
	)
	var i ChatMessage
	err := row.Scan(
		&i.ID,
		&i.RoomID,
		&i.SenderID,
		&i.Content,
		&i.MessageType,
		&i.IsRead,
		&i.CreatedAt,
	)
	return i, err
}

const createChatRoom = `-- name: CreateChatRoom :one
INSERT INTO chat_rooms (booking_id, room_type) VALUES ($1, $2) RETURNING id, booking_id, room_type, created_at
`

type CreateChatRoomParams struct {
	BookingID pgtype.UUID `json:"booking_id"`
	RoomType  string      `json:"room_type"`
}

func (q *Queries) CreateChatRoom(ctx context.Context, arg CreateChatRoomParams) (ChatRoom, error) {
	row := q.db.QueryRow(ctx, createChatRoom, arg.BookingID, arg.RoomType)
	var i ChatRoom
	err := row.Scan(
		&i.ID,
		&i.BookingID,
		&i.RoomType,
		&i.CreatedAt,
	)
	return i, err
}

const findChatRoomByExactParticipants = `-- name: FindChatRoomByExactParticipants :one
SELECT cr.id, cr.booking_id, cr.room_type, cr.created_at FROM chat_rooms cr
  JOIN chat_participants cp ON cp.room_id = cr.id
WHERE cr.room_type = 'admin_support'
  AND cp.user_id = ANY($1::uuid[])
GROUP BY cr.id, cr.booking_id, cr.room_type, cr.created_at
HAVING COUNT(DISTINCT cp.user_id) = $2::bigint
  AND $2::bigint = (SELECT COUNT(*) FROM chat_participants cp2 WHERE cp2.room_id = cr.id)
LIMIT 1
`

type FindChatRoomByExactParticipantsParams struct {
	ParticipantIds   []pgtype.UUID `json:"participant_ids"`
	ParticipantCount int64         `json:"participant_count"`
}

func (q *Queries) FindChatRoomByExactParticipants(ctx context.Context, arg FindChatRoomByExactParticipantsParams) (ChatRoom, error) {
	row := q.db.QueryRow(ctx, findChatRoomByExactParticipants, arg.ParticipantIds, arg.ParticipantCount)
	var i ChatRoom
	err := row.Scan(
		&i.ID,
		&i.BookingID,
		&i.RoomType,
		&i.CreatedAt,
	)
	return i, err
}

const findDirectChatRoom = `-- name: FindDirectChatRoom :one
SELECT cr.id, cr.booking_id, cr.room_type, cr.created_at FROM chat_rooms cr
  JOIN chat_participants cp1 ON cp1.room_id = cr.id AND cp1.user_id = $1
  JOIN chat_participants cp2 ON cp2.room_id = cr.id AND cp2.user_id = $2
WHERE cr.room_type = 'admin_support'
LIMIT 1
`

type FindDirectChatRoomParams struct {
	UserID   pgtype.UUID `json:"user_id"`
	UserID_2 pgtype.UUID `json:"user_id_2"`
}

func (q *Queries) FindDirectChatRoom(ctx context.Context, arg FindDirectChatRoomParams) (ChatRoom, error) {
	row := q.db.QueryRow(ctx, findDirectChatRoom, arg.UserID, arg.UserID_2)
	var i ChatRoom
	err := row.Scan(
		&i.ID,
		&i.BookingID,
		&i.RoomType,
		&i.CreatedAt,
	)
	return i, err
}

const getChatRoomByBookingID = `-- name: GetChatRoomByBookingID :one
SELECT id, booking_id, room_type, created_at FROM chat_rooms WHERE booking_id = $1
`

func (q *Queries) GetChatRoomByBookingID(ctx context.Context, bookingID pgtype.UUID) (ChatRoom, error) {
	row := q.db.QueryRow(ctx, getChatRoomByBookingID, bookingID)
	var i ChatRoom
	err := row.Scan(
		&i.ID,
		&i.BookingID,
		&i.RoomType,
		&i.CreatedAt,
	)
	return i, err
}

const getChatRoomByID = `-- name: GetChatRoomByID :one
SELECT id, booking_id, room_type, created_at FROM chat_rooms WHERE id = $1
`

func (q *Queries) GetChatRoomByID(ctx context.Context, id pgtype.UUID) (ChatRoom, error) {
	row := q.db.QueryRow(ctx, getChatRoomByID, id)
	var i ChatRoom
	err := row.Scan(
		&i.ID,
		&i.BookingID,
		&i.RoomType,
		&i.CreatedAt,
	)
	return i, err
}

const getLastChatMessage = `-- name: GetLastChatMessage :one
SELECT id, room_id, sender_id, content, message_type, is_read, created_at FROM chat_messages WHERE room_id = $1 ORDER BY created_at DESC LIMIT 1
`

func (q *Queries) GetLastChatMessage(ctx context.Context, roomID pgtype.UUID) (ChatMessage, error) {
	row := q.db.QueryRow(ctx, getLastChatMessage, roomID)
	var i ChatMessage
	err := row.Scan(
		&i.ID,
		&i.RoomID,
		&i.SenderID,
		&i.Content,
		&i.MessageType,
		&i.IsRead,
		&i.CreatedAt,
	)
	return i, err
}

const listAllChatRooms = `-- name: ListAllChatRooms :many
SELECT id, booking_id, room_type, created_at FROM chat_rooms ORDER BY created_at DESC
`

func (q *Queries) ListAllChatRooms(ctx context.Context) ([]ChatRoom, error) {
	rows, err := q.db.Query(ctx, listAllChatRooms)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ChatRoom
	for rows.Next() {
		var i ChatRoom
		if err := rows.Scan(
			&i.ID,
			&i.BookingID,
			&i.RoomType,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listChatMessages = `-- name: ListChatMessages :many
SELECT id, room_id, sender_id, content, message_type, is_read, created_at FROM chat_messages WHERE room_id = $1 ORDER BY created_at ASC LIMIT $2 OFFSET $3
`

type ListChatMessagesParams struct {
	RoomID pgtype.UUID `json:"room_id"`
	Limit  int32       `json:"limit"`
	Offset int32       `json:"offset"`
}

func (q *Queries) ListChatMessages(ctx context.Context, arg ListChatMessagesParams) ([]ChatMessage, error) {
	rows, err := q.db.Query(ctx, listChatMessages, arg.RoomID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ChatMessage
	for rows.Next() {
		var i ChatMessage
		if err := rows.Scan(
			&i.ID,
			&i.RoomID,
			&i.SenderID,
			&i.Content,
			&i.MessageType,
			&i.IsRead,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listChatParticipants = `-- name: ListChatParticipants :many
SELECT id, room_id, user_id, joined_at FROM chat_participants WHERE room_id = $1
`

func (q *Queries) ListChatParticipants(ctx context.Context, roomID pgtype.UUID) ([]ChatParticipant, error) {
	rows, err := q.db.Query(ctx, listChatParticipants, roomID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ChatParticipant
	for rows.Next() {
		var i ChatParticipant
		if err := rows.Scan(
			&i.ID,
			&i.RoomID,
			&i.UserID,
			&i.JoinedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listChatRoomsByCompanyCleaners = `-- name: ListChatRoomsByCompanyCleaners :many
SELECT DISTINCT cr.id, cr.booking_id, cr.room_type, cr.created_at FROM chat_rooms cr
  JOIN chat_participants cp ON cp.room_id = cr.id
  JOIN cleaners c ON c.user_id = cp.user_id AND c.company_id = $1
ORDER BY cr.created_at DESC
`

func (q *Queries) ListChatRoomsByCompanyCleaners(ctx context.Context, companyID pgtype.UUID) ([]ChatRoom, error) {
	rows, err := q.db.Query(ctx, listChatRoomsByCompanyCleaners, companyID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ChatRoom
	for rows.Next() {
		var i ChatRoom
		if err := rows.Scan(
			&i.ID,
			&i.BookingID,
			&i.RoomType,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listChatRoomsByUser = `-- name: ListChatRoomsByUser :many
SELECT cr.id, cr.booking_id, cr.room_type, cr.created_at FROM chat_rooms cr
JOIN chat_participants cp ON cr.id = cp.room_id
WHERE cp.user_id = $1
ORDER BY cr.created_at DESC
`

func (q *Queries) ListChatRoomsByUser(ctx context.Context, userID pgtype.UUID) ([]ChatRoom, error) {
	rows, err := q.db.Query(ctx, listChatRoomsByUser, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ChatRoom
	for rows.Next() {
		var i ChatRoom
		if err := rows.Scan(
			&i.ID,
			&i.BookingID,
			&i.RoomType,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const markMessagesRead = `-- name: MarkMessagesRead :exec
UPDATE chat_messages SET is_read = TRUE WHERE room_id = $1 AND sender_id != $2 AND is_read = FALSE
`

type MarkMessagesReadParams struct {
	RoomID   pgtype.UUID `json:"room_id"`
	SenderID pgtype.UUID `json:"sender_id"`
}

func (q *Queries) MarkMessagesRead(ctx context.Context, arg MarkMessagesReadParams) error {
	_, err := q.db.Exec(ctx, markMessagesRead, arg.RoomID, arg.SenderID)
	return err
}
