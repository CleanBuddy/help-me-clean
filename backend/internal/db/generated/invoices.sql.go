// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: invoices.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const countInvoicesByClient = `-- name: CountInvoicesByClient :one
SELECT COUNT(*) FROM invoices WHERE client_user_id = $1
`

func (q *Queries) CountInvoicesByClient(ctx context.Context, clientUserID pgtype.UUID) (int64, error) {
	row := q.db.QueryRow(ctx, countInvoicesByClient, clientUserID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countInvoicesByCompany = `-- name: CountInvoicesByCompany :one
SELECT COUNT(*) FROM invoices WHERE company_id = $1
`

func (q *Queries) CountInvoicesByCompany(ctx context.Context, companyID pgtype.UUID) (int64, error) {
	row := q.db.QueryRow(ctx, countInvoicesByCompany, companyID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createBillingProfile = `-- name: CreateBillingProfile :one
INSERT INTO client_billing_profiles (
  user_id, is_company, company_name, cui, reg_number, address, city, county, is_vat_payer, bank_name, iban, is_default
) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, TRUE)
RETURNING id, user_id, is_company, company_name, cui, reg_number, address, city, county, is_vat_payer, bank_name, iban, is_default, created_at, updated_at
`

type CreateBillingProfileParams struct {
	UserID      pgtype.UUID `json:"user_id"`
	IsCompany   bool        `json:"is_company"`
	CompanyName pgtype.Text `json:"company_name"`
	Cui         pgtype.Text `json:"cui"`
	RegNumber   pgtype.Text `json:"reg_number"`
	Address     pgtype.Text `json:"address"`
	City        pgtype.Text `json:"city"`
	County      pgtype.Text `json:"county"`
	IsVatPayer  pgtype.Bool `json:"is_vat_payer"`
	BankName    pgtype.Text `json:"bank_name"`
	Iban        pgtype.Text `json:"iban"`
}

func (q *Queries) CreateBillingProfile(ctx context.Context, arg CreateBillingProfileParams) (ClientBillingProfile, error) {
	row := q.db.QueryRow(ctx, createBillingProfile,
		arg.UserID,
		arg.IsCompany,
		arg.CompanyName,
		arg.Cui,
		arg.RegNumber,
		arg.Address,
		arg.City,
		arg.County,
		arg.IsVatPayer,
		arg.BankName,
		arg.Iban,
	)
	var i ClientBillingProfile
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.IsCompany,
		&i.CompanyName,
		&i.Cui,
		&i.RegNumber,
		&i.Address,
		&i.City,
		&i.County,
		&i.IsVatPayer,
		&i.BankName,
		&i.Iban,
		&i.IsDefault,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createInvoice = `-- name: CreateInvoice :one

INSERT INTO invoices (
  invoice_type, invoice_number,
  seller_company_name, seller_cui, seller_reg_number, seller_address, seller_city, seller_county,
  seller_is_vat_payer, seller_bank_name, seller_iban,
  buyer_name, buyer_cui, buyer_reg_number, buyer_address, buyer_city, buyer_county,
  buyer_is_vat_payer, buyer_email,
  subtotal_amount, vat_rate, vat_amount, total_amount, currency,
  booking_id, payment_transaction_id, company_id, client_user_id,
  status, due_date, notes
) VALUES (
  $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11,
  $12, $13, $14, $15, $16, $17, $18, $19,
  $20, $21, $22, $23, $24,
  $25, $26, $27, $28,
  $29, $30, $31
)
RETURNING id, invoice_type, invoice_number, factureaza_id, factureaza_download_url, seller_company_name, seller_cui, seller_reg_number, seller_address, seller_city, seller_county, seller_is_vat_payer, seller_bank_name, seller_iban, buyer_name, buyer_cui, buyer_reg_number, buyer_address, buyer_city, buyer_county, buyer_is_vat_payer, buyer_email, subtotal_amount, vat_rate, vat_amount, total_amount, currency, booking_id, payment_transaction_id, company_id, client_user_id, efactura_status, efactura_index, status, issued_at, due_date, notes, created_at, updated_at
`

type CreateInvoiceParams struct {
	InvoiceType          InvoiceType    `json:"invoice_type"`
	InvoiceNumber        pgtype.Text    `json:"invoice_number"`
	SellerCompanyName    string         `json:"seller_company_name"`
	SellerCui            string         `json:"seller_cui"`
	SellerRegNumber      pgtype.Text    `json:"seller_reg_number"`
	SellerAddress        string         `json:"seller_address"`
	SellerCity           string         `json:"seller_city"`
	SellerCounty         string         `json:"seller_county"`
	SellerIsVatPayer     bool           `json:"seller_is_vat_payer"`
	SellerBankName       pgtype.Text    `json:"seller_bank_name"`
	SellerIban           pgtype.Text    `json:"seller_iban"`
	BuyerName            string         `json:"buyer_name"`
	BuyerCui             pgtype.Text    `json:"buyer_cui"`
	BuyerRegNumber       pgtype.Text    `json:"buyer_reg_number"`
	BuyerAddress         pgtype.Text    `json:"buyer_address"`
	BuyerCity            pgtype.Text    `json:"buyer_city"`
	BuyerCounty          pgtype.Text    `json:"buyer_county"`
	BuyerIsVatPayer      pgtype.Bool    `json:"buyer_is_vat_payer"`
	BuyerEmail           pgtype.Text    `json:"buyer_email"`
	SubtotalAmount       int32          `json:"subtotal_amount"`
	VatRate              pgtype.Numeric `json:"vat_rate"`
	VatAmount            int32          `json:"vat_amount"`
	TotalAmount          int32          `json:"total_amount"`
	Currency             string         `json:"currency"`
	BookingID            pgtype.UUID    `json:"booking_id"`
	PaymentTransactionID pgtype.UUID    `json:"payment_transaction_id"`
	CompanyID            pgtype.UUID    `json:"company_id"`
	ClientUserID         pgtype.UUID    `json:"client_user_id"`
	Status               InvoiceStatus  `json:"status"`
	DueDate              pgtype.Date    `json:"due_date"`
	Notes                pgtype.Text    `json:"notes"`
}

// ============================================
// INVOICES
// ============================================
func (q *Queries) CreateInvoice(ctx context.Context, arg CreateInvoiceParams) (Invoice, error) {
	row := q.db.QueryRow(ctx, createInvoice,
		arg.InvoiceType,
		arg.InvoiceNumber,
		arg.SellerCompanyName,
		arg.SellerCui,
		arg.SellerRegNumber,
		arg.SellerAddress,
		arg.SellerCity,
		arg.SellerCounty,
		arg.SellerIsVatPayer,
		arg.SellerBankName,
		arg.SellerIban,
		arg.BuyerName,
		arg.BuyerCui,
		arg.BuyerRegNumber,
		arg.BuyerAddress,
		arg.BuyerCity,
		arg.BuyerCounty,
		arg.BuyerIsVatPayer,
		arg.BuyerEmail,
		arg.SubtotalAmount,
		arg.VatRate,
		arg.VatAmount,
		arg.TotalAmount,
		arg.Currency,
		arg.BookingID,
		arg.PaymentTransactionID,
		arg.CompanyID,
		arg.ClientUserID,
		arg.Status,
		arg.DueDate,
		arg.Notes,
	)
	var i Invoice
	err := row.Scan(
		&i.ID,
		&i.InvoiceType,
		&i.InvoiceNumber,
		&i.FactureazaID,
		&i.FactureazaDownloadUrl,
		&i.SellerCompanyName,
		&i.SellerCui,
		&i.SellerRegNumber,
		&i.SellerAddress,
		&i.SellerCity,
		&i.SellerCounty,
		&i.SellerIsVatPayer,
		&i.SellerBankName,
		&i.SellerIban,
		&i.BuyerName,
		&i.BuyerCui,
		&i.BuyerRegNumber,
		&i.BuyerAddress,
		&i.BuyerCity,
		&i.BuyerCounty,
		&i.BuyerIsVatPayer,
		&i.BuyerEmail,
		&i.SubtotalAmount,
		&i.VatRate,
		&i.VatAmount,
		&i.TotalAmount,
		&i.Currency,
		&i.BookingID,
		&i.PaymentTransactionID,
		&i.CompanyID,
		&i.ClientUserID,
		&i.EfacturaStatus,
		&i.EfacturaIndex,
		&i.Status,
		&i.IssuedAt,
		&i.DueDate,
		&i.Notes,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createInvoiceLineItem = `-- name: CreateInvoiceLineItem :one

INSERT INTO invoice_line_items (
  invoice_id, description_ro, description_en, quantity, unit_price,
  vat_rate, vat_amount, line_total, line_total_with_vat, sort_order
) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10)
RETURNING id, invoice_id, description_ro, description_en, quantity, unit_price, vat_rate, vat_amount, line_total, line_total_with_vat, sort_order
`

type CreateInvoiceLineItemParams struct {
	InvoiceID        pgtype.UUID    `json:"invoice_id"`
	DescriptionRo    string         `json:"description_ro"`
	DescriptionEn    pgtype.Text    `json:"description_en"`
	Quantity         pgtype.Numeric `json:"quantity"`
	UnitPrice        int32          `json:"unit_price"`
	VatRate          pgtype.Numeric `json:"vat_rate"`
	VatAmount        int32          `json:"vat_amount"`
	LineTotal        int32          `json:"line_total"`
	LineTotalWithVat int32          `json:"line_total_with_vat"`
	SortOrder        pgtype.Int4    `json:"sort_order"`
}

// ============================================
// INVOICE LINE ITEMS
// ============================================
func (q *Queries) CreateInvoiceLineItem(ctx context.Context, arg CreateInvoiceLineItemParams) (InvoiceLineItem, error) {
	row := q.db.QueryRow(ctx, createInvoiceLineItem,
		arg.InvoiceID,
		arg.DescriptionRo,
		arg.DescriptionEn,
		arg.Quantity,
		arg.UnitPrice,
		arg.VatRate,
		arg.VatAmount,
		arg.LineTotal,
		arg.LineTotalWithVat,
		arg.SortOrder,
	)
	var i InvoiceLineItem
	err := row.Scan(
		&i.ID,
		&i.InvoiceID,
		&i.DescriptionRo,
		&i.DescriptionEn,
		&i.Quantity,
		&i.UnitPrice,
		&i.VatRate,
		&i.VatAmount,
		&i.LineTotal,
		&i.LineTotalWithVat,
		&i.SortOrder,
	)
	return i, err
}

const createInvoiceSequence = `-- name: CreateInvoiceSequence :exec
INSERT INTO invoice_sequences (company_id, prefix, year, current_number)
VALUES ($1, $2, $3, 0)
ON CONFLICT (company_id, prefix, year) DO NOTHING
`

type CreateInvoiceSequenceParams struct {
	CompanyID pgtype.UUID `json:"company_id"`
	Prefix    string      `json:"prefix"`
	Year      int32       `json:"year"`
}

func (q *Queries) CreateInvoiceSequence(ctx context.Context, arg CreateInvoiceSequenceParams) error {
	_, err := q.db.Exec(ctx, createInvoiceSequence, arg.CompanyID, arg.Prefix, arg.Year)
	return err
}

const deleteBillingProfile = `-- name: DeleteBillingProfile :exec
DELETE FROM client_billing_profiles WHERE id = $1
`

func (q *Queries) DeleteBillingProfile(ctx context.Context, id pgtype.UUID) error {
	_, err := q.db.Exec(ctx, deleteBillingProfile, id)
	return err
}

const getBillingProfileByUser = `-- name: GetBillingProfileByUser :one

SELECT id, user_id, is_company, company_name, cui, reg_number, address, city, county, is_vat_payer, bank_name, iban, is_default, created_at, updated_at FROM client_billing_profiles WHERE user_id = $1 AND is_default = TRUE LIMIT 1
`

// ============================================
// CLIENT BILLING PROFILES
// ============================================
func (q *Queries) GetBillingProfileByUser(ctx context.Context, userID pgtype.UUID) (ClientBillingProfile, error) {
	row := q.db.QueryRow(ctx, getBillingProfileByUser, userID)
	var i ClientBillingProfile
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.IsCompany,
		&i.CompanyName,
		&i.Cui,
		&i.RegNumber,
		&i.Address,
		&i.City,
		&i.County,
		&i.IsVatPayer,
		&i.BankName,
		&i.Iban,
		&i.IsDefault,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getInvoiceAnalytics = `-- name: GetInvoiceAnalytics :one

SELECT
  COUNT(*)::BIGINT as total_issued,
  COALESCE(SUM(total_amount), 0)::BIGINT as total_amount,
  COALESCE(SUM(vat_amount), 0)::BIGINT as total_vat
FROM invoices
WHERE created_at >= $1 AND created_at <= $2
`

type GetInvoiceAnalyticsParams struct {
	CreatedAt   pgtype.Timestamptz `json:"created_at"`
	CreatedAt_2 pgtype.Timestamptz `json:"created_at_2"`
}

type GetInvoiceAnalyticsRow struct {
	TotalIssued int64 `json:"total_issued"`
	TotalAmount int64 `json:"total_amount"`
	TotalVat    int64 `json:"total_vat"`
}

// ============================================
// INVOICE ANALYTICS (Admin reporting)
// ============================================
func (q *Queries) GetInvoiceAnalytics(ctx context.Context, arg GetInvoiceAnalyticsParams) (GetInvoiceAnalyticsRow, error) {
	row := q.db.QueryRow(ctx, getInvoiceAnalytics, arg.CreatedAt, arg.CreatedAt_2)
	var i GetInvoiceAnalyticsRow
	err := row.Scan(&i.TotalIssued, &i.TotalAmount, &i.TotalVat)
	return i, err
}

const getInvoiceByBookingAndType = `-- name: GetInvoiceByBookingAndType :one
SELECT id, invoice_type, invoice_number, factureaza_id, factureaza_download_url, seller_company_name, seller_cui, seller_reg_number, seller_address, seller_city, seller_county, seller_is_vat_payer, seller_bank_name, seller_iban, buyer_name, buyer_cui, buyer_reg_number, buyer_address, buyer_city, buyer_county, buyer_is_vat_payer, buyer_email, subtotal_amount, vat_rate, vat_amount, total_amount, currency, booking_id, payment_transaction_id, company_id, client_user_id, efactura_status, efactura_index, status, issued_at, due_date, notes, created_at, updated_at FROM invoices WHERE booking_id = $1 AND invoice_type = $2 ORDER BY created_at DESC LIMIT 1
`

type GetInvoiceByBookingAndTypeParams struct {
	BookingID   pgtype.UUID `json:"booking_id"`
	InvoiceType InvoiceType `json:"invoice_type"`
}

func (q *Queries) GetInvoiceByBookingAndType(ctx context.Context, arg GetInvoiceByBookingAndTypeParams) (Invoice, error) {
	row := q.db.QueryRow(ctx, getInvoiceByBookingAndType, arg.BookingID, arg.InvoiceType)
	var i Invoice
	err := row.Scan(
		&i.ID,
		&i.InvoiceType,
		&i.InvoiceNumber,
		&i.FactureazaID,
		&i.FactureazaDownloadUrl,
		&i.SellerCompanyName,
		&i.SellerCui,
		&i.SellerRegNumber,
		&i.SellerAddress,
		&i.SellerCity,
		&i.SellerCounty,
		&i.SellerIsVatPayer,
		&i.SellerBankName,
		&i.SellerIban,
		&i.BuyerName,
		&i.BuyerCui,
		&i.BuyerRegNumber,
		&i.BuyerAddress,
		&i.BuyerCity,
		&i.BuyerCounty,
		&i.BuyerIsVatPayer,
		&i.BuyerEmail,
		&i.SubtotalAmount,
		&i.VatRate,
		&i.VatAmount,
		&i.TotalAmount,
		&i.Currency,
		&i.BookingID,
		&i.PaymentTransactionID,
		&i.CompanyID,
		&i.ClientUserID,
		&i.EfacturaStatus,
		&i.EfacturaIndex,
		&i.Status,
		&i.IssuedAt,
		&i.DueDate,
		&i.Notes,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getInvoiceByID = `-- name: GetInvoiceByID :one
SELECT id, invoice_type, invoice_number, factureaza_id, factureaza_download_url, seller_company_name, seller_cui, seller_reg_number, seller_address, seller_city, seller_county, seller_is_vat_payer, seller_bank_name, seller_iban, buyer_name, buyer_cui, buyer_reg_number, buyer_address, buyer_city, buyer_county, buyer_is_vat_payer, buyer_email, subtotal_amount, vat_rate, vat_amount, total_amount, currency, booking_id, payment_transaction_id, company_id, client_user_id, efactura_status, efactura_index, status, issued_at, due_date, notes, created_at, updated_at FROM invoices WHERE id = $1
`

func (q *Queries) GetInvoiceByID(ctx context.Context, id pgtype.UUID) (Invoice, error) {
	row := q.db.QueryRow(ctx, getInvoiceByID, id)
	var i Invoice
	err := row.Scan(
		&i.ID,
		&i.InvoiceType,
		&i.InvoiceNumber,
		&i.FactureazaID,
		&i.FactureazaDownloadUrl,
		&i.SellerCompanyName,
		&i.SellerCui,
		&i.SellerRegNumber,
		&i.SellerAddress,
		&i.SellerCity,
		&i.SellerCounty,
		&i.SellerIsVatPayer,
		&i.SellerBankName,
		&i.SellerIban,
		&i.BuyerName,
		&i.BuyerCui,
		&i.BuyerRegNumber,
		&i.BuyerAddress,
		&i.BuyerCity,
		&i.BuyerCounty,
		&i.BuyerIsVatPayer,
		&i.BuyerEmail,
		&i.SubtotalAmount,
		&i.VatRate,
		&i.VatAmount,
		&i.TotalAmount,
		&i.Currency,
		&i.BookingID,
		&i.PaymentTransactionID,
		&i.CompanyID,
		&i.ClientUserID,
		&i.EfacturaStatus,
		&i.EfacturaIndex,
		&i.Status,
		&i.IssuedAt,
		&i.DueDate,
		&i.Notes,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getInvoiceCountByStatus = `-- name: GetInvoiceCountByStatus :many
SELECT status, COUNT(*)::BIGINT as count, COALESCE(SUM(total_amount), 0)::BIGINT as total_amount
FROM invoices
WHERE created_at >= $1 AND created_at <= $2
GROUP BY status
`

type GetInvoiceCountByStatusParams struct {
	CreatedAt   pgtype.Timestamptz `json:"created_at"`
	CreatedAt_2 pgtype.Timestamptz `json:"created_at_2"`
}

type GetInvoiceCountByStatusRow struct {
	Status      InvoiceStatus `json:"status"`
	Count       int64         `json:"count"`
	TotalAmount int64         `json:"total_amount"`
}

func (q *Queries) GetInvoiceCountByStatus(ctx context.Context, arg GetInvoiceCountByStatusParams) ([]GetInvoiceCountByStatusRow, error) {
	rows, err := q.db.Query(ctx, getInvoiceCountByStatus, arg.CreatedAt, arg.CreatedAt_2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetInvoiceCountByStatusRow
	for rows.Next() {
		var i GetInvoiceCountByStatusRow
		if err := rows.Scan(&i.Status, &i.Count, &i.TotalAmount); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getInvoiceCountByType = `-- name: GetInvoiceCountByType :many
SELECT invoice_type, COUNT(*)::BIGINT as count, COALESCE(SUM(total_amount), 0)::BIGINT as total_amount
FROM invoices
WHERE created_at >= $1 AND created_at <= $2
GROUP BY invoice_type
`

type GetInvoiceCountByTypeParams struct {
	CreatedAt   pgtype.Timestamptz `json:"created_at"`
	CreatedAt_2 pgtype.Timestamptz `json:"created_at_2"`
}

type GetInvoiceCountByTypeRow struct {
	InvoiceType InvoiceType `json:"invoice_type"`
	Count       int64       `json:"count"`
	TotalAmount int64       `json:"total_amount"`
}

func (q *Queries) GetInvoiceCountByType(ctx context.Context, arg GetInvoiceCountByTypeParams) ([]GetInvoiceCountByTypeRow, error) {
	rows, err := q.db.Query(ctx, getInvoiceCountByType, arg.CreatedAt, arg.CreatedAt_2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetInvoiceCountByTypeRow
	for rows.Next() {
		var i GetInvoiceCountByTypeRow
		if err := rows.Scan(&i.InvoiceType, &i.Count, &i.TotalAmount); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getNextInvoiceNumber = `-- name: GetNextInvoiceNumber :one

UPDATE invoice_sequences SET current_number = current_number + 1
WHERE company_id IS NOT DISTINCT FROM $1 AND prefix = $2 AND year = $3
RETURNING current_number
`

type GetNextInvoiceNumberParams struct {
	CompanyID pgtype.UUID `json:"company_id"`
	Prefix    string      `json:"prefix"`
	Year      int32       `json:"year"`
}

// ============================================
// INVOICE SEQUENCES
// ============================================
func (q *Queries) GetNextInvoiceNumber(ctx context.Context, arg GetNextInvoiceNumberParams) (int32, error) {
	row := q.db.QueryRow(ctx, getNextInvoiceNumber, arg.CompanyID, arg.Prefix, arg.Year)
	var current_number int32
	err := row.Scan(&current_number)
	return current_number, err
}

const listAllInvoices = `-- name: ListAllInvoices :many

SELECT id, invoice_type, invoice_number, factureaza_id, factureaza_download_url, seller_company_name, seller_cui, seller_reg_number, seller_address, seller_city, seller_county, seller_is_vat_payer, seller_bank_name, seller_iban, buyer_name, buyer_cui, buyer_reg_number, buyer_address, buyer_city, buyer_county, buyer_is_vat_payer, buyer_email, subtotal_amount, vat_rate, vat_amount, total_amount, currency, booking_id, payment_transaction_id, company_id, client_user_id, efactura_status, efactura_index, status, issued_at, due_date, notes, created_at, updated_at FROM invoices ORDER BY created_at DESC LIMIT $1 OFFSET $2
`

type ListAllInvoicesParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

// ============================================
// INVOICE LISTING (Admin)
// ============================================
func (q *Queries) ListAllInvoices(ctx context.Context, arg ListAllInvoicesParams) ([]Invoice, error) {
	rows, err := q.db.Query(ctx, listAllInvoices, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Invoice
	for rows.Next() {
		var i Invoice
		if err := rows.Scan(
			&i.ID,
			&i.InvoiceType,
			&i.InvoiceNumber,
			&i.FactureazaID,
			&i.FactureazaDownloadUrl,
			&i.SellerCompanyName,
			&i.SellerCui,
			&i.SellerRegNumber,
			&i.SellerAddress,
			&i.SellerCity,
			&i.SellerCounty,
			&i.SellerIsVatPayer,
			&i.SellerBankName,
			&i.SellerIban,
			&i.BuyerName,
			&i.BuyerCui,
			&i.BuyerRegNumber,
			&i.BuyerAddress,
			&i.BuyerCity,
			&i.BuyerCounty,
			&i.BuyerIsVatPayer,
			&i.BuyerEmail,
			&i.SubtotalAmount,
			&i.VatRate,
			&i.VatAmount,
			&i.TotalAmount,
			&i.Currency,
			&i.BookingID,
			&i.PaymentTransactionID,
			&i.CompanyID,
			&i.ClientUserID,
			&i.EfacturaStatus,
			&i.EfacturaIndex,
			&i.Status,
			&i.IssuedAt,
			&i.DueDate,
			&i.Notes,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listInvoiceLineItems = `-- name: ListInvoiceLineItems :many
SELECT id, invoice_id, description_ro, description_en, quantity, unit_price, vat_rate, vat_amount, line_total, line_total_with_vat, sort_order FROM invoice_line_items WHERE invoice_id = $1 ORDER BY sort_order
`

func (q *Queries) ListInvoiceLineItems(ctx context.Context, invoiceID pgtype.UUID) ([]InvoiceLineItem, error) {
	rows, err := q.db.Query(ctx, listInvoiceLineItems, invoiceID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []InvoiceLineItem
	for rows.Next() {
		var i InvoiceLineItem
		if err := rows.Scan(
			&i.ID,
			&i.InvoiceID,
			&i.DescriptionRo,
			&i.DescriptionEn,
			&i.Quantity,
			&i.UnitPrice,
			&i.VatRate,
			&i.VatAmount,
			&i.LineTotal,
			&i.LineTotalWithVat,
			&i.SortOrder,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listInvoicesByClient = `-- name: ListInvoicesByClient :many

SELECT id, invoice_type, invoice_number, factureaza_id, factureaza_download_url, seller_company_name, seller_cui, seller_reg_number, seller_address, seller_city, seller_county, seller_is_vat_payer, seller_bank_name, seller_iban, buyer_name, buyer_cui, buyer_reg_number, buyer_address, buyer_city, buyer_county, buyer_is_vat_payer, buyer_email, subtotal_amount, vat_rate, vat_amount, total_amount, currency, booking_id, payment_transaction_id, company_id, client_user_id, efactura_status, efactura_index, status, issued_at, due_date, notes, created_at, updated_at FROM invoices WHERE client_user_id = $1 ORDER BY created_at DESC LIMIT $2 OFFSET $3
`

type ListInvoicesByClientParams struct {
	ClientUserID pgtype.UUID `json:"client_user_id"`
	Limit        int32       `json:"limit"`
	Offset       int32       `json:"offset"`
}

// ============================================
// INVOICE LISTING (Client)
// ============================================
func (q *Queries) ListInvoicesByClient(ctx context.Context, arg ListInvoicesByClientParams) ([]Invoice, error) {
	rows, err := q.db.Query(ctx, listInvoicesByClient, arg.ClientUserID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Invoice
	for rows.Next() {
		var i Invoice
		if err := rows.Scan(
			&i.ID,
			&i.InvoiceType,
			&i.InvoiceNumber,
			&i.FactureazaID,
			&i.FactureazaDownloadUrl,
			&i.SellerCompanyName,
			&i.SellerCui,
			&i.SellerRegNumber,
			&i.SellerAddress,
			&i.SellerCity,
			&i.SellerCounty,
			&i.SellerIsVatPayer,
			&i.SellerBankName,
			&i.SellerIban,
			&i.BuyerName,
			&i.BuyerCui,
			&i.BuyerRegNumber,
			&i.BuyerAddress,
			&i.BuyerCity,
			&i.BuyerCounty,
			&i.BuyerIsVatPayer,
			&i.BuyerEmail,
			&i.SubtotalAmount,
			&i.VatRate,
			&i.VatAmount,
			&i.TotalAmount,
			&i.Currency,
			&i.BookingID,
			&i.PaymentTransactionID,
			&i.CompanyID,
			&i.ClientUserID,
			&i.EfacturaStatus,
			&i.EfacturaIndex,
			&i.Status,
			&i.IssuedAt,
			&i.DueDate,
			&i.Notes,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listInvoicesByCompany = `-- name: ListInvoicesByCompany :many

SELECT id, invoice_type, invoice_number, factureaza_id, factureaza_download_url, seller_company_name, seller_cui, seller_reg_number, seller_address, seller_city, seller_county, seller_is_vat_payer, seller_bank_name, seller_iban, buyer_name, buyer_cui, buyer_reg_number, buyer_address, buyer_city, buyer_county, buyer_is_vat_payer, buyer_email, subtotal_amount, vat_rate, vat_amount, total_amount, currency, booking_id, payment_transaction_id, company_id, client_user_id, efactura_status, efactura_index, status, issued_at, due_date, notes, created_at, updated_at FROM invoices WHERE company_id = $1 ORDER BY created_at DESC LIMIT $2 OFFSET $3
`

type ListInvoicesByCompanyParams struct {
	CompanyID pgtype.UUID `json:"company_id"`
	Limit     int32       `json:"limit"`
	Offset    int32       `json:"offset"`
}

// ============================================
// INVOICE LISTING (Company)
// ============================================
func (q *Queries) ListInvoicesByCompany(ctx context.Context, arg ListInvoicesByCompanyParams) ([]Invoice, error) {
	rows, err := q.db.Query(ctx, listInvoicesByCompany, arg.CompanyID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Invoice
	for rows.Next() {
		var i Invoice
		if err := rows.Scan(
			&i.ID,
			&i.InvoiceType,
			&i.InvoiceNumber,
			&i.FactureazaID,
			&i.FactureazaDownloadUrl,
			&i.SellerCompanyName,
			&i.SellerCui,
			&i.SellerRegNumber,
			&i.SellerAddress,
			&i.SellerCity,
			&i.SellerCounty,
			&i.SellerIsVatPayer,
			&i.SellerBankName,
			&i.SellerIban,
			&i.BuyerName,
			&i.BuyerCui,
			&i.BuyerRegNumber,
			&i.BuyerAddress,
			&i.BuyerCity,
			&i.BuyerCounty,
			&i.BuyerIsVatPayer,
			&i.BuyerEmail,
			&i.SubtotalAmount,
			&i.VatRate,
			&i.VatAmount,
			&i.TotalAmount,
			&i.Currency,
			&i.BookingID,
			&i.PaymentTransactionID,
			&i.CompanyID,
			&i.ClientUserID,
			&i.EfacturaStatus,
			&i.EfacturaIndex,
			&i.Status,
			&i.IssuedAt,
			&i.DueDate,
			&i.Notes,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listInvoicesByCompanyAndStatus = `-- name: ListInvoicesByCompanyAndStatus :many
SELECT id, invoice_type, invoice_number, factureaza_id, factureaza_download_url, seller_company_name, seller_cui, seller_reg_number, seller_address, seller_city, seller_county, seller_is_vat_payer, seller_bank_name, seller_iban, buyer_name, buyer_cui, buyer_reg_number, buyer_address, buyer_city, buyer_county, buyer_is_vat_payer, buyer_email, subtotal_amount, vat_rate, vat_amount, total_amount, currency, booking_id, payment_transaction_id, company_id, client_user_id, efactura_status, efactura_index, status, issued_at, due_date, notes, created_at, updated_at FROM invoices WHERE company_id = $1 AND status = $2 ORDER BY created_at DESC LIMIT $3 OFFSET $4
`

type ListInvoicesByCompanyAndStatusParams struct {
	CompanyID pgtype.UUID   `json:"company_id"`
	Status    InvoiceStatus `json:"status"`
	Limit     int32         `json:"limit"`
	Offset    int32         `json:"offset"`
}

func (q *Queries) ListInvoicesByCompanyAndStatus(ctx context.Context, arg ListInvoicesByCompanyAndStatusParams) ([]Invoice, error) {
	rows, err := q.db.Query(ctx, listInvoicesByCompanyAndStatus,
		arg.CompanyID,
		arg.Status,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Invoice
	for rows.Next() {
		var i Invoice
		if err := rows.Scan(
			&i.ID,
			&i.InvoiceType,
			&i.InvoiceNumber,
			&i.FactureazaID,
			&i.FactureazaDownloadUrl,
			&i.SellerCompanyName,
			&i.SellerCui,
			&i.SellerRegNumber,
			&i.SellerAddress,
			&i.SellerCity,
			&i.SellerCounty,
			&i.SellerIsVatPayer,
			&i.SellerBankName,
			&i.SellerIban,
			&i.BuyerName,
			&i.BuyerCui,
			&i.BuyerRegNumber,
			&i.BuyerAddress,
			&i.BuyerCity,
			&i.BuyerCounty,
			&i.BuyerIsVatPayer,
			&i.BuyerEmail,
			&i.SubtotalAmount,
			&i.VatRate,
			&i.VatAmount,
			&i.TotalAmount,
			&i.Currency,
			&i.BookingID,
			&i.PaymentTransactionID,
			&i.CompanyID,
			&i.ClientUserID,
			&i.EfacturaStatus,
			&i.EfacturaIndex,
			&i.Status,
			&i.IssuedAt,
			&i.DueDate,
			&i.Notes,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listInvoicesByCompanyID = `-- name: ListInvoicesByCompanyID :many
SELECT id, invoice_type, invoice_number, factureaza_id, factureaza_download_url, seller_company_name, seller_cui, seller_reg_number, seller_address, seller_city, seller_county, seller_is_vat_payer, seller_bank_name, seller_iban, buyer_name, buyer_cui, buyer_reg_number, buyer_address, buyer_city, buyer_county, buyer_is_vat_payer, buyer_email, subtotal_amount, vat_rate, vat_amount, total_amount, currency, booking_id, payment_transaction_id, company_id, client_user_id, efactura_status, efactura_index, status, issued_at, due_date, notes, created_at, updated_at FROM invoices WHERE company_id = $1 ORDER BY created_at DESC LIMIT $2 OFFSET $3
`

type ListInvoicesByCompanyIDParams struct {
	CompanyID pgtype.UUID `json:"company_id"`
	Limit     int32       `json:"limit"`
	Offset    int32       `json:"offset"`
}

func (q *Queries) ListInvoicesByCompanyID(ctx context.Context, arg ListInvoicesByCompanyIDParams) ([]Invoice, error) {
	rows, err := q.db.Query(ctx, listInvoicesByCompanyID, arg.CompanyID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Invoice
	for rows.Next() {
		var i Invoice
		if err := rows.Scan(
			&i.ID,
			&i.InvoiceType,
			&i.InvoiceNumber,
			&i.FactureazaID,
			&i.FactureazaDownloadUrl,
			&i.SellerCompanyName,
			&i.SellerCui,
			&i.SellerRegNumber,
			&i.SellerAddress,
			&i.SellerCity,
			&i.SellerCounty,
			&i.SellerIsVatPayer,
			&i.SellerBankName,
			&i.SellerIban,
			&i.BuyerName,
			&i.BuyerCui,
			&i.BuyerRegNumber,
			&i.BuyerAddress,
			&i.BuyerCity,
			&i.BuyerCounty,
			&i.BuyerIsVatPayer,
			&i.BuyerEmail,
			&i.SubtotalAmount,
			&i.VatRate,
			&i.VatAmount,
			&i.TotalAmount,
			&i.Currency,
			&i.BookingID,
			&i.PaymentTransactionID,
			&i.CompanyID,
			&i.ClientUserID,
			&i.EfacturaStatus,
			&i.EfacturaIndex,
			&i.Status,
			&i.IssuedAt,
			&i.DueDate,
			&i.Notes,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listInvoicesByType = `-- name: ListInvoicesByType :many
SELECT id, invoice_type, invoice_number, factureaza_id, factureaza_download_url, seller_company_name, seller_cui, seller_reg_number, seller_address, seller_city, seller_county, seller_is_vat_payer, seller_bank_name, seller_iban, buyer_name, buyer_cui, buyer_reg_number, buyer_address, buyer_city, buyer_county, buyer_is_vat_payer, buyer_email, subtotal_amount, vat_rate, vat_amount, total_amount, currency, booking_id, payment_transaction_id, company_id, client_user_id, efactura_status, efactura_index, status, issued_at, due_date, notes, created_at, updated_at FROM invoices WHERE invoice_type = $1 ORDER BY created_at DESC LIMIT $2 OFFSET $3
`

type ListInvoicesByTypeParams struct {
	InvoiceType InvoiceType `json:"invoice_type"`
	Limit       int32       `json:"limit"`
	Offset      int32       `json:"offset"`
}

func (q *Queries) ListInvoicesByType(ctx context.Context, arg ListInvoicesByTypeParams) ([]Invoice, error) {
	rows, err := q.db.Query(ctx, listInvoicesByType, arg.InvoiceType, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Invoice
	for rows.Next() {
		var i Invoice
		if err := rows.Scan(
			&i.ID,
			&i.InvoiceType,
			&i.InvoiceNumber,
			&i.FactureazaID,
			&i.FactureazaDownloadUrl,
			&i.SellerCompanyName,
			&i.SellerCui,
			&i.SellerRegNumber,
			&i.SellerAddress,
			&i.SellerCity,
			&i.SellerCounty,
			&i.SellerIsVatPayer,
			&i.SellerBankName,
			&i.SellerIban,
			&i.BuyerName,
			&i.BuyerCui,
			&i.BuyerRegNumber,
			&i.BuyerAddress,
			&i.BuyerCity,
			&i.BuyerCounty,
			&i.BuyerIsVatPayer,
			&i.BuyerEmail,
			&i.SubtotalAmount,
			&i.VatRate,
			&i.VatAmount,
			&i.TotalAmount,
			&i.Currency,
			&i.BookingID,
			&i.PaymentTransactionID,
			&i.CompanyID,
			&i.ClientUserID,
			&i.EfacturaStatus,
			&i.EfacturaIndex,
			&i.Status,
			&i.IssuedAt,
			&i.DueDate,
			&i.Notes,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listInvoicesByTypeAndStatus = `-- name: ListInvoicesByTypeAndStatus :many
SELECT id, invoice_type, invoice_number, factureaza_id, factureaza_download_url, seller_company_name, seller_cui, seller_reg_number, seller_address, seller_city, seller_county, seller_is_vat_payer, seller_bank_name, seller_iban, buyer_name, buyer_cui, buyer_reg_number, buyer_address, buyer_city, buyer_county, buyer_is_vat_payer, buyer_email, subtotal_amount, vat_rate, vat_amount, total_amount, currency, booking_id, payment_transaction_id, company_id, client_user_id, efactura_status, efactura_index, status, issued_at, due_date, notes, created_at, updated_at FROM invoices WHERE invoice_type = $1 AND status = $2 ORDER BY created_at DESC LIMIT $3 OFFSET $4
`

type ListInvoicesByTypeAndStatusParams struct {
	InvoiceType InvoiceType   `json:"invoice_type"`
	Status      InvoiceStatus `json:"status"`
	Limit       int32         `json:"limit"`
	Offset      int32         `json:"offset"`
}

func (q *Queries) ListInvoicesByTypeAndStatus(ctx context.Context, arg ListInvoicesByTypeAndStatusParams) ([]Invoice, error) {
	rows, err := q.db.Query(ctx, listInvoicesByTypeAndStatus,
		arg.InvoiceType,
		arg.Status,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Invoice
	for rows.Next() {
		var i Invoice
		if err := rows.Scan(
			&i.ID,
			&i.InvoiceType,
			&i.InvoiceNumber,
			&i.FactureazaID,
			&i.FactureazaDownloadUrl,
			&i.SellerCompanyName,
			&i.SellerCui,
			&i.SellerRegNumber,
			&i.SellerAddress,
			&i.SellerCity,
			&i.SellerCounty,
			&i.SellerIsVatPayer,
			&i.SellerBankName,
			&i.SellerIban,
			&i.BuyerName,
			&i.BuyerCui,
			&i.BuyerRegNumber,
			&i.BuyerAddress,
			&i.BuyerCity,
			&i.BuyerCounty,
			&i.BuyerIsVatPayer,
			&i.BuyerEmail,
			&i.SubtotalAmount,
			&i.VatRate,
			&i.VatAmount,
			&i.TotalAmount,
			&i.Currency,
			&i.BookingID,
			&i.PaymentTransactionID,
			&i.CompanyID,
			&i.ClientUserID,
			&i.EfacturaStatus,
			&i.EfacturaIndex,
			&i.Status,
			&i.IssuedAt,
			&i.DueDate,
			&i.Notes,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateBillingProfile = `-- name: UpdateBillingProfile :one
UPDATE client_billing_profiles SET
  is_company = $2, company_name = $3, cui = $4, reg_number = $5,
  address = $6, city = $7, county = $8, is_vat_payer = $9,
  bank_name = $10, iban = $11, updated_at = NOW()
WHERE id = $1
RETURNING id, user_id, is_company, company_name, cui, reg_number, address, city, county, is_vat_payer, bank_name, iban, is_default, created_at, updated_at
`

type UpdateBillingProfileParams struct {
	ID          pgtype.UUID `json:"id"`
	IsCompany   bool        `json:"is_company"`
	CompanyName pgtype.Text `json:"company_name"`
	Cui         pgtype.Text `json:"cui"`
	RegNumber   pgtype.Text `json:"reg_number"`
	Address     pgtype.Text `json:"address"`
	City        pgtype.Text `json:"city"`
	County      pgtype.Text `json:"county"`
	IsVatPayer  pgtype.Bool `json:"is_vat_payer"`
	BankName    pgtype.Text `json:"bank_name"`
	Iban        pgtype.Text `json:"iban"`
}

func (q *Queries) UpdateBillingProfile(ctx context.Context, arg UpdateBillingProfileParams) (ClientBillingProfile, error) {
	row := q.db.QueryRow(ctx, updateBillingProfile,
		arg.ID,
		arg.IsCompany,
		arg.CompanyName,
		arg.Cui,
		arg.RegNumber,
		arg.Address,
		arg.City,
		arg.County,
		arg.IsVatPayer,
		arg.BankName,
		arg.Iban,
	)
	var i ClientBillingProfile
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.IsCompany,
		&i.CompanyName,
		&i.Cui,
		&i.RegNumber,
		&i.Address,
		&i.City,
		&i.County,
		&i.IsVatPayer,
		&i.BankName,
		&i.Iban,
		&i.IsDefault,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateInvoiceEFactura = `-- name: UpdateInvoiceEFactura :exec
UPDATE invoices SET efactura_status = $2, efactura_index = $3, updated_at = NOW()
WHERE id = $1
`

type UpdateInvoiceEFacturaParams struct {
	ID             pgtype.UUID `json:"id"`
	EfacturaStatus pgtype.Text `json:"efactura_status"`
	EfacturaIndex  pgtype.Text `json:"efactura_index"`
}

func (q *Queries) UpdateInvoiceEFactura(ctx context.Context, arg UpdateInvoiceEFacturaParams) error {
	_, err := q.db.Exec(ctx, updateInvoiceEFactura, arg.ID, arg.EfacturaStatus, arg.EfacturaIndex)
	return err
}

const updateInvoiceFactureaza = `-- name: UpdateInvoiceFactureaza :exec
UPDATE invoices SET factureaza_id = $2, factureaza_download_url = $3, updated_at = NOW()
WHERE id = $1
`

type UpdateInvoiceFactureazaParams struct {
	ID                    pgtype.UUID `json:"id"`
	FactureazaID          pgtype.Text `json:"factureaza_id"`
	FactureazaDownloadUrl pgtype.Text `json:"factureaza_download_url"`
}

func (q *Queries) UpdateInvoiceFactureaza(ctx context.Context, arg UpdateInvoiceFactureazaParams) error {
	_, err := q.db.Exec(ctx, updateInvoiceFactureaza, arg.ID, arg.FactureazaID, arg.FactureazaDownloadUrl)
	return err
}

const updateInvoiceStatus = `-- name: UpdateInvoiceStatus :one
UPDATE invoices SET status = $2, issued_at = CASE WHEN $2 = 'issued' THEN NOW() ELSE issued_at END, updated_at = NOW()
WHERE id = $1 RETURNING id, invoice_type, invoice_number, factureaza_id, factureaza_download_url, seller_company_name, seller_cui, seller_reg_number, seller_address, seller_city, seller_county, seller_is_vat_payer, seller_bank_name, seller_iban, buyer_name, buyer_cui, buyer_reg_number, buyer_address, buyer_city, buyer_county, buyer_is_vat_payer, buyer_email, subtotal_amount, vat_rate, vat_amount, total_amount, currency, booking_id, payment_transaction_id, company_id, client_user_id, efactura_status, efactura_index, status, issued_at, due_date, notes, created_at, updated_at
`

type UpdateInvoiceStatusParams struct {
	ID     pgtype.UUID   `json:"id"`
	Status InvoiceStatus `json:"status"`
}

func (q *Queries) UpdateInvoiceStatus(ctx context.Context, arg UpdateInvoiceStatusParams) (Invoice, error) {
	row := q.db.QueryRow(ctx, updateInvoiceStatus, arg.ID, arg.Status)
	var i Invoice
	err := row.Scan(
		&i.ID,
		&i.InvoiceType,
		&i.InvoiceNumber,
		&i.FactureazaID,
		&i.FactureazaDownloadUrl,
		&i.SellerCompanyName,
		&i.SellerCui,
		&i.SellerRegNumber,
		&i.SellerAddress,
		&i.SellerCity,
		&i.SellerCounty,
		&i.SellerIsVatPayer,
		&i.SellerBankName,
		&i.SellerIban,
		&i.BuyerName,
		&i.BuyerCui,
		&i.BuyerRegNumber,
		&i.BuyerAddress,
		&i.BuyerCity,
		&i.BuyerCounty,
		&i.BuyerIsVatPayer,
		&i.BuyerEmail,
		&i.SubtotalAmount,
		&i.VatRate,
		&i.VatAmount,
		&i.TotalAmount,
		&i.Currency,
		&i.BookingID,
		&i.PaymentTransactionID,
		&i.CompanyID,
		&i.ClientUserID,
		&i.EfacturaStatus,
		&i.EfacturaIndex,
		&i.Status,
		&i.IssuedAt,
		&i.DueDate,
		&i.Notes,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
