// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: users.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const adminUpdateUserProfile = `-- name: AdminUpdateUserProfile :one
UPDATE users SET full_name = $2, phone = $3, updated_at = NOW() WHERE id = $1 RETURNING id, email, full_name, phone, avatar_url, role, status, google_id, fcm_token, preferred_language, created_at, updated_at, stripe_customer_id
`

type AdminUpdateUserProfileParams struct {
	ID       pgtype.UUID `json:"id"`
	FullName string      `json:"full_name"`
	Phone    pgtype.Text `json:"phone"`
}

func (q *Queries) AdminUpdateUserProfile(ctx context.Context, arg AdminUpdateUserProfileParams) (User, error) {
	row := q.db.QueryRow(ctx, adminUpdateUserProfile, arg.ID, arg.FullName, arg.Phone)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.FullName,
		&i.Phone,
		&i.AvatarUrl,
		&i.Role,
		&i.Status,
		&i.GoogleID,
		&i.FcmToken,
		&i.PreferredLanguage,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.StripeCustomerID,
	)
	return i, err
}

const countSearchUsers = `-- name: CountSearchUsers :one
SELECT COUNT(*) FROM users WHERE
    (full_name ILIKE '%' || $1::text || '%' OR email ILIKE '%' || $1::text || '%' OR COALESCE(phone, '') ILIKE '%' || $1::text || '%')
    AND ($2::text = '' OR role::text = $2::text)
    AND ($3::text = '' OR status::text = $3::text)
`

type CountSearchUsersParams struct {
	Query        string `json:"query"`
	RoleFilter   string `json:"role_filter"`
	StatusFilter string `json:"status_filter"`
}

func (q *Queries) CountSearchUsers(ctx context.Context, arg CountSearchUsersParams) (int64, error) {
	row := q.db.QueryRow(ctx, countSearchUsers, arg.Query, arg.RoleFilter, arg.StatusFilter)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countUsersByRole = `-- name: CountUsersByRole :one
SELECT COUNT(*) FROM users WHERE role = $1
`

func (q *Queries) CountUsersByRole(ctx context.Context, role UserRole) (int64, error) {
	row := q.db.QueryRow(ctx, countUsersByRole, role)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createUser = `-- name: CreateUser :one
INSERT INTO users (email, full_name, phone, avatar_url, role, status, google_id, preferred_language)
VALUES ($1, $2, $3, $4, $5, $6, $7, $8)
RETURNING id, email, full_name, phone, avatar_url, role, status, google_id, fcm_token, preferred_language, created_at, updated_at, stripe_customer_id
`

type CreateUserParams struct {
	Email             string      `json:"email"`
	FullName          string      `json:"full_name"`
	Phone             pgtype.Text `json:"phone"`
	AvatarUrl         pgtype.Text `json:"avatar_url"`
	Role              UserRole    `json:"role"`
	Status            UserStatus  `json:"status"`
	GoogleID          pgtype.Text `json:"google_id"`
	PreferredLanguage pgtype.Text `json:"preferred_language"`
}

func (q *Queries) CreateUser(ctx context.Context, arg CreateUserParams) (User, error) {
	row := q.db.QueryRow(ctx, createUser,
		arg.Email,
		arg.FullName,
		arg.Phone,
		arg.AvatarUrl,
		arg.Role,
		arg.Status,
		arg.GoogleID,
		arg.PreferredLanguage,
	)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.FullName,
		&i.Phone,
		&i.AvatarUrl,
		&i.Role,
		&i.Status,
		&i.GoogleID,
		&i.FcmToken,
		&i.PreferredLanguage,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.StripeCustomerID,
	)
	return i, err
}

const getUserByEmail = `-- name: GetUserByEmail :one
SELECT id, email, full_name, phone, avatar_url, role, status, google_id, fcm_token, preferred_language, created_at, updated_at, stripe_customer_id FROM users WHERE email = $1
`

func (q *Queries) GetUserByEmail(ctx context.Context, email string) (User, error) {
	row := q.db.QueryRow(ctx, getUserByEmail, email)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.FullName,
		&i.Phone,
		&i.AvatarUrl,
		&i.Role,
		&i.Status,
		&i.GoogleID,
		&i.FcmToken,
		&i.PreferredLanguage,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.StripeCustomerID,
	)
	return i, err
}

const getUserByGoogleID = `-- name: GetUserByGoogleID :one
SELECT id, email, full_name, phone, avatar_url, role, status, google_id, fcm_token, preferred_language, created_at, updated_at, stripe_customer_id FROM users WHERE google_id = $1
`

func (q *Queries) GetUserByGoogleID(ctx context.Context, googleID pgtype.Text) (User, error) {
	row := q.db.QueryRow(ctx, getUserByGoogleID, googleID)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.FullName,
		&i.Phone,
		&i.AvatarUrl,
		&i.Role,
		&i.Status,
		&i.GoogleID,
		&i.FcmToken,
		&i.PreferredLanguage,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.StripeCustomerID,
	)
	return i, err
}

const getUserByID = `-- name: GetUserByID :one
SELECT id, email, full_name, phone, avatar_url, role, status, google_id, fcm_token, preferred_language, created_at, updated_at, stripe_customer_id FROM users WHERE id = $1
`

func (q *Queries) GetUserByID(ctx context.Context, id pgtype.UUID) (User, error) {
	row := q.db.QueryRow(ctx, getUserByID, id)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.FullName,
		&i.Phone,
		&i.AvatarUrl,
		&i.Role,
		&i.Status,
		&i.GoogleID,
		&i.FcmToken,
		&i.PreferredLanguage,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.StripeCustomerID,
	)
	return i, err
}

const listAllUsers = `-- name: ListAllUsers :many
SELECT id, email, full_name, phone, avatar_url, role, status, google_id, fcm_token, preferred_language, created_at, updated_at, stripe_customer_id FROM users ORDER BY full_name ASC
`

func (q *Queries) ListAllUsers(ctx context.Context) ([]User, error) {
	rows, err := q.db.Query(ctx, listAllUsers)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []User
	for rows.Next() {
		var i User
		if err := rows.Scan(
			&i.ID,
			&i.Email,
			&i.FullName,
			&i.Phone,
			&i.AvatarUrl,
			&i.Role,
			&i.Status,
			&i.GoogleID,
			&i.FcmToken,
			&i.PreferredLanguage,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.StripeCustomerID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listUsersByRole = `-- name: ListUsersByRole :many
SELECT id, email, full_name, phone, avatar_url, role, status, google_id, fcm_token, preferred_language, created_at, updated_at, stripe_customer_id FROM users WHERE role = $1 ORDER BY created_at DESC
`

func (q *Queries) ListUsersByRole(ctx context.Context, role UserRole) ([]User, error) {
	rows, err := q.db.Query(ctx, listUsersByRole, role)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []User
	for rows.Next() {
		var i User
		if err := rows.Scan(
			&i.ID,
			&i.Email,
			&i.FullName,
			&i.Phone,
			&i.AvatarUrl,
			&i.Role,
			&i.Status,
			&i.GoogleID,
			&i.FcmToken,
			&i.PreferredLanguage,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.StripeCustomerID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchUsers = `-- name: SearchUsers :many
SELECT id, email, full_name, phone, avatar_url, role, status, google_id, fcm_token, preferred_language, created_at, updated_at, stripe_customer_id FROM users WHERE
    (full_name ILIKE '%' || $3::text || '%' OR email ILIKE '%' || $3::text || '%' OR COALESCE(phone, '') ILIKE '%' || $3::text || '%')
    AND ($4::text = '' OR role::text = $4::text)
    AND ($5::text = '' OR status::text = $5::text)
ORDER BY created_at DESC LIMIT $1 OFFSET $2
`

type SearchUsersParams struct {
	Limit        int32  `json:"limit"`
	Offset       int32  `json:"offset"`
	Query        string `json:"query"`
	RoleFilter   string `json:"role_filter"`
	StatusFilter string `json:"status_filter"`
}

func (q *Queries) SearchUsers(ctx context.Context, arg SearchUsersParams) ([]User, error) {
	rows, err := q.db.Query(ctx, searchUsers,
		arg.Limit,
		arg.Offset,
		arg.Query,
		arg.RoleFilter,
		arg.StatusFilter,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []User
	for rows.Next() {
		var i User
		if err := rows.Scan(
			&i.ID,
			&i.Email,
			&i.FullName,
			&i.Phone,
			&i.AvatarUrl,
			&i.Role,
			&i.Status,
			&i.GoogleID,
			&i.FcmToken,
			&i.PreferredLanguage,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.StripeCustomerID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchUsersByName = `-- name: SearchUsersByName :many
SELECT id, email, full_name, phone, avatar_url, role, status, google_id, fcm_token, preferred_language, created_at, updated_at, stripe_customer_id FROM users WHERE full_name ILIKE '%' || $1 || '%' ORDER BY full_name ASC LIMIT 20
`

func (q *Queries) SearchUsersByName(ctx context.Context, dollar_1 pgtype.Text) ([]User, error) {
	rows, err := q.db.Query(ctx, searchUsersByName, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []User
	for rows.Next() {
		var i User
		if err := rows.Scan(
			&i.ID,
			&i.Email,
			&i.FullName,
			&i.Phone,
			&i.AvatarUrl,
			&i.Role,
			&i.Status,
			&i.GoogleID,
			&i.FcmToken,
			&i.PreferredLanguage,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.StripeCustomerID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateUser = `-- name: UpdateUser :one
UPDATE users SET full_name = $2, phone = $3, avatar_url = $4, preferred_language = $5, updated_at = NOW()
WHERE id = $1 RETURNING id, email, full_name, phone, avatar_url, role, status, google_id, fcm_token, preferred_language, created_at, updated_at, stripe_customer_id
`

type UpdateUserParams struct {
	ID                pgtype.UUID `json:"id"`
	FullName          string      `json:"full_name"`
	Phone             pgtype.Text `json:"phone"`
	AvatarUrl         pgtype.Text `json:"avatar_url"`
	PreferredLanguage pgtype.Text `json:"preferred_language"`
}

func (q *Queries) UpdateUser(ctx context.Context, arg UpdateUserParams) (User, error) {
	row := q.db.QueryRow(ctx, updateUser,
		arg.ID,
		arg.FullName,
		arg.Phone,
		arg.AvatarUrl,
		arg.PreferredLanguage,
	)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.FullName,
		&i.Phone,
		&i.AvatarUrl,
		&i.Role,
		&i.Status,
		&i.GoogleID,
		&i.FcmToken,
		&i.PreferredLanguage,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.StripeCustomerID,
	)
	return i, err
}

const updateUserAvatar = `-- name: UpdateUserAvatar :one
UPDATE users SET avatar_url = $2, updated_at = NOW() WHERE id = $1 RETURNING id, email, full_name, phone, avatar_url, role, status, google_id, fcm_token, preferred_language, created_at, updated_at, stripe_customer_id
`

type UpdateUserAvatarParams struct {
	ID        pgtype.UUID `json:"id"`
	AvatarUrl pgtype.Text `json:"avatar_url"`
}

func (q *Queries) UpdateUserAvatar(ctx context.Context, arg UpdateUserAvatarParams) (User, error) {
	row := q.db.QueryRow(ctx, updateUserAvatar, arg.ID, arg.AvatarUrl)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.FullName,
		&i.Phone,
		&i.AvatarUrl,
		&i.Role,
		&i.Status,
		&i.GoogleID,
		&i.FcmToken,
		&i.PreferredLanguage,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.StripeCustomerID,
	)
	return i, err
}

const updateUserFCMToken = `-- name: UpdateUserFCMToken :exec
UPDATE users SET fcm_token = $2, updated_at = NOW() WHERE id = $1
`

type UpdateUserFCMTokenParams struct {
	ID       pgtype.UUID `json:"id"`
	FcmToken pgtype.Text `json:"fcm_token"`
}

func (q *Queries) UpdateUserFCMToken(ctx context.Context, arg UpdateUserFCMTokenParams) error {
	_, err := q.db.Exec(ctx, updateUserFCMToken, arg.ID, arg.FcmToken)
	return err
}

const updateUserRole = `-- name: UpdateUserRole :one
UPDATE users SET role = $2, updated_at = NOW() WHERE id = $1 RETURNING id, email, full_name, phone, avatar_url, role, status, google_id, fcm_token, preferred_language, created_at, updated_at, stripe_customer_id
`

type UpdateUserRoleParams struct {
	ID   pgtype.UUID `json:"id"`
	Role UserRole    `json:"role"`
}

func (q *Queries) UpdateUserRole(ctx context.Context, arg UpdateUserRoleParams) (User, error) {
	row := q.db.QueryRow(ctx, updateUserRole, arg.ID, arg.Role)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.FullName,
		&i.Phone,
		&i.AvatarUrl,
		&i.Role,
		&i.Status,
		&i.GoogleID,
		&i.FcmToken,
		&i.PreferredLanguage,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.StripeCustomerID,
	)
	return i, err
}

const updateUserStatus = `-- name: UpdateUserStatus :one
UPDATE users SET status = $2, updated_at = NOW() WHERE id = $1 RETURNING id, email, full_name, phone, avatar_url, role, status, google_id, fcm_token, preferred_language, created_at, updated_at, stripe_customer_id
`

type UpdateUserStatusParams struct {
	ID     pgtype.UUID `json:"id"`
	Status UserStatus  `json:"status"`
}

func (q *Queries) UpdateUserStatus(ctx context.Context, arg UpdateUserStatusParams) (User, error) {
	row := q.db.QueryRow(ctx, updateUserStatus, arg.ID, arg.Status)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.FullName,
		&i.Phone,
		&i.AvatarUrl,
		&i.Role,
		&i.Status,
		&i.GoogleID,
		&i.FcmToken,
		&i.PreferredLanguage,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.StripeCustomerID,
	)
	return i, err
}
