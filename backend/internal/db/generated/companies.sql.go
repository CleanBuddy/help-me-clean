// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: companies.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const adminUpdateCompanyProfile = `-- name: AdminUpdateCompanyProfile :one
UPDATE companies SET company_name = $2, cui = $3, address = $4, contact_phone = $5, contact_email = $6, updated_at = NOW()
WHERE id = $1 RETURNING id, admin_user_id, company_name, cui, company_type, legal_representative, contact_email, contact_phone, address, city, county, description, logo_url, status, rejection_reason, max_service_radius_km, rating_avg, total_jobs_completed, approved_at, created_at, updated_at, claim_token, stripe_connect_account_id, stripe_connect_onboarding_complete, stripe_connect_charges_enabled, stripe_connect_payouts_enabled
`

type AdminUpdateCompanyProfileParams struct {
	ID           pgtype.UUID `json:"id"`
	CompanyName  string      `json:"company_name"`
	Cui          string      `json:"cui"`
	Address      string      `json:"address"`
	ContactPhone string      `json:"contact_phone"`
	ContactEmail string      `json:"contact_email"`
}

func (q *Queries) AdminUpdateCompanyProfile(ctx context.Context, arg AdminUpdateCompanyProfileParams) (Company, error) {
	row := q.db.QueryRow(ctx, adminUpdateCompanyProfile,
		arg.ID,
		arg.CompanyName,
		arg.Cui,
		arg.Address,
		arg.ContactPhone,
		arg.ContactEmail,
	)
	var i Company
	err := row.Scan(
		&i.ID,
		&i.AdminUserID,
		&i.CompanyName,
		&i.Cui,
		&i.CompanyType,
		&i.LegalRepresentative,
		&i.ContactEmail,
		&i.ContactPhone,
		&i.Address,
		&i.City,
		&i.County,
		&i.Description,
		&i.LogoUrl,
		&i.Status,
		&i.RejectionReason,
		&i.MaxServiceRadiusKm,
		&i.RatingAvg,
		&i.TotalJobsCompleted,
		&i.ApprovedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.ClaimToken,
		&i.StripeConnectAccountID,
		&i.StripeConnectOnboardingComplete,
		&i.StripeConnectChargesEnabled,
		&i.StripeConnectPayoutsEnabled,
	)
	return i, err
}

const approveCompany = `-- name: ApproveCompany :one
UPDATE companies SET status = 'approved', approved_at = NOW(), updated_at = NOW()
WHERE id = $1 RETURNING id, admin_user_id, company_name, cui, company_type, legal_representative, contact_email, contact_phone, address, city, county, description, logo_url, status, rejection_reason, max_service_radius_km, rating_avg, total_jobs_completed, approved_at, created_at, updated_at, claim_token, stripe_connect_account_id, stripe_connect_onboarding_complete, stripe_connect_charges_enabled, stripe_connect_payouts_enabled
`

func (q *Queries) ApproveCompany(ctx context.Context, id pgtype.UUID) (Company, error) {
	row := q.db.QueryRow(ctx, approveCompany, id)
	var i Company
	err := row.Scan(
		&i.ID,
		&i.AdminUserID,
		&i.CompanyName,
		&i.Cui,
		&i.CompanyType,
		&i.LegalRepresentative,
		&i.ContactEmail,
		&i.ContactPhone,
		&i.Address,
		&i.City,
		&i.County,
		&i.Description,
		&i.LogoUrl,
		&i.Status,
		&i.RejectionReason,
		&i.MaxServiceRadiusKm,
		&i.RatingAvg,
		&i.TotalJobsCompleted,
		&i.ApprovedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.ClaimToken,
		&i.StripeConnectAccountID,
		&i.StripeConnectOnboardingComplete,
		&i.StripeConnectChargesEnabled,
		&i.StripeConnectPayoutsEnabled,
	)
	return i, err
}

const checkCompanyDocumentsReady = `-- name: CheckCompanyDocumentsReady :one
SELECT
  COUNT(CASE WHEN document_type = 'certificat_constatator' AND status = 'approved' THEN 1 END) = 1 AND
  COUNT(CASE WHEN document_type = 'asigurare_raspundere_civila' AND status = 'approved' THEN 1 END) = 1 AND
  COUNT(CASE WHEN document_type = 'cui_document' AND status = 'approved' THEN 1 END) = 1 AS all_ready
FROM company_documents
WHERE company_id = $1
`

// Returns true if all 3 required documents exist and are approved
func (q *Queries) CheckCompanyDocumentsReady(ctx context.Context, companyID pgtype.UUID) (pgtype.Bool, error) {
	row := q.db.QueryRow(ctx, checkCompanyDocumentsReady, companyID)
	var all_ready pgtype.Bool
	err := row.Scan(&all_ready)
	return all_ready, err
}

const claimCompanyByToken = `-- name: ClaimCompanyByToken :one
UPDATE companies
SET admin_user_id = $1, claim_token = NULL, updated_at = NOW()
WHERE claim_token = $2 AND admin_user_id IS NULL
RETURNING id, admin_user_id, company_name, cui, company_type, legal_representative, contact_email, contact_phone, address, city, county, description, logo_url, status, rejection_reason, max_service_radius_km, rating_avg, total_jobs_completed, approved_at, created_at, updated_at, claim_token, stripe_connect_account_id, stripe_connect_onboarding_complete, stripe_connect_charges_enabled, stripe_connect_payouts_enabled
`

type ClaimCompanyByTokenParams struct {
	AdminUserID pgtype.UUID `json:"admin_user_id"`
	ClaimToken  pgtype.Text `json:"claim_token"`
}

func (q *Queries) ClaimCompanyByToken(ctx context.Context, arg ClaimCompanyByTokenParams) (Company, error) {
	row := q.db.QueryRow(ctx, claimCompanyByToken, arg.AdminUserID, arg.ClaimToken)
	var i Company
	err := row.Scan(
		&i.ID,
		&i.AdminUserID,
		&i.CompanyName,
		&i.Cui,
		&i.CompanyType,
		&i.LegalRepresentative,
		&i.ContactEmail,
		&i.ContactPhone,
		&i.Address,
		&i.City,
		&i.County,
		&i.Description,
		&i.LogoUrl,
		&i.Status,
		&i.RejectionReason,
		&i.MaxServiceRadiusKm,
		&i.RatingAvg,
		&i.TotalJobsCompleted,
		&i.ApprovedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.ClaimToken,
		&i.StripeConnectAccountID,
		&i.StripeConnectOnboardingComplete,
		&i.StripeConnectChargesEnabled,
		&i.StripeConnectPayoutsEnabled,
	)
	return i, err
}

const countCompaniesByStatus = `-- name: CountCompaniesByStatus :one
SELECT COUNT(*) FROM companies WHERE status = $1
`

func (q *Queries) CountCompaniesByStatus(ctx context.Context, status CompanyStatus) (int64, error) {
	row := q.db.QueryRow(ctx, countCompaniesByStatus, status)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countSearchCompanies = `-- name: CountSearchCompanies :one
SELECT COUNT(*) FROM companies WHERE
    (company_name ILIKE '%' || $1::text || '%' OR cui ILIKE '%' || $1::text || '%')
    AND ($2::text = '' OR status::text = $2::text)
`

type CountSearchCompaniesParams struct {
	Query        string `json:"query"`
	StatusFilter string `json:"status_filter"`
}

func (q *Queries) CountSearchCompanies(ctx context.Context, arg CountSearchCompaniesParams) (int64, error) {
	row := q.db.QueryRow(ctx, countSearchCompanies, arg.Query, arg.StatusFilter)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createCompany = `-- name: CreateCompany :one
INSERT INTO companies (
    admin_user_id, company_name, cui, company_type, legal_representative,
    contact_email, contact_phone, address, city, county, description, claim_token
) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12)
RETURNING id, admin_user_id, company_name, cui, company_type, legal_representative, contact_email, contact_phone, address, city, county, description, logo_url, status, rejection_reason, max_service_radius_km, rating_avg, total_jobs_completed, approved_at, created_at, updated_at, claim_token, stripe_connect_account_id, stripe_connect_onboarding_complete, stripe_connect_charges_enabled, stripe_connect_payouts_enabled
`

type CreateCompanyParams struct {
	AdminUserID         pgtype.UUID `json:"admin_user_id"`
	CompanyName         string      `json:"company_name"`
	Cui                 string      `json:"cui"`
	CompanyType         CompanyType `json:"company_type"`
	LegalRepresentative string      `json:"legal_representative"`
	ContactEmail        string      `json:"contact_email"`
	ContactPhone        string      `json:"contact_phone"`
	Address             string      `json:"address"`
	City                string      `json:"city"`
	County              string      `json:"county"`
	Description         pgtype.Text `json:"description"`
	ClaimToken          pgtype.Text `json:"claim_token"`
}

func (q *Queries) CreateCompany(ctx context.Context, arg CreateCompanyParams) (Company, error) {
	row := q.db.QueryRow(ctx, createCompany,
		arg.AdminUserID,
		arg.CompanyName,
		arg.Cui,
		arg.CompanyType,
		arg.LegalRepresentative,
		arg.ContactEmail,
		arg.ContactPhone,
		arg.Address,
		arg.City,
		arg.County,
		arg.Description,
		arg.ClaimToken,
	)
	var i Company
	err := row.Scan(
		&i.ID,
		&i.AdminUserID,
		&i.CompanyName,
		&i.Cui,
		&i.CompanyType,
		&i.LegalRepresentative,
		&i.ContactEmail,
		&i.ContactPhone,
		&i.Address,
		&i.City,
		&i.County,
		&i.Description,
		&i.LogoUrl,
		&i.Status,
		&i.RejectionReason,
		&i.MaxServiceRadiusKm,
		&i.RatingAvg,
		&i.TotalJobsCompleted,
		&i.ApprovedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.ClaimToken,
		&i.StripeConnectAccountID,
		&i.StripeConnectOnboardingComplete,
		&i.StripeConnectChargesEnabled,
		&i.StripeConnectPayoutsEnabled,
	)
	return i, err
}

const getCompanyByAdminUserID = `-- name: GetCompanyByAdminUserID :one
SELECT id, admin_user_id, company_name, cui, company_type, legal_representative, contact_email, contact_phone, address, city, county, description, logo_url, status, rejection_reason, max_service_radius_km, rating_avg, total_jobs_completed, approved_at, created_at, updated_at, claim_token, stripe_connect_account_id, stripe_connect_onboarding_complete, stripe_connect_charges_enabled, stripe_connect_payouts_enabled FROM companies WHERE admin_user_id = $1
`

func (q *Queries) GetCompanyByAdminUserID(ctx context.Context, adminUserID pgtype.UUID) (Company, error) {
	row := q.db.QueryRow(ctx, getCompanyByAdminUserID, adminUserID)
	var i Company
	err := row.Scan(
		&i.ID,
		&i.AdminUserID,
		&i.CompanyName,
		&i.Cui,
		&i.CompanyType,
		&i.LegalRepresentative,
		&i.ContactEmail,
		&i.ContactPhone,
		&i.Address,
		&i.City,
		&i.County,
		&i.Description,
		&i.LogoUrl,
		&i.Status,
		&i.RejectionReason,
		&i.MaxServiceRadiusKm,
		&i.RatingAvg,
		&i.TotalJobsCompleted,
		&i.ApprovedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.ClaimToken,
		&i.StripeConnectAccountID,
		&i.StripeConnectOnboardingComplete,
		&i.StripeConnectChargesEnabled,
		&i.StripeConnectPayoutsEnabled,
	)
	return i, err
}

const getCompanyByCUI = `-- name: GetCompanyByCUI :one
SELECT id, admin_user_id, company_name, cui, company_type, legal_representative, contact_email, contact_phone, address, city, county, description, logo_url, status, rejection_reason, max_service_radius_km, rating_avg, total_jobs_completed, approved_at, created_at, updated_at, claim_token, stripe_connect_account_id, stripe_connect_onboarding_complete, stripe_connect_charges_enabled, stripe_connect_payouts_enabled FROM companies WHERE cui = $1
`

func (q *Queries) GetCompanyByCUI(ctx context.Context, cui string) (Company, error) {
	row := q.db.QueryRow(ctx, getCompanyByCUI, cui)
	var i Company
	err := row.Scan(
		&i.ID,
		&i.AdminUserID,
		&i.CompanyName,
		&i.Cui,
		&i.CompanyType,
		&i.LegalRepresentative,
		&i.ContactEmail,
		&i.ContactPhone,
		&i.Address,
		&i.City,
		&i.County,
		&i.Description,
		&i.LogoUrl,
		&i.Status,
		&i.RejectionReason,
		&i.MaxServiceRadiusKm,
		&i.RatingAvg,
		&i.TotalJobsCompleted,
		&i.ApprovedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.ClaimToken,
		&i.StripeConnectAccountID,
		&i.StripeConnectOnboardingComplete,
		&i.StripeConnectChargesEnabled,
		&i.StripeConnectPayoutsEnabled,
	)
	return i, err
}

const getCompanyByClaimToken = `-- name: GetCompanyByClaimToken :one
SELECT id, admin_user_id, company_name, cui, company_type, legal_representative, contact_email, contact_phone, address, city, county, description, logo_url, status, rejection_reason, max_service_radius_km, rating_avg, total_jobs_completed, approved_at, created_at, updated_at, claim_token, stripe_connect_account_id, stripe_connect_onboarding_complete, stripe_connect_charges_enabled, stripe_connect_payouts_enabled FROM companies
WHERE claim_token = $1 AND admin_user_id IS NULL
`

func (q *Queries) GetCompanyByClaimToken(ctx context.Context, claimToken pgtype.Text) (Company, error) {
	row := q.db.QueryRow(ctx, getCompanyByClaimToken, claimToken)
	var i Company
	err := row.Scan(
		&i.ID,
		&i.AdminUserID,
		&i.CompanyName,
		&i.Cui,
		&i.CompanyType,
		&i.LegalRepresentative,
		&i.ContactEmail,
		&i.ContactPhone,
		&i.Address,
		&i.City,
		&i.County,
		&i.Description,
		&i.LogoUrl,
		&i.Status,
		&i.RejectionReason,
		&i.MaxServiceRadiusKm,
		&i.RatingAvg,
		&i.TotalJobsCompleted,
		&i.ApprovedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.ClaimToken,
		&i.StripeConnectAccountID,
		&i.StripeConnectOnboardingComplete,
		&i.StripeConnectChargesEnabled,
		&i.StripeConnectPayoutsEnabled,
	)
	return i, err
}

const getCompanyByID = `-- name: GetCompanyByID :one
SELECT id, admin_user_id, company_name, cui, company_type, legal_representative, contact_email, contact_phone, address, city, county, description, logo_url, status, rejection_reason, max_service_radius_km, rating_avg, total_jobs_completed, approved_at, created_at, updated_at, claim_token, stripe_connect_account_id, stripe_connect_onboarding_complete, stripe_connect_charges_enabled, stripe_connect_payouts_enabled FROM companies WHERE id = $1
`

func (q *Queries) GetCompanyByID(ctx context.Context, id pgtype.UUID) (Company, error) {
	row := q.db.QueryRow(ctx, getCompanyByID, id)
	var i Company
	err := row.Scan(
		&i.ID,
		&i.AdminUserID,
		&i.CompanyName,
		&i.Cui,
		&i.CompanyType,
		&i.LegalRepresentative,
		&i.ContactEmail,
		&i.ContactPhone,
		&i.Address,
		&i.City,
		&i.County,
		&i.Description,
		&i.LogoUrl,
		&i.Status,
		&i.RejectionReason,
		&i.MaxServiceRadiusKm,
		&i.RatingAvg,
		&i.TotalJobsCompleted,
		&i.ApprovedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.ClaimToken,
		&i.StripeConnectAccountID,
		&i.StripeConnectOnboardingComplete,
		&i.StripeConnectChargesEnabled,
		&i.StripeConnectPayoutsEnabled,
	)
	return i, err
}

const getCompanyFinancialSummary = `-- name: GetCompanyFinancialSummary :one
SELECT
    COUNT(*) FILTER (WHERE status = 'completed')::bigint AS completed_bookings,
    COALESCE(SUM(COALESCE(final_total, estimated_total)) FILTER (WHERE status = 'completed'), 0)::numeric AS total_revenue,
    COALESCE(SUM(platform_commission_amount) FILTER (WHERE status = 'completed'), 0)::numeric AS total_commission,
    COALESCE(SUM(COALESCE(final_total, estimated_total) - COALESCE(platform_commission_amount, 0)) FILTER (WHERE status = 'completed'), 0)::numeric AS net_payout
FROM bookings WHERE company_id = $1
`

type GetCompanyFinancialSummaryRow struct {
	CompletedBookings int64          `json:"completed_bookings"`
	TotalRevenue      pgtype.Numeric `json:"total_revenue"`
	TotalCommission   pgtype.Numeric `json:"total_commission"`
	NetPayout         pgtype.Numeric `json:"net_payout"`
}

func (q *Queries) GetCompanyFinancialSummary(ctx context.Context, companyID pgtype.UUID) (GetCompanyFinancialSummaryRow, error) {
	row := q.db.QueryRow(ctx, getCompanyFinancialSummary, companyID)
	var i GetCompanyFinancialSummaryRow
	err := row.Scan(
		&i.CompletedBookings,
		&i.TotalRevenue,
		&i.TotalCommission,
		&i.NetPayout,
	)
	return i, err
}

const getUnclaimedCompanyByContactEmail = `-- name: GetUnclaimedCompanyByContactEmail :one
SELECT id, admin_user_id, company_name, cui, company_type, legal_representative, contact_email, contact_phone, address, city, county, description, logo_url, status, rejection_reason, max_service_radius_km, rating_avg, total_jobs_completed, approved_at, created_at, updated_at, claim_token, stripe_connect_account_id, stripe_connect_onboarding_complete, stripe_connect_charges_enabled, stripe_connect_payouts_enabled FROM companies
WHERE contact_email = $1 AND admin_user_id IS NULL
LIMIT 1
`

func (q *Queries) GetUnclaimedCompanyByContactEmail(ctx context.Context, contactEmail string) (Company, error) {
	row := q.db.QueryRow(ctx, getUnclaimedCompanyByContactEmail, contactEmail)
	var i Company
	err := row.Scan(
		&i.ID,
		&i.AdminUserID,
		&i.CompanyName,
		&i.Cui,
		&i.CompanyType,
		&i.LegalRepresentative,
		&i.ContactEmail,
		&i.ContactPhone,
		&i.Address,
		&i.City,
		&i.County,
		&i.Description,
		&i.LogoUrl,
		&i.Status,
		&i.RejectionReason,
		&i.MaxServiceRadiusKm,
		&i.RatingAvg,
		&i.TotalJobsCompleted,
		&i.ApprovedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.ClaimToken,
		&i.StripeConnectAccountID,
		&i.StripeConnectOnboardingComplete,
		&i.StripeConnectChargesEnabled,
		&i.StripeConnectPayoutsEnabled,
	)
	return i, err
}

const listAllCompanies = `-- name: ListAllCompanies :many
SELECT id, admin_user_id, company_name, cui, company_type, legal_representative, contact_email, contact_phone, address, city, county, description, logo_url, status, rejection_reason, max_service_radius_km, rating_avg, total_jobs_completed, approved_at, created_at, updated_at, claim_token, stripe_connect_account_id, stripe_connect_onboarding_complete, stripe_connect_charges_enabled, stripe_connect_payouts_enabled FROM companies ORDER BY created_at DESC LIMIT $1 OFFSET $2
`

type ListAllCompaniesParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

func (q *Queries) ListAllCompanies(ctx context.Context, arg ListAllCompaniesParams) ([]Company, error) {
	rows, err := q.db.Query(ctx, listAllCompanies, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Company
	for rows.Next() {
		var i Company
		if err := rows.Scan(
			&i.ID,
			&i.AdminUserID,
			&i.CompanyName,
			&i.Cui,
			&i.CompanyType,
			&i.LegalRepresentative,
			&i.ContactEmail,
			&i.ContactPhone,
			&i.Address,
			&i.City,
			&i.County,
			&i.Description,
			&i.LogoUrl,
			&i.Status,
			&i.RejectionReason,
			&i.MaxServiceRadiusKm,
			&i.RatingAvg,
			&i.TotalJobsCompleted,
			&i.ApprovedAt,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ClaimToken,
			&i.StripeConnectAccountID,
			&i.StripeConnectOnboardingComplete,
			&i.StripeConnectChargesEnabled,
			&i.StripeConnectPayoutsEnabled,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listCompaniesByStatus = `-- name: ListCompaniesByStatus :many
SELECT id, admin_user_id, company_name, cui, company_type, legal_representative, contact_email, contact_phone, address, city, county, description, logo_url, status, rejection_reason, max_service_radius_km, rating_avg, total_jobs_completed, approved_at, created_at, updated_at, claim_token, stripe_connect_account_id, stripe_connect_onboarding_complete, stripe_connect_charges_enabled, stripe_connect_payouts_enabled FROM companies WHERE status = $1 ORDER BY created_at DESC LIMIT $2 OFFSET $3
`

type ListCompaniesByStatusParams struct {
	Status CompanyStatus `json:"status"`
	Limit  int32         `json:"limit"`
	Offset int32         `json:"offset"`
}

func (q *Queries) ListCompaniesByStatus(ctx context.Context, arg ListCompaniesByStatusParams) ([]Company, error) {
	rows, err := q.db.Query(ctx, listCompaniesByStatus, arg.Status, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Company
	for rows.Next() {
		var i Company
		if err := rows.Scan(
			&i.ID,
			&i.AdminUserID,
			&i.CompanyName,
			&i.Cui,
			&i.CompanyType,
			&i.LegalRepresentative,
			&i.ContactEmail,
			&i.ContactPhone,
			&i.Address,
			&i.City,
			&i.County,
			&i.Description,
			&i.LogoUrl,
			&i.Status,
			&i.RejectionReason,
			&i.MaxServiceRadiusKm,
			&i.RatingAvg,
			&i.TotalJobsCompleted,
			&i.ApprovedAt,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ClaimToken,
			&i.StripeConnectAccountID,
			&i.StripeConnectOnboardingComplete,
			&i.StripeConnectChargesEnabled,
			&i.StripeConnectPayoutsEnabled,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const rejectCompany = `-- name: RejectCompany :one
UPDATE companies SET status = 'rejected', rejection_reason = $2, updated_at = NOW()
WHERE id = $1 RETURNING id, admin_user_id, company_name, cui, company_type, legal_representative, contact_email, contact_phone, address, city, county, description, logo_url, status, rejection_reason, max_service_radius_km, rating_avg, total_jobs_completed, approved_at, created_at, updated_at, claim_token, stripe_connect_account_id, stripe_connect_onboarding_complete, stripe_connect_charges_enabled, stripe_connect_payouts_enabled
`

type RejectCompanyParams struct {
	ID              pgtype.UUID `json:"id"`
	RejectionReason pgtype.Text `json:"rejection_reason"`
}

func (q *Queries) RejectCompany(ctx context.Context, arg RejectCompanyParams) (Company, error) {
	row := q.db.QueryRow(ctx, rejectCompany, arg.ID, arg.RejectionReason)
	var i Company
	err := row.Scan(
		&i.ID,
		&i.AdminUserID,
		&i.CompanyName,
		&i.Cui,
		&i.CompanyType,
		&i.LegalRepresentative,
		&i.ContactEmail,
		&i.ContactPhone,
		&i.Address,
		&i.City,
		&i.County,
		&i.Description,
		&i.LogoUrl,
		&i.Status,
		&i.RejectionReason,
		&i.MaxServiceRadiusKm,
		&i.RatingAvg,
		&i.TotalJobsCompleted,
		&i.ApprovedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.ClaimToken,
		&i.StripeConnectAccountID,
		&i.StripeConnectOnboardingComplete,
		&i.StripeConnectChargesEnabled,
		&i.StripeConnectPayoutsEnabled,
	)
	return i, err
}

const searchCompanies = `-- name: SearchCompanies :many
SELECT id, admin_user_id, company_name, cui, company_type, legal_representative, contact_email, contact_phone, address, city, county, description, logo_url, status, rejection_reason, max_service_radius_km, rating_avg, total_jobs_completed, approved_at, created_at, updated_at, claim_token, stripe_connect_account_id, stripe_connect_onboarding_complete, stripe_connect_charges_enabled, stripe_connect_payouts_enabled FROM companies WHERE
    (company_name ILIKE '%' || $3::text || '%' OR cui ILIKE '%' || $3::text || '%')
    AND ($4::text = '' OR status::text = $4::text)
ORDER BY created_at DESC LIMIT $1 OFFSET $2
`

type SearchCompaniesParams struct {
	Limit        int32  `json:"limit"`
	Offset       int32  `json:"offset"`
	Query        string `json:"query"`
	StatusFilter string `json:"status_filter"`
}

func (q *Queries) SearchCompanies(ctx context.Context, arg SearchCompaniesParams) ([]Company, error) {
	rows, err := q.db.Query(ctx, searchCompanies,
		arg.Limit,
		arg.Offset,
		arg.Query,
		arg.StatusFilter,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Company
	for rows.Next() {
		var i Company
		if err := rows.Scan(
			&i.ID,
			&i.AdminUserID,
			&i.CompanyName,
			&i.Cui,
			&i.CompanyType,
			&i.LegalRepresentative,
			&i.ContactEmail,
			&i.ContactPhone,
			&i.Address,
			&i.City,
			&i.County,
			&i.Description,
			&i.LogoUrl,
			&i.Status,
			&i.RejectionReason,
			&i.MaxServiceRadiusKm,
			&i.RatingAvg,
			&i.TotalJobsCompleted,
			&i.ApprovedAt,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ClaimToken,
			&i.StripeConnectAccountID,
			&i.StripeConnectOnboardingComplete,
			&i.StripeConnectChargesEnabled,
			&i.StripeConnectPayoutsEnabled,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const setCompanyAdminUser = `-- name: SetCompanyAdminUser :one
UPDATE companies SET admin_user_id = $1, updated_at = NOW()
WHERE id = $2
RETURNING id, admin_user_id, company_name, cui, company_type, legal_representative, contact_email, contact_phone, address, city, county, description, logo_url, status, rejection_reason, max_service_radius_km, rating_avg, total_jobs_completed, approved_at, created_at, updated_at, claim_token, stripe_connect_account_id, stripe_connect_onboarding_complete, stripe_connect_charges_enabled, stripe_connect_payouts_enabled
`

type SetCompanyAdminUserParams struct {
	AdminUserID pgtype.UUID `json:"admin_user_id"`
	ID          pgtype.UUID `json:"id"`
}

func (q *Queries) SetCompanyAdminUser(ctx context.Context, arg SetCompanyAdminUserParams) (Company, error) {
	row := q.db.QueryRow(ctx, setCompanyAdminUser, arg.AdminUserID, arg.ID)
	var i Company
	err := row.Scan(
		&i.ID,
		&i.AdminUserID,
		&i.CompanyName,
		&i.Cui,
		&i.CompanyType,
		&i.LegalRepresentative,
		&i.ContactEmail,
		&i.ContactPhone,
		&i.Address,
		&i.City,
		&i.County,
		&i.Description,
		&i.LogoUrl,
		&i.Status,
		&i.RejectionReason,
		&i.MaxServiceRadiusKm,
		&i.RatingAvg,
		&i.TotalJobsCompleted,
		&i.ApprovedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.ClaimToken,
		&i.StripeConnectAccountID,
		&i.StripeConnectOnboardingComplete,
		&i.StripeConnectChargesEnabled,
		&i.StripeConnectPayoutsEnabled,
	)
	return i, err
}

const updateCompanyLogo = `-- name: UpdateCompanyLogo :one
UPDATE companies SET logo_url = $2, updated_at = NOW() WHERE id = $1 RETURNING id, admin_user_id, company_name, cui, company_type, legal_representative, contact_email, contact_phone, address, city, county, description, logo_url, status, rejection_reason, max_service_radius_km, rating_avg, total_jobs_completed, approved_at, created_at, updated_at, claim_token, stripe_connect_account_id, stripe_connect_onboarding_complete, stripe_connect_charges_enabled, stripe_connect_payouts_enabled
`

type UpdateCompanyLogoParams struct {
	ID      pgtype.UUID `json:"id"`
	LogoUrl pgtype.Text `json:"logo_url"`
}

func (q *Queries) UpdateCompanyLogo(ctx context.Context, arg UpdateCompanyLogoParams) (Company, error) {
	row := q.db.QueryRow(ctx, updateCompanyLogo, arg.ID, arg.LogoUrl)
	var i Company
	err := row.Scan(
		&i.ID,
		&i.AdminUserID,
		&i.CompanyName,
		&i.Cui,
		&i.CompanyType,
		&i.LegalRepresentative,
		&i.ContactEmail,
		&i.ContactPhone,
		&i.Address,
		&i.City,
		&i.County,
		&i.Description,
		&i.LogoUrl,
		&i.Status,
		&i.RejectionReason,
		&i.MaxServiceRadiusKm,
		&i.RatingAvg,
		&i.TotalJobsCompleted,
		&i.ApprovedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.ClaimToken,
		&i.StripeConnectAccountID,
		&i.StripeConnectOnboardingComplete,
		&i.StripeConnectChargesEnabled,
		&i.StripeConnectPayoutsEnabled,
	)
	return i, err
}

const updateCompanyOwnProfile = `-- name: UpdateCompanyOwnProfile :one
UPDATE companies SET
    description = COALESCE(NULLIF($2::text, ''), description),
    contact_phone = COALESCE(NULLIF($3::text, ''), contact_phone),
    contact_email = COALESCE(NULLIF($4::text, ''), contact_email),
    max_service_radius_km = CASE WHEN $5::int > 0 THEN $5::int ELSE max_service_radius_km END,
    updated_at = NOW()
WHERE id = $1 RETURNING id, admin_user_id, company_name, cui, company_type, legal_representative, contact_email, contact_phone, address, city, county, description, logo_url, status, rejection_reason, max_service_radius_km, rating_avg, total_jobs_completed, approved_at, created_at, updated_at, claim_token, stripe_connect_account_id, stripe_connect_onboarding_complete, stripe_connect_charges_enabled, stripe_connect_payouts_enabled
`

type UpdateCompanyOwnProfileParams struct {
	ID           pgtype.UUID `json:"id"`
	Description  string      `json:"description"`
	ContactPhone string      `json:"contact_phone"`
	ContactEmail string      `json:"contact_email"`
	MaxRadius    int32       `json:"max_radius"`
}

func (q *Queries) UpdateCompanyOwnProfile(ctx context.Context, arg UpdateCompanyOwnProfileParams) (Company, error) {
	row := q.db.QueryRow(ctx, updateCompanyOwnProfile,
		arg.ID,
		arg.Description,
		arg.ContactPhone,
		arg.ContactEmail,
		arg.MaxRadius,
	)
	var i Company
	err := row.Scan(
		&i.ID,
		&i.AdminUserID,
		&i.CompanyName,
		&i.Cui,
		&i.CompanyType,
		&i.LegalRepresentative,
		&i.ContactEmail,
		&i.ContactPhone,
		&i.Address,
		&i.City,
		&i.County,
		&i.Description,
		&i.LogoUrl,
		&i.Status,
		&i.RejectionReason,
		&i.MaxServiceRadiusKm,
		&i.RatingAvg,
		&i.TotalJobsCompleted,
		&i.ApprovedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.ClaimToken,
		&i.StripeConnectAccountID,
		&i.StripeConnectOnboardingComplete,
		&i.StripeConnectChargesEnabled,
		&i.StripeConnectPayoutsEnabled,
	)
	return i, err
}

const updateCompanyStatus = `-- name: UpdateCompanyStatus :one
UPDATE companies SET status = $2, updated_at = NOW() WHERE id = $1 RETURNING id, admin_user_id, company_name, cui, company_type, legal_representative, contact_email, contact_phone, address, city, county, description, logo_url, status, rejection_reason, max_service_radius_km, rating_avg, total_jobs_completed, approved_at, created_at, updated_at, claim_token, stripe_connect_account_id, stripe_connect_onboarding_complete, stripe_connect_charges_enabled, stripe_connect_payouts_enabled
`

type UpdateCompanyStatusParams struct {
	ID     pgtype.UUID   `json:"id"`
	Status CompanyStatus `json:"status"`
}

func (q *Queries) UpdateCompanyStatus(ctx context.Context, arg UpdateCompanyStatusParams) (Company, error) {
	row := q.db.QueryRow(ctx, updateCompanyStatus, arg.ID, arg.Status)
	var i Company
	err := row.Scan(
		&i.ID,
		&i.AdminUserID,
		&i.CompanyName,
		&i.Cui,
		&i.CompanyType,
		&i.LegalRepresentative,
		&i.ContactEmail,
		&i.ContactPhone,
		&i.Address,
		&i.City,
		&i.County,
		&i.Description,
		&i.LogoUrl,
		&i.Status,
		&i.RejectionReason,
		&i.MaxServiceRadiusKm,
		&i.RatingAvg,
		&i.TotalJobsCompleted,
		&i.ApprovedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.ClaimToken,
		&i.StripeConnectAccountID,
		&i.StripeConnectOnboardingComplete,
		&i.StripeConnectChargesEnabled,
		&i.StripeConnectPayoutsEnabled,
	)
	return i, err
}
