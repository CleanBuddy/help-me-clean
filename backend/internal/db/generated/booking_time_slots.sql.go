// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: booking_time_slots.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createBookingTimeSlot = `-- name: CreateBookingTimeSlot :one
INSERT INTO booking_time_slots (booking_id, slot_date, start_time, end_time, is_selected)
VALUES ($1, $2, $3, $4, $5)
RETURNING id, booking_id, slot_date, start_time, end_time, is_selected, created_at
`

type CreateBookingTimeSlotParams struct {
	BookingID  pgtype.UUID `json:"booking_id"`
	SlotDate   pgtype.Date `json:"slot_date"`
	StartTime  pgtype.Time `json:"start_time"`
	EndTime    pgtype.Time `json:"end_time"`
	IsSelected bool        `json:"is_selected"`
}

func (q *Queries) CreateBookingTimeSlot(ctx context.Context, arg CreateBookingTimeSlotParams) (BookingTimeSlot, error) {
	row := q.db.QueryRow(ctx, createBookingTimeSlot,
		arg.BookingID,
		arg.SlotDate,
		arg.StartTime,
		arg.EndTime,
		arg.IsSelected,
	)
	var i BookingTimeSlot
	err := row.Scan(
		&i.ID,
		&i.BookingID,
		&i.SlotDate,
		&i.StartTime,
		&i.EndTime,
		&i.IsSelected,
		&i.CreatedAt,
	)
	return i, err
}

const deleteBookingTimeSlots = `-- name: DeleteBookingTimeSlots :exec
DELETE FROM booking_time_slots WHERE booking_id = $1
`

func (q *Queries) DeleteBookingTimeSlots(ctx context.Context, bookingID pgtype.UUID) error {
	_, err := q.db.Exec(ctx, deleteBookingTimeSlots, bookingID)
	return err
}

const deselectAllBookingTimeSlots = `-- name: DeselectAllBookingTimeSlots :exec
UPDATE booking_time_slots SET is_selected = FALSE WHERE booking_id = $1
`

func (q *Queries) DeselectAllBookingTimeSlots(ctx context.Context, bookingID pgtype.UUID) error {
	_, err := q.db.Exec(ctx, deselectAllBookingTimeSlots, bookingID)
	return err
}

const getSelectedTimeSlot = `-- name: GetSelectedTimeSlot :one
SELECT id, booking_id, slot_date, start_time, end_time, is_selected, created_at FROM booking_time_slots WHERE booking_id = $1 AND is_selected = TRUE LIMIT 1
`

func (q *Queries) GetSelectedTimeSlot(ctx context.Context, bookingID pgtype.UUID) (BookingTimeSlot, error) {
	row := q.db.QueryRow(ctx, getSelectedTimeSlot, bookingID)
	var i BookingTimeSlot
	err := row.Scan(
		&i.ID,
		&i.BookingID,
		&i.SlotDate,
		&i.StartTime,
		&i.EndTime,
		&i.IsSelected,
		&i.CreatedAt,
	)
	return i, err
}

const listBookingTimeSlots = `-- name: ListBookingTimeSlots :many
SELECT id, booking_id, slot_date, start_time, end_time, is_selected, created_at FROM booking_time_slots WHERE booking_id = $1 ORDER BY slot_date, start_time
`

func (q *Queries) ListBookingTimeSlots(ctx context.Context, bookingID pgtype.UUID) ([]BookingTimeSlot, error) {
	rows, err := q.db.Query(ctx, listBookingTimeSlots, bookingID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []BookingTimeSlot
	for rows.Next() {
		var i BookingTimeSlot
		if err := rows.Scan(
			&i.ID,
			&i.BookingID,
			&i.SlotDate,
			&i.StartTime,
			&i.EndTime,
			&i.IsSelected,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const selectBookingTimeSlot = `-- name: SelectBookingTimeSlot :one
UPDATE booking_time_slots SET is_selected = TRUE WHERE id = $1 RETURNING id, booking_id, slot_date, start_time, end_time, is_selected, created_at
`

func (q *Queries) SelectBookingTimeSlot(ctx context.Context, id pgtype.UUID) (BookingTimeSlot, error) {
	row := q.db.QueryRow(ctx, selectBookingTimeSlot, id)
	var i BookingTimeSlot
	err := row.Scan(
		&i.ID,
		&i.BookingID,
		&i.SlotDate,
		&i.StartTime,
		&i.EndTime,
		&i.IsSelected,
		&i.CreatedAt,
	)
	return i, err
}
