// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: analytics.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const getCleanerEarningsByDateRange = `-- name: GetCleanerEarningsByDateRange :many
SELECT DATE(completed_at) AS date,
    COALESCE(SUM(COALESCE(final_total, estimated_total)), 0)::numeric AS amount
FROM bookings
WHERE cleaner_id = $1 AND status = 'completed' AND completed_at >= $2 AND completed_at <= $3
GROUP BY DATE(completed_at) ORDER BY date
`

type GetCleanerEarningsByDateRangeParams struct {
	CleanerID     pgtype.UUID        `json:"cleaner_id"`
	CompletedAt   pgtype.Timestamptz `json:"completed_at"`
	CompletedAt_2 pgtype.Timestamptz `json:"completed_at_2"`
}

type GetCleanerEarningsByDateRangeRow struct {
	Date   pgtype.Date    `json:"date"`
	Amount pgtype.Numeric `json:"amount"`
}

func (q *Queries) GetCleanerEarningsByDateRange(ctx context.Context, arg GetCleanerEarningsByDateRangeParams) ([]GetCleanerEarningsByDateRangeRow, error) {
	rows, err := q.db.Query(ctx, getCleanerEarningsByDateRange, arg.CleanerID, arg.CompletedAt, arg.CompletedAt_2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetCleanerEarningsByDateRangeRow
	for rows.Next() {
		var i GetCleanerEarningsByDateRangeRow
		if err := rows.Scan(&i.Date, &i.Amount); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCompanyRevenueByDateRange = `-- name: GetCompanyRevenueByDateRange :many
SELECT DATE(completed_at) AS date,
    COUNT(*)::bigint AS booking_count,
    COALESCE(SUM(COALESCE(final_total, estimated_total)), 0)::numeric AS revenue,
    COALESCE(SUM(COALESCE(platform_commission_amount, 0)), 0)::numeric AS commission
FROM bookings
WHERE company_id = $1 AND status = 'completed' AND completed_at >= $2 AND completed_at <= $3
GROUP BY DATE(completed_at) ORDER BY date
`

type GetCompanyRevenueByDateRangeParams struct {
	CompanyID     pgtype.UUID        `json:"company_id"`
	CompletedAt   pgtype.Timestamptz `json:"completed_at"`
	CompletedAt_2 pgtype.Timestamptz `json:"completed_at_2"`
}

type GetCompanyRevenueByDateRangeRow struct {
	Date         pgtype.Date    `json:"date"`
	BookingCount int64          `json:"booking_count"`
	Revenue      pgtype.Numeric `json:"revenue"`
	Commission   pgtype.Numeric `json:"commission"`
}

func (q *Queries) GetCompanyRevenueByDateRange(ctx context.Context, arg GetCompanyRevenueByDateRangeParams) ([]GetCompanyRevenueByDateRangeRow, error) {
	rows, err := q.db.Query(ctx, getCompanyRevenueByDateRange, arg.CompanyID, arg.CompletedAt, arg.CompletedAt_2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetCompanyRevenueByDateRangeRow
	for rows.Next() {
		var i GetCompanyRevenueByDateRangeRow
		if err := rows.Scan(
			&i.Date,
			&i.BookingCount,
			&i.Revenue,
			&i.Commission,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPlatformTotals = `-- name: GetPlatformTotals :one
SELECT
    COUNT(*) FILTER (WHERE status = 'completed')::bigint AS total_completed,
    COUNT(*)::bigint AS total_bookings,
    COALESCE(SUM(COALESCE(final_total, estimated_total)) FILTER (WHERE status = 'completed'), 0)::numeric AS total_revenue,
    COALESCE(SUM(platform_commission_amount) FILTER (WHERE status = 'completed'), 0)::numeric AS total_commission,
    COUNT(DISTINCT client_user_id)::bigint AS unique_clients,
    COUNT(DISTINCT company_id) FILTER (WHERE company_id IS NOT NULL)::bigint AS active_companies
FROM bookings
`

type GetPlatformTotalsRow struct {
	TotalCompleted  int64          `json:"total_completed"`
	TotalBookings   int64          `json:"total_bookings"`
	TotalRevenue    pgtype.Numeric `json:"total_revenue"`
	TotalCommission pgtype.Numeric `json:"total_commission"`
	UniqueClients   int64          `json:"unique_clients"`
	ActiveCompanies int64          `json:"active_companies"`
}

func (q *Queries) GetPlatformTotals(ctx context.Context) (GetPlatformTotalsRow, error) {
	row := q.db.QueryRow(ctx, getPlatformTotals)
	var i GetPlatformTotalsRow
	err := row.Scan(
		&i.TotalCompleted,
		&i.TotalBookings,
		&i.TotalRevenue,
		&i.TotalCommission,
		&i.UniqueClients,
		&i.ActiveCompanies,
	)
	return i, err
}

const getRevenueByDateRange = `-- name: GetRevenueByDateRange :many
SELECT DATE(completed_at) AS date,
    COUNT(*)::bigint AS booking_count,
    COALESCE(SUM(COALESCE(final_total, estimated_total)), 0)::numeric AS revenue,
    COALESCE(SUM(COALESCE(platform_commission_amount, 0)), 0)::numeric AS commission
FROM bookings
WHERE status = 'completed' AND completed_at >= $1 AND completed_at <= $2
GROUP BY DATE(completed_at) ORDER BY date
`

type GetRevenueByDateRangeParams struct {
	CompletedAt   pgtype.Timestamptz `json:"completed_at"`
	CompletedAt_2 pgtype.Timestamptz `json:"completed_at_2"`
}

type GetRevenueByDateRangeRow struct {
	Date         pgtype.Date    `json:"date"`
	BookingCount int64          `json:"booking_count"`
	Revenue      pgtype.Numeric `json:"revenue"`
	Commission   pgtype.Numeric `json:"commission"`
}

func (q *Queries) GetRevenueByDateRange(ctx context.Context, arg GetRevenueByDateRangeParams) ([]GetRevenueByDateRangeRow, error) {
	rows, err := q.db.Query(ctx, getRevenueByDateRange, arg.CompletedAt, arg.CompletedAt_2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetRevenueByDateRangeRow
	for rows.Next() {
		var i GetRevenueByDateRangeRow
		if err := rows.Scan(
			&i.Date,
			&i.BookingCount,
			&i.Revenue,
			&i.Commission,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRevenueByServiceType = `-- name: GetRevenueByServiceType :many
SELECT service_type,
    COUNT(*)::bigint AS booking_count,
    COALESCE(SUM(COALESCE(final_total, estimated_total)), 0)::numeric AS revenue
FROM bookings
WHERE status = 'completed' AND completed_at >= $1 AND completed_at <= $2
GROUP BY service_type ORDER BY revenue DESC
`

type GetRevenueByServiceTypeParams struct {
	CompletedAt   pgtype.Timestamptz `json:"completed_at"`
	CompletedAt_2 pgtype.Timestamptz `json:"completed_at_2"`
}

type GetRevenueByServiceTypeRow struct {
	ServiceType  ServiceType    `json:"service_type"`
	BookingCount int64          `json:"booking_count"`
	Revenue      pgtype.Numeric `json:"revenue"`
}

func (q *Queries) GetRevenueByServiceType(ctx context.Context, arg GetRevenueByServiceTypeParams) ([]GetRevenueByServiceTypeRow, error) {
	rows, err := q.db.Query(ctx, getRevenueByServiceType, arg.CompletedAt, arg.CompletedAt_2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetRevenueByServiceTypeRow
	for rows.Next() {
		var i GetRevenueByServiceTypeRow
		if err := rows.Scan(&i.ServiceType, &i.BookingCount, &i.Revenue); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTopCompaniesByRevenue = `-- name: GetTopCompaniesByRevenue :many
SELECT c.id, c.company_name,
    COUNT(b.id)::bigint AS booking_count,
    COALESCE(SUM(COALESCE(b.final_total, b.estimated_total)), 0)::numeric AS revenue,
    COALESCE(SUM(COALESCE(b.platform_commission_amount, 0)), 0)::numeric AS commission
FROM bookings b JOIN companies c ON b.company_id = c.id
WHERE b.status = 'completed' AND b.completed_at >= $1 AND b.completed_at <= $2
GROUP BY c.id, c.company_name ORDER BY revenue DESC LIMIT $3
`

type GetTopCompaniesByRevenueParams struct {
	CompletedAt   pgtype.Timestamptz `json:"completed_at"`
	CompletedAt_2 pgtype.Timestamptz `json:"completed_at_2"`
	Limit         int32              `json:"limit"`
}

type GetTopCompaniesByRevenueRow struct {
	ID           pgtype.UUID    `json:"id"`
	CompanyName  string         `json:"company_name"`
	BookingCount int64          `json:"booking_count"`
	Revenue      pgtype.Numeric `json:"revenue"`
	Commission   pgtype.Numeric `json:"commission"`
}

func (q *Queries) GetTopCompaniesByRevenue(ctx context.Context, arg GetTopCompaniesByRevenueParams) ([]GetTopCompaniesByRevenueRow, error) {
	rows, err := q.db.Query(ctx, getTopCompaniesByRevenue, arg.CompletedAt, arg.CompletedAt_2, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetTopCompaniesByRevenueRow
	for rows.Next() {
		var i GetTopCompaniesByRevenueRow
		if err := rows.Scan(
			&i.ID,
			&i.CompanyName,
			&i.BookingCount,
			&i.Revenue,
			&i.Commission,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
