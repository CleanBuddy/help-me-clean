// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: recurring_bookings.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const cancelFutureOccurrences = `-- name: CancelFutureOccurrences :exec
UPDATE bookings
SET status = 'cancelled_by_client', cancelled_at = NOW(), cancellation_reason = $2, updated_at = NOW()
WHERE recurring_group_id = $1
  AND scheduled_date >= CURRENT_DATE
  AND status IN ('pending', 'assigned', 'confirmed')
`

type CancelFutureOccurrencesParams struct {
	RecurringGroupID   pgtype.UUID `json:"recurring_group_id"`
	CancellationReason pgtype.Text `json:"cancellation_reason"`
}

func (q *Queries) CancelFutureOccurrences(ctx context.Context, arg CancelFutureOccurrencesParams) error {
	_, err := q.db.Exec(ctx, cancelFutureOccurrences, arg.RecurringGroupID, arg.CancellationReason)
	return err
}

const cancelRecurringGroup = `-- name: CancelRecurringGroup :one
UPDATE recurring_booking_groups
SET is_active = FALSE, cancelled_at = NOW(), cancellation_reason = $2, updated_at = NOW()
WHERE id = $1 RETURNING id, client_user_id, company_id, preferred_cleaner_id, address_id, recurrence_type, day_of_week, preferred_time, service_type, property_type, num_rooms, num_bathrooms, area_sqm, has_pets, special_instructions, hourly_rate, estimated_total_per_occurrence, is_active, cancelled_at, cancellation_reason, created_at, updated_at
`

type CancelRecurringGroupParams struct {
	ID                 pgtype.UUID `json:"id"`
	CancellationReason pgtype.Text `json:"cancellation_reason"`
}

func (q *Queries) CancelRecurringGroup(ctx context.Context, arg CancelRecurringGroupParams) (RecurringBookingGroup, error) {
	row := q.db.QueryRow(ctx, cancelRecurringGroup, arg.ID, arg.CancellationReason)
	var i RecurringBookingGroup
	err := row.Scan(
		&i.ID,
		&i.ClientUserID,
		&i.CompanyID,
		&i.PreferredCleanerID,
		&i.AddressID,
		&i.RecurrenceType,
		&i.DayOfWeek,
		&i.PreferredTime,
		&i.ServiceType,
		&i.PropertyType,
		&i.NumRooms,
		&i.NumBathrooms,
		&i.AreaSqm,
		&i.HasPets,
		&i.SpecialInstructions,
		&i.HourlyRate,
		&i.EstimatedTotalPerOccurrence,
		&i.IsActive,
		&i.CancelledAt,
		&i.CancellationReason,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const countActiveRecurringGroups = `-- name: CountActiveRecurringGroups :one
SELECT COUNT(*) FROM recurring_booking_groups WHERE is_active = TRUE
`

func (q *Queries) CountActiveRecurringGroups(ctx context.Context) (int64, error) {
	row := q.db.QueryRow(ctx, countActiveRecurringGroups)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createRecurringGroup = `-- name: CreateRecurringGroup :one
INSERT INTO recurring_booking_groups (
    client_user_id, company_id, preferred_cleaner_id, address_id,
    recurrence_type, day_of_week, preferred_time, service_type,
    property_type, num_rooms, num_bathrooms, area_sqm, has_pets,
    special_instructions, hourly_rate, estimated_total_per_occurrence
) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16)
RETURNING id, client_user_id, company_id, preferred_cleaner_id, address_id, recurrence_type, day_of_week, preferred_time, service_type, property_type, num_rooms, num_bathrooms, area_sqm, has_pets, special_instructions, hourly_rate, estimated_total_per_occurrence, is_active, cancelled_at, cancellation_reason, created_at, updated_at
`

type CreateRecurringGroupParams struct {
	ClientUserID                pgtype.UUID    `json:"client_user_id"`
	CompanyID                   pgtype.UUID    `json:"company_id"`
	PreferredCleanerID          pgtype.UUID    `json:"preferred_cleaner_id"`
	AddressID                   pgtype.UUID    `json:"address_id"`
	RecurrenceType              RecurrenceType `json:"recurrence_type"`
	DayOfWeek                   pgtype.Int4    `json:"day_of_week"`
	PreferredTime               pgtype.Time    `json:"preferred_time"`
	ServiceType                 ServiceType    `json:"service_type"`
	PropertyType                pgtype.Text    `json:"property_type"`
	NumRooms                    pgtype.Int4    `json:"num_rooms"`
	NumBathrooms                pgtype.Int4    `json:"num_bathrooms"`
	AreaSqm                     pgtype.Int4    `json:"area_sqm"`
	HasPets                     pgtype.Bool    `json:"has_pets"`
	SpecialInstructions         pgtype.Text    `json:"special_instructions"`
	HourlyRate                  pgtype.Numeric `json:"hourly_rate"`
	EstimatedTotalPerOccurrence pgtype.Numeric `json:"estimated_total_per_occurrence"`
}

func (q *Queries) CreateRecurringGroup(ctx context.Context, arg CreateRecurringGroupParams) (RecurringBookingGroup, error) {
	row := q.db.QueryRow(ctx, createRecurringGroup,
		arg.ClientUserID,
		arg.CompanyID,
		arg.PreferredCleanerID,
		arg.AddressID,
		arg.RecurrenceType,
		arg.DayOfWeek,
		arg.PreferredTime,
		arg.ServiceType,
		arg.PropertyType,
		arg.NumRooms,
		arg.NumBathrooms,
		arg.AreaSqm,
		arg.HasPets,
		arg.SpecialInstructions,
		arg.HourlyRate,
		arg.EstimatedTotalPerOccurrence,
	)
	var i RecurringBookingGroup
	err := row.Scan(
		&i.ID,
		&i.ClientUserID,
		&i.CompanyID,
		&i.PreferredCleanerID,
		&i.AddressID,
		&i.RecurrenceType,
		&i.DayOfWeek,
		&i.PreferredTime,
		&i.ServiceType,
		&i.PropertyType,
		&i.NumRooms,
		&i.NumBathrooms,
		&i.AreaSqm,
		&i.HasPets,
		&i.SpecialInstructions,
		&i.HourlyRate,
		&i.EstimatedTotalPerOccurrence,
		&i.IsActive,
		&i.CancelledAt,
		&i.CancellationReason,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getBookingsByRecurringGroup = `-- name: GetBookingsByRecurringGroup :many
SELECT id, reference_code, client_user_id, company_id, cleaner_id, address_id, service_type, scheduled_date, scheduled_start_time, estimated_duration_hours, property_type, num_rooms, num_bathrooms, area_sqm, has_pets, special_instructions, hourly_rate, estimated_total, final_total, platform_commission_pct, platform_commission_amount, status, started_at, completed_at, cancelled_at, cancellation_reason, stripe_payment_intent_id, payment_status, paid_at, created_at, updated_at, recurring_group_id, occurrence_number FROM bookings
WHERE recurring_group_id = $1
ORDER BY scheduled_date, scheduled_start_time
`

func (q *Queries) GetBookingsByRecurringGroup(ctx context.Context, recurringGroupID pgtype.UUID) ([]Booking, error) {
	rows, err := q.db.Query(ctx, getBookingsByRecurringGroup, recurringGroupID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Booking
	for rows.Next() {
		var i Booking
		if err := rows.Scan(
			&i.ID,
			&i.ReferenceCode,
			&i.ClientUserID,
			&i.CompanyID,
			&i.CleanerID,
			&i.AddressID,
			&i.ServiceType,
			&i.ScheduledDate,
			&i.ScheduledStartTime,
			&i.EstimatedDurationHours,
			&i.PropertyType,
			&i.NumRooms,
			&i.NumBathrooms,
			&i.AreaSqm,
			&i.HasPets,
			&i.SpecialInstructions,
			&i.HourlyRate,
			&i.EstimatedTotal,
			&i.FinalTotal,
			&i.PlatformCommissionPct,
			&i.PlatformCommissionAmount,
			&i.Status,
			&i.StartedAt,
			&i.CompletedAt,
			&i.CancelledAt,
			&i.CancellationReason,
			&i.StripePaymentIntentID,
			&i.PaymentStatus,
			&i.PaidAt,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.RecurringGroupID,
			&i.OccurrenceNumber,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRecurringGroupByID = `-- name: GetRecurringGroupByID :one
SELECT id, client_user_id, company_id, preferred_cleaner_id, address_id, recurrence_type, day_of_week, preferred_time, service_type, property_type, num_rooms, num_bathrooms, area_sqm, has_pets, special_instructions, hourly_rate, estimated_total_per_occurrence, is_active, cancelled_at, cancellation_reason, created_at, updated_at FROM recurring_booking_groups WHERE id = $1
`

func (q *Queries) GetRecurringGroupByID(ctx context.Context, id pgtype.UUID) (RecurringBookingGroup, error) {
	row := q.db.QueryRow(ctx, getRecurringGroupByID, id)
	var i RecurringBookingGroup
	err := row.Scan(
		&i.ID,
		&i.ClientUserID,
		&i.CompanyID,
		&i.PreferredCleanerID,
		&i.AddressID,
		&i.RecurrenceType,
		&i.DayOfWeek,
		&i.PreferredTime,
		&i.ServiceType,
		&i.PropertyType,
		&i.NumRooms,
		&i.NumBathrooms,
		&i.AreaSqm,
		&i.HasPets,
		&i.SpecialInstructions,
		&i.HourlyRate,
		&i.EstimatedTotalPerOccurrence,
		&i.IsActive,
		&i.CancelledAt,
		&i.CancellationReason,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getRecurringGroupExtras = `-- name: GetRecurringGroupExtras :many
SELECT rge.id, rge.group_id, rge.extra_id, rge.quantity, se.name_ro, se.name_en, se.price, se.duration_minutes
FROM recurring_group_extras rge
JOIN service_extras se ON se.id = rge.extra_id
WHERE rge.group_id = $1
`

type GetRecurringGroupExtrasRow struct {
	ID              pgtype.UUID    `json:"id"`
	GroupID         pgtype.UUID    `json:"group_id"`
	ExtraID         pgtype.UUID    `json:"extra_id"`
	Quantity        pgtype.Int4    `json:"quantity"`
	NameRo          string         `json:"name_ro"`
	NameEn          string         `json:"name_en"`
	Price           pgtype.Numeric `json:"price"`
	DurationMinutes int32          `json:"duration_minutes"`
}

func (q *Queries) GetRecurringGroupExtras(ctx context.Context, groupID pgtype.UUID) ([]GetRecurringGroupExtrasRow, error) {
	rows, err := q.db.Query(ctx, getRecurringGroupExtras, groupID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetRecurringGroupExtrasRow
	for rows.Next() {
		var i GetRecurringGroupExtrasRow
		if err := rows.Scan(
			&i.ID,
			&i.GroupID,
			&i.ExtraID,
			&i.Quantity,
			&i.NameRo,
			&i.NameEn,
			&i.Price,
			&i.DurationMinutes,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUpcomingBookingsByRecurringGroup = `-- name: GetUpcomingBookingsByRecurringGroup :many
SELECT id, reference_code, client_user_id, company_id, cleaner_id, address_id, service_type, scheduled_date, scheduled_start_time, estimated_duration_hours, property_type, num_rooms, num_bathrooms, area_sqm, has_pets, special_instructions, hourly_rate, estimated_total, final_total, platform_commission_pct, platform_commission_amount, status, started_at, completed_at, cancelled_at, cancellation_reason, stripe_payment_intent_id, payment_status, paid_at, created_at, updated_at, recurring_group_id, occurrence_number FROM bookings
WHERE recurring_group_id = $1
  AND scheduled_date >= CURRENT_DATE
  AND status NOT IN ('cancelled_by_client', 'cancelled_by_company', 'cancelled_by_admin')
ORDER BY scheduled_date, scheduled_start_time
`

func (q *Queries) GetUpcomingBookingsByRecurringGroup(ctx context.Context, recurringGroupID pgtype.UUID) ([]Booking, error) {
	rows, err := q.db.Query(ctx, getUpcomingBookingsByRecurringGroup, recurringGroupID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Booking
	for rows.Next() {
		var i Booking
		if err := rows.Scan(
			&i.ID,
			&i.ReferenceCode,
			&i.ClientUserID,
			&i.CompanyID,
			&i.CleanerID,
			&i.AddressID,
			&i.ServiceType,
			&i.ScheduledDate,
			&i.ScheduledStartTime,
			&i.EstimatedDurationHours,
			&i.PropertyType,
			&i.NumRooms,
			&i.NumBathrooms,
			&i.AreaSqm,
			&i.HasPets,
			&i.SpecialInstructions,
			&i.HourlyRate,
			&i.EstimatedTotal,
			&i.FinalTotal,
			&i.PlatformCommissionPct,
			&i.PlatformCommissionAmount,
			&i.Status,
			&i.StartedAt,
			&i.CompletedAt,
			&i.CancelledAt,
			&i.CancellationReason,
			&i.StripePaymentIntentID,
			&i.PaymentStatus,
			&i.PaidAt,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.RecurringGroupID,
			&i.OccurrenceNumber,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const insertRecurringGroupExtra = `-- name: InsertRecurringGroupExtra :exec
INSERT INTO recurring_group_extras (group_id, extra_id, quantity)
VALUES ($1, $2, $3)
`

type InsertRecurringGroupExtraParams struct {
	GroupID  pgtype.UUID `json:"group_id"`
	ExtraID  pgtype.UUID `json:"extra_id"`
	Quantity pgtype.Int4 `json:"quantity"`
}

func (q *Queries) InsertRecurringGroupExtra(ctx context.Context, arg InsertRecurringGroupExtraParams) error {
	_, err := q.db.Exec(ctx, insertRecurringGroupExtra, arg.GroupID, arg.ExtraID, arg.Quantity)
	return err
}

const listActiveRecurringGroupsByClient = `-- name: ListActiveRecurringGroupsByClient :many
SELECT id, client_user_id, company_id, preferred_cleaner_id, address_id, recurrence_type, day_of_week, preferred_time, service_type, property_type, num_rooms, num_bathrooms, area_sqm, has_pets, special_instructions, hourly_rate, estimated_total_per_occurrence, is_active, cancelled_at, cancellation_reason, created_at, updated_at FROM recurring_booking_groups
WHERE client_user_id = $1 AND is_active = TRUE
ORDER BY created_at DESC
`

func (q *Queries) ListActiveRecurringGroupsByClient(ctx context.Context, clientUserID pgtype.UUID) ([]RecurringBookingGroup, error) {
	rows, err := q.db.Query(ctx, listActiveRecurringGroupsByClient, clientUserID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []RecurringBookingGroup
	for rows.Next() {
		var i RecurringBookingGroup
		if err := rows.Scan(
			&i.ID,
			&i.ClientUserID,
			&i.CompanyID,
			&i.PreferredCleanerID,
			&i.AddressID,
			&i.RecurrenceType,
			&i.DayOfWeek,
			&i.PreferredTime,
			&i.ServiceType,
			&i.PropertyType,
			&i.NumRooms,
			&i.NumBathrooms,
			&i.AreaSqm,
			&i.HasPets,
			&i.SpecialInstructions,
			&i.HourlyRate,
			&i.EstimatedTotalPerOccurrence,
			&i.IsActive,
			&i.CancelledAt,
			&i.CancellationReason,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listRecurringGroupsByClient = `-- name: ListRecurringGroupsByClient :many
SELECT id, client_user_id, company_id, preferred_cleaner_id, address_id, recurrence_type, day_of_week, preferred_time, service_type, property_type, num_rooms, num_bathrooms, area_sqm, has_pets, special_instructions, hourly_rate, estimated_total_per_occurrence, is_active, cancelled_at, cancellation_reason, created_at, updated_at FROM recurring_booking_groups
WHERE client_user_id = $1
ORDER BY created_at DESC
`

func (q *Queries) ListRecurringGroupsByClient(ctx context.Context, clientUserID pgtype.UUID) ([]RecurringBookingGroup, error) {
	rows, err := q.db.Query(ctx, listRecurringGroupsByClient, clientUserID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []RecurringBookingGroup
	for rows.Next() {
		var i RecurringBookingGroup
		if err := rows.Scan(
			&i.ID,
			&i.ClientUserID,
			&i.CompanyID,
			&i.PreferredCleanerID,
			&i.AddressID,
			&i.RecurrenceType,
			&i.DayOfWeek,
			&i.PreferredTime,
			&i.ServiceType,
			&i.PropertyType,
			&i.NumRooms,
			&i.NumBathrooms,
			&i.AreaSqm,
			&i.HasPets,
			&i.SpecialInstructions,
			&i.HourlyRate,
			&i.EstimatedTotalPerOccurrence,
			&i.IsActive,
			&i.CancelledAt,
			&i.CancellationReason,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const pauseRecurringGroup = `-- name: PauseRecurringGroup :one
UPDATE recurring_booking_groups
SET is_active = FALSE, updated_at = NOW()
WHERE id = $1 RETURNING id, client_user_id, company_id, preferred_cleaner_id, address_id, recurrence_type, day_of_week, preferred_time, service_type, property_type, num_rooms, num_bathrooms, area_sqm, has_pets, special_instructions, hourly_rate, estimated_total_per_occurrence, is_active, cancelled_at, cancellation_reason, created_at, updated_at
`

func (q *Queries) PauseRecurringGroup(ctx context.Context, id pgtype.UUID) (RecurringBookingGroup, error) {
	row := q.db.QueryRow(ctx, pauseRecurringGroup, id)
	var i RecurringBookingGroup
	err := row.Scan(
		&i.ID,
		&i.ClientUserID,
		&i.CompanyID,
		&i.PreferredCleanerID,
		&i.AddressID,
		&i.RecurrenceType,
		&i.DayOfWeek,
		&i.PreferredTime,
		&i.ServiceType,
		&i.PropertyType,
		&i.NumRooms,
		&i.NumBathrooms,
		&i.AreaSqm,
		&i.HasPets,
		&i.SpecialInstructions,
		&i.HourlyRate,
		&i.EstimatedTotalPerOccurrence,
		&i.IsActive,
		&i.CancelledAt,
		&i.CancellationReason,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const resumeRecurringGroup = `-- name: ResumeRecurringGroup :one
UPDATE recurring_booking_groups
SET is_active = TRUE, cancelled_at = NULL, cancellation_reason = NULL, updated_at = NOW()
WHERE id = $1 RETURNING id, client_user_id, company_id, preferred_cleaner_id, address_id, recurrence_type, day_of_week, preferred_time, service_type, property_type, num_rooms, num_bathrooms, area_sqm, has_pets, special_instructions, hourly_rate, estimated_total_per_occurrence, is_active, cancelled_at, cancellation_reason, created_at, updated_at
`

func (q *Queries) ResumeRecurringGroup(ctx context.Context, id pgtype.UUID) (RecurringBookingGroup, error) {
	row := q.db.QueryRow(ctx, resumeRecurringGroup, id)
	var i RecurringBookingGroup
	err := row.Scan(
		&i.ID,
		&i.ClientUserID,
		&i.CompanyID,
		&i.PreferredCleanerID,
		&i.AddressID,
		&i.RecurrenceType,
		&i.DayOfWeek,
		&i.PreferredTime,
		&i.ServiceType,
		&i.PropertyType,
		&i.NumRooms,
		&i.NumBathrooms,
		&i.AreaSqm,
		&i.HasPets,
		&i.SpecialInstructions,
		&i.HourlyRate,
		&i.EstimatedTotalPerOccurrence,
		&i.IsActive,
		&i.CancelledAt,
		&i.CancellationReason,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
