package resolver

// This file will be automatically regenerated based on the schema, any resolver
// implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.86

import (
	"context"
	"errors"
	"fmt"
	"helpmeclean-backend/internal/auth"
	db "helpmeclean-backend/internal/db/generated"
	"helpmeclean-backend/internal/graph/model"
	"helpmeclean-backend/internal/middleware"
	"os"
	"strings"

	pgx "github.com/jackc/pgx/v5"
	"github.com/jackc/pgx/v5/pgtype"
)

// SignInWithGoogle is the resolver for the signInWithGoogle field.
func (r *mutationResolver) SignInWithGoogle(ctx context.Context, idToken string, role model.UserRole) (*model.AuthPayload, error) {
	googleInfo, err := auth.VerifyGoogleIDToken(idToken)
	if err != nil {
		return nil, fmt.Errorf("failed to verify Google ID token: %w", err)
	}

	// Try to find existing user by Google ID.
	googleIDText := pgtype.Text{String: googleInfo.GoogleID, Valid: true}
	existingUser, err := r.Queries.GetUserByGoogleID(ctx, googleIDText)
	if err == nil {
		// User already exists, generate token and return.
		token, err := auth.GenerateToken(
			uuidToString(existingUser.ID),
			existingUser.Email,
			string(existingUser.Role),
		)
		if err != nil {
			return nil, fmt.Errorf("failed to generate token: %w", err)
		}

		// Set httpOnly cookie (new secure method)
		if w := middleware.GetResponseWriter(ctx); w != nil {
			auth.SetAuthCookie(w, token)
		}

		return &model.AuthPayload{
			Token:     token, // Still return token for backward compatibility (will be removed after migration)
			User:      dbUserToGQL(existingUser),
			IsNewUser: false,
		}, nil
	}

	// Try finding by email.
	existingUser, err = r.Queries.GetUserByEmail(ctx, googleInfo.Email)
	if err == nil {
		// User exists with this email but different Google ID -- generate token.
		token, err := auth.GenerateToken(
			uuidToString(existingUser.ID),
			existingUser.Email,
			string(existingUser.Role),
		)
		if err != nil {
			return nil, fmt.Errorf("failed to generate token: %w", err)
		}

		// Set httpOnly cookie (new secure method)
		if w := middleware.GetResponseWriter(ctx); w != nil {
			auth.SetAuthCookie(w, token)
		}

		return &model.AuthPayload{
			Token:     token, // Still return token for backward compatibility (will be removed after migration)
			User:      dbUserToGQL(existingUser),
			IsNewUser: false,
		}, nil
	}

	// Create new user.
	dbRole := gqlUserRoleToDb(role)
	newUser, err := r.Queries.CreateUser(ctx, db.CreateUserParams{
		Email:    googleInfo.Email,
		FullName: googleInfo.FullName,
		AvatarUrl: pgtype.Text{
			String: googleInfo.AvatarURL,
			Valid:  googleInfo.AvatarURL != "",
		},
		Role:              dbRole,
		Status:            db.UserStatusActive,
		GoogleID:          googleIDText,
		PreferredLanguage: pgtype.Text{String: "ro", Valid: true},
	})
	if err != nil {
		return nil, fmt.Errorf("failed to create user: %w", err)
	}

	token, err := auth.GenerateToken(
		uuidToString(newUser.ID),
		newUser.Email,
		string(newUser.Role),
	)
	if err != nil {
		return nil, fmt.Errorf("failed to generate token: %w", err)
	}

	// Set httpOnly cookie (new secure method)
	if w := middleware.GetResponseWriter(ctx); w != nil {
		auth.SetAuthCookie(w, token)
	}

	return &model.AuthPayload{
		Token:     token, // Still return token for backward compatibility (will be removed after migration)
		User:      dbUserToGQL(newUser),
		IsNewUser: true,
	}, nil
}

// RefreshToken is the resolver for the refreshToken field.
func (r *mutationResolver) RefreshToken(ctx context.Context) (*model.AuthPayload, error) {
	claims := auth.GetUserFromContext(ctx)
	if claims == nil {
		return nil, fmt.Errorf("not authenticated")
	}

	dbUser, err := r.Queries.GetUserByID(ctx, stringToUUID(claims.UserID))
	if err != nil {
		return nil, fmt.Errorf("user not found: %w", err)
	}

	token, err := auth.GenerateToken(
		uuidToString(dbUser.ID),
		dbUser.Email,
		string(dbUser.Role),
	)
	if err != nil {
		return nil, fmt.Errorf("failed to generate token: %w", err)
	}

	// Set httpOnly cookie (new secure method)
	if w := middleware.GetResponseWriter(ctx); w != nil {
		auth.SetAuthCookie(w, token)
	}

	return &model.AuthPayload{
		Token:     token, // Still return token for backward compatibility (will be removed after migration)
		User:      dbUserToGQL(dbUser),
		IsNewUser: false,
	}, nil
}

// RegisterDeviceToken is the resolver for the registerDeviceToken field.
func (r *mutationResolver) RegisterDeviceToken(ctx context.Context, token string) (bool, error) {
	claims := auth.GetUserFromContext(ctx)
	if claims == nil {
		return false, fmt.Errorf("not authenticated")
	}

	err := r.Queries.UpdateUserFCMToken(ctx, db.UpdateUserFCMTokenParams{
		ID:       stringToUUID(claims.UserID),
		FcmToken: pgtype.Text{String: token, Valid: true},
	})
	if err != nil {
		return false, fmt.Errorf("failed to register device token: %w", err)
	}

	return true, nil
}

// Logout is the resolver for the logout field.
func (r *mutationResolver) Logout(ctx context.Context) (bool, error) {
	// Clear the httpOnly cookie
	if w := middleware.GetResponseWriter(ctx); w != nil {
		auth.ClearAuthCookie(w)
		return true, nil
	}
	return false, fmt.Errorf("unable to clear authentication cookie")
}

// RequestEmailOtp is the resolver for the requestEmailOtp field.
func (r *mutationResolver) RequestEmailOtp(ctx context.Context, email string, role model.UserRole) (*model.RequestOtpResponse, error) {
	email = strings.ToLower(strings.TrimSpace(email))
	if email == "" {
		return nil, fmt.Errorf("email is required")
	}

	// Rate-limit: max 3 active (unexpired, unused) codes per email per 10-minute window.
	count, err := r.Queries.CountActiveEmailOTPs(ctx, email)
	if err != nil {
		return nil, fmt.Errorf("failed to check rate limit: %w", err)
	}
	if count >= 3 {
		return nil, fmt.Errorf("prea multe cereri — așteptați înainte de a solicita un cod nou")
	}

	code, err := generateOTPCode()
	if err != nil {
		return nil, fmt.Errorf("failed to generate OTP: %w", err)
	}

	dbRole := strings.ToLower(string(gqlUserRoleToDb(role)))
	if _, err := r.Queries.CreateEmailOTP(ctx, db.CreateEmailOTPParams{
		Email: email,
		Code:  code,
		Role:  dbRole,
	}); err != nil {
		return nil, fmt.Errorf("failed to save OTP: %w", err)
	}

	skipped, err := r.EmailService.SendOTP(email, code)
	if err != nil {
		return nil, fmt.Errorf("failed to send OTP email: %w", err)
	}

	// In non-production (or when SMTP is unconfigured), expose the code so developers
	// can test without a real mail server.
	var devCode *string
	if skipped || os.Getenv("ENVIRONMENT") != "production" {
		devCode = &code
	}

	return &model.RequestOtpResponse{
		Success: true,
		DevCode: devCode,
	}, nil
}

// VerifyEmailOtp is the resolver for the verifyEmailOtp field.
func (r *mutationResolver) VerifyEmailOtp(ctx context.Context, email string, code string, role model.UserRole) (*model.AuthPayload, error) {
	email = strings.ToLower(strings.TrimSpace(email))
	code = strings.TrimSpace(code)

	if len(code) != 6 {
		return nil, fmt.Errorf("codul OTP trebuie să aibă exact 6 cifre")
	}

	otpRow, err := r.Queries.GetValidEmailOTP(ctx, db.GetValidEmailOTPParams{
		Email: email,
		Code:  code,
	})
	if err != nil {
		if errors.Is(err, pgx.ErrNoRows) {
			return nil, fmt.Errorf("cod invalid sau expirat")
		}
		return nil, fmt.Errorf("failed to validate OTP: %w", err)
	}

	// Mark as used immediately to prevent replay attacks.
	if err := r.Queries.MarkEmailOTPUsed(ctx, otpRow.ID); err != nil {
		return nil, fmt.Errorf("failed to consume OTP: %w", err)
	}

	// Find or create the user.
	dbUser, err := r.Queries.GetUserByEmail(ctx, email)
	isNewUser := false
	if err != nil {
		if !errors.Is(err, pgx.ErrNoRows) {
			return nil, fmt.Errorf("failed to look up user: %w", err)
		}
		// First-time login — create the user.
		isNewUser = true
		dbUser, err = r.Queries.CreateUser(ctx, db.CreateUserParams{
			Email:             email,
			FullName:          emailPrefix(email),
			Role:              gqlUserRoleToDb(role),
			Status:            db.UserStatusActive,
			PreferredLanguage: pgtype.Text{String: "ro", Valid: true},
		})
		if err != nil {
			return nil, fmt.Errorf("failed to create user: %w", err)
		}
	}

	token, err := auth.GenerateToken(
		uuidToString(dbUser.ID),
		dbUser.Email,
		string(dbUser.Role),
	)
	if err != nil {
		return nil, fmt.Errorf("failed to generate token: %w", err)
	}

	if w := middleware.GetResponseWriter(ctx); w != nil {
		auth.SetAuthCookie(w, token)
	}

	return &model.AuthPayload{
		Token:     token,
		User:      dbUserToGQL(dbUser),
		IsNewUser: isNewUser,
	}, nil
}
