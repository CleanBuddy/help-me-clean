package resolver

// This file will be automatically regenerated based on the schema, any resolver
// implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.86

import (
	"context"
	"fmt"
	"helpmeclean-backend/internal/auth"
	db "helpmeclean-backend/internal/db/generated"
	"helpmeclean-backend/internal/graph/model"

	"github.com/jackc/pgx/v5/pgtype"
)

// SignInWithGoogle is the resolver for the signInWithGoogle field.
func (r *mutationResolver) SignInWithGoogle(ctx context.Context, idToken string, role model.UserRole) (*model.AuthPayload, error) {
	googleInfo, err := auth.VerifyGoogleIDToken(idToken)
	if err != nil {
		return nil, fmt.Errorf("failed to verify Google ID token: %w", err)
	}

	// Try to find existing user by Google ID.
	googleIDText := pgtype.Text{String: googleInfo.GoogleID, Valid: true}
	existingUser, err := r.Queries.GetUserByGoogleID(ctx, googleIDText)
	if err == nil {
		// User already exists, generate token and return.
		token, err := auth.GenerateToken(
			uuidToString(existingUser.ID),
			existingUser.Email,
			string(existingUser.Role),
		)
		if err != nil {
			return nil, fmt.Errorf("failed to generate token: %w", err)
		}
		return &model.AuthPayload{
			Token:     token,
			User:      dbUserToGQL(existingUser),
			IsNewUser: false,
		}, nil
	}

	// Try finding by email.
	existingUser, err = r.Queries.GetUserByEmail(ctx, googleInfo.Email)
	if err == nil {
		// User exists with this email but different Google ID -- generate token.
		token, err := auth.GenerateToken(
			uuidToString(existingUser.ID),
			existingUser.Email,
			string(existingUser.Role),
		)
		if err != nil {
			return nil, fmt.Errorf("failed to generate token: %w", err)
		}
		return &model.AuthPayload{
			Token:     token,
			User:      dbUserToGQL(existingUser),
			IsNewUser: false,
		}, nil
	}

	// Create new user.
	dbRole := gqlUserRoleToDb(role)
	newUser, err := r.Queries.CreateUser(ctx, db.CreateUserParams{
		Email:    googleInfo.Email,
		FullName: googleInfo.FullName,
		AvatarUrl: pgtype.Text{
			String: googleInfo.AvatarURL,
			Valid:  googleInfo.AvatarURL != "",
		},
		Role:              dbRole,
		Status:            db.UserStatusActive,
		GoogleID:          googleIDText,
		PreferredLanguage: pgtype.Text{String: "ro", Valid: true},
	})
	if err != nil {
		return nil, fmt.Errorf("failed to create user: %w", err)
	}

	token, err := auth.GenerateToken(
		uuidToString(newUser.ID),
		newUser.Email,
		string(newUser.Role),
	)
	if err != nil {
		return nil, fmt.Errorf("failed to generate token: %w", err)
	}

	return &model.AuthPayload{
		Token:     token,
		User:      dbUserToGQL(newUser),
		IsNewUser: true,
	}, nil
}

// RefreshToken is the resolver for the refreshToken field.
func (r *mutationResolver) RefreshToken(ctx context.Context) (*model.AuthPayload, error) {
	claims := auth.GetUserFromContext(ctx)
	if claims == nil {
		return nil, fmt.Errorf("not authenticated")
	}

	dbUser, err := r.Queries.GetUserByID(ctx, stringToUUID(claims.UserID))
	if err != nil {
		return nil, fmt.Errorf("user not found: %w", err)
	}

	token, err := auth.GenerateToken(
		uuidToString(dbUser.ID),
		dbUser.Email,
		string(dbUser.Role),
	)
	if err != nil {
		return nil, fmt.Errorf("failed to generate token: %w", err)
	}

	return &model.AuthPayload{
		Token:     token,
		User:      dbUserToGQL(dbUser),
		IsNewUser: false,
	}, nil
}

// RegisterDeviceToken is the resolver for the registerDeviceToken field.
func (r *mutationResolver) RegisterDeviceToken(ctx context.Context, token string) (bool, error) {
	claims := auth.GetUserFromContext(ctx)
	if claims == nil {
		return false, fmt.Errorf("not authenticated")
	}

	err := r.Queries.UpdateUserFCMToken(ctx, db.UpdateUserFCMTokenParams{
		ID:       stringToUUID(claims.UserID),
		FcmToken: pgtype.Text{String: token, Valid: true},
	})
	if err != nil {
		return false, fmt.Errorf("failed to register device token: %w", err)
	}

	return true, nil
}
