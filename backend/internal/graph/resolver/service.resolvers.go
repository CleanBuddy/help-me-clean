package resolver

// This file will be automatically regenerated based on the schema, any resolver
// implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.86

import (
	"context"
	"fmt"
	"helpmeclean-backend/internal/auth"
	db "helpmeclean-backend/internal/db/generated"
	"helpmeclean-backend/internal/graph/model"
	"strings"

	"github.com/jackc/pgx/v5/pgtype"
)

// UpdateServiceDefinition is the resolver for the updateServiceDefinition field.
func (r *mutationResolver) UpdateServiceDefinition(ctx context.Context, input model.UpdateServiceDefinitionInput) (*model.ServiceDefinition, error) {
	claims := auth.GetUserFromContext(ctx)
	if claims == nil || claims.Role != "global_admin" {
		return nil, fmt.Errorf("not authorized")
	}

	updated, err := r.Queries.UpdateServiceDefinition(ctx, db.UpdateServiceDefinitionParams{
		ID:                 stringToUUID(input.ID),
		NameRo:             input.NameRo,
		NameEn:             input.NameEn,
		BasePricePerHour:   float64ToNumeric(input.BasePricePerHour),
		MinHours:           float64ToNumeric(input.MinHours),
		HoursPerRoom:       float64ToNumeric(input.HoursPerRoom),
		HoursPerBathroom:   float64ToNumeric(input.HoursPerBathroom),
		HoursPer100Sqm:     float64ToNumeric(input.HoursPer100Sqm),
		HouseMultiplier:    float64ToNumeric(input.HouseMultiplier),
		PetDurationMinutes: int32(input.PetDurationMinutes),
		IsActive:           pgtype.Bool{Bool: input.IsActive, Valid: true},
	})
	if err != nil {
		return nil, fmt.Errorf("failed to update service definition: %w", err)
	}

	return dbServiceDefToGQL(updated), nil
}

// CreateServiceDefinition is the resolver for the createServiceDefinition field.
func (r *mutationResolver) CreateServiceDefinition(ctx context.Context, input model.CreateServiceDefinitionInput) (*model.ServiceDefinition, error) {
	claims := auth.GetUserFromContext(ctx)
	if claims == nil || claims.Role != "global_admin" {
		return nil, fmt.Errorf("not authorized")
	}

	created, err := r.Queries.CreateServiceDefinition(ctx, db.CreateServiceDefinitionParams{
		ServiceType:        gqlServiceTypeToDb(input.ServiceType),
		NameRo:             input.NameRo,
		NameEn:             input.NameEn,
		BasePricePerHour:   float64ToNumeric(input.BasePricePerHour),
		MinHours:           float64ToNumeric(input.MinHours),
		HoursPerRoom:       float64ToNumeric(input.HoursPerRoom),
		HoursPerBathroom:   float64ToNumeric(input.HoursPerBathroom),
		HoursPer100Sqm:     float64ToNumeric(input.HoursPer100Sqm),
		HouseMultiplier:    float64ToNumeric(input.HouseMultiplier),
		PetDurationMinutes: int32(input.PetDurationMinutes),
		IsActive:           pgtype.Bool{Bool: input.IsActive, Valid: true},
	})
	if err != nil {
		return nil, fmt.Errorf("failed to create service definition: %w", err)
	}

	return dbServiceDefToGQL(created), nil
}

// UpdateServiceExtra is the resolver for the updateServiceExtra field.
func (r *mutationResolver) UpdateServiceExtra(ctx context.Context, input model.UpdateServiceExtraInput) (*model.ServiceExtra, error) {
	claims := auth.GetUserFromContext(ctx)
	if claims == nil || claims.Role != "global_admin" {
		return nil, fmt.Errorf("not authorized")
	}

	updated, err := r.Queries.UpdateServiceExtra(ctx, db.UpdateServiceExtraParams{
		ID:              stringToUUID(input.ID),
		NameRo:          input.NameRo,
		NameEn:          input.NameEn,
		Price:           float64ToNumeric(input.Price),
		DurationMinutes: int32(input.DurationMinutes),
		IsActive:        pgtype.Bool{Bool: input.IsActive, Valid: true},
	})
	if err != nil {
		return nil, fmt.Errorf("failed to update service extra: %w", err)
	}

	return dbServiceExtraToGQL(updated), nil
}

// CreateServiceExtra is the resolver for the createServiceExtra field.
func (r *mutationResolver) CreateServiceExtra(ctx context.Context, input model.CreateServiceExtraInput) (*model.ServiceExtra, error) {
	claims := auth.GetUserFromContext(ctx)
	if claims == nil || claims.Role != "global_admin" {
		return nil, fmt.Errorf("not authorized")
	}

	created, err := r.Queries.CreateServiceExtra(ctx, db.CreateServiceExtraParams{
		NameRo:          input.NameRo,
		NameEn:          input.NameEn,
		Price:           float64ToNumeric(input.Price),
		DurationMinutes: int32(input.DurationMinutes),
		IsActive:        pgtype.Bool{Bool: input.IsActive, Valid: true},
	})
	if err != nil {
		return nil, fmt.Errorf("failed to create service extra: %w", err)
	}

	return dbServiceExtraToGQL(created), nil
}

// AvailableServices is the resolver for the availableServices field.
func (r *queryResolver) AvailableServices(ctx context.Context) ([]*model.ServiceDefinition, error) {
	services, err := r.Queries.ListActiveServices(ctx)
	if err != nil {
		return nil, fmt.Errorf("failed to list services: %w", err)
	}

	result := make([]*model.ServiceDefinition, len(services))
	for i, s := range services {
		result[i] = dbServiceDefToGQL(s)
	}
	return result, nil
}

// AvailableExtras is the resolver for the availableExtras field.
func (r *queryResolver) AvailableExtras(ctx context.Context) ([]*model.ServiceExtra, error) {
	extras, err := r.Queries.ListActiveExtras(ctx)
	if err != nil {
		return nil, fmt.Errorf("failed to list extras: %w", err)
	}

	result := make([]*model.ServiceExtra, len(extras))
	for i, e := range extras {
		result[i] = dbServiceExtraToGQL(e)
	}
	return result, nil
}

// EstimatePrice is the resolver for the estimatePrice field.
func (r *queryResolver) EstimatePrice(ctx context.Context, input model.PriceEstimateInput) (*model.PriceEstimate, error) {
	dbServiceType := gqlServiceTypeToDb(input.ServiceType)
	serviceDef, err := r.Queries.GetServiceByType(ctx, dbServiceType)
	if err != nil {
		return nil, fmt.Errorf("service type not found: %w", err)
	}

	hourlyRate := numericToFloat(serviceDef.BasePricePerHour)

	// Fetch extras and build duration info.
	var extraLineItems []*model.ExtraLineItem
	extrasTotal := 0.0
	var extrasDuration []struct {
		DurationMinutes int32
		Quantity        int
	}
	if input.Extras != nil {
		for _, extraInput := range input.Extras {
			extra, err := r.Queries.GetExtraByID(ctx, stringToUUID(extraInput.ExtraID))
			if err != nil {
				return nil, fmt.Errorf("extra not found: %w", err)
			}
			price := numericToFloat(extra.Price)
			lineTotal := price * float64(extraInput.Quantity)
			extrasTotal += lineTotal
			extraLineItems = append(extraLineItems, &model.ExtraLineItem{
				Extra:     dbServiceExtraToGQL(extra),
				Quantity:  extraInput.Quantity,
				LineTotal: lineTotal,
			})
			extrasDuration = append(extrasDuration, struct {
				DurationMinutes int32
				Quantity        int
			}{DurationMinutes: extra.DurationMinutes, Quantity: extraInput.Quantity})
		}
	}

	// Estimate duration using DB-driven parameters.
	estimatedHours := estimateDuration(serviceDef, input.NumRooms, input.NumBathrooms, input.AreaSqm, input.PropertyType, input.HasPets, extrasDuration)

	// Property type multiplier for price display.
	propertyMultiplier := 1.0
	if input.PropertyType != nil {
		switch strings.ToLower(*input.PropertyType) {
		case "casa", "house":
			propertyMultiplier = numericToFloat(serviceDef.HouseMultiplier)
		}
	}

	subtotal := hourlyRate * estimatedHours

	// Pets surcharge (flat fee on top of duration).
	petsSurcharge := 0.0
	if input.HasPets != nil && *input.HasPets {
		petsSurcharge = 15.0
	}

	total := subtotal + extrasTotal + petsSurcharge

	return &model.PriceEstimate{
		HourlyRate:         hourlyRate,
		EstimatedHours:     estimatedHours,
		PropertyMultiplier: propertyMultiplier,
		PetsSurcharge:      petsSurcharge,
		Subtotal:           subtotal,
		Extras:             extraLineItems,
		Total:              total,
	}, nil
}

// AllServices is the resolver for the allServices field.
func (r *queryResolver) AllServices(ctx context.Context) ([]*model.ServiceDefinition, error) {
	claims := auth.GetUserFromContext(ctx)
	if claims == nil || claims.Role != "global_admin" {
		return nil, fmt.Errorf("not authorized")
	}

	services, err := r.Queries.ListAllServices(ctx)
	if err != nil {
		return nil, fmt.Errorf("failed to list all services: %w", err)
	}

	result := make([]*model.ServiceDefinition, len(services))
	for i, s := range services {
		result[i] = dbServiceDefToGQL(s)
	}
	return result, nil
}

// AllExtras is the resolver for the allExtras field.
func (r *queryResolver) AllExtras(ctx context.Context) ([]*model.ServiceExtra, error) {
	claims := auth.GetUserFromContext(ctx)
	if claims == nil || claims.Role != "global_admin" {
		return nil, fmt.Errorf("not authorized")
	}

	extras, err := r.Queries.ListAllExtras(ctx)
	if err != nil {
		return nil, fmt.Errorf("failed to list all extras: %w", err)
	}

	result := make([]*model.ServiceExtra, len(extras))
	for i, e := range extras {
		result[i] = dbServiceExtraToGQL(e)
	}
	return result, nil
}
