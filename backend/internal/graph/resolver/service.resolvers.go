package resolver

// This file will be automatically regenerated based on the schema, any resolver
// implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.86

import (
	"context"
	"fmt"
	"helpmeclean-backend/internal/auth"
	db "helpmeclean-backend/internal/db/generated"
	"helpmeclean-backend/internal/graph/model"
	"math"

	"github.com/jackc/pgx/v5/pgtype"
)

// UpdateServiceDefinition is the resolver for the updateServiceDefinition field.
func (r *mutationResolver) UpdateServiceDefinition(ctx context.Context, input model.UpdateServiceDefinitionInput) (*model.ServiceDefinition, error) {
	claims := auth.GetUserFromContext(ctx)
	if claims == nil || claims.Role != "global_admin" {
		return nil, fmt.Errorf("not authorized")
	}

	updated, err := r.Queries.UpdateServiceDefinition(ctx, db.UpdateServiceDefinitionParams{
		ID:               stringToUUID(input.ID),
		NameRo:           input.NameRo,
		NameEn:           input.NameEn,
		BasePricePerHour: float64ToNumeric(input.BasePricePerHour),
		MinHours:         float64ToNumeric(input.MinHours),
		IsActive:         pgtype.Bool{Bool: input.IsActive, Valid: true},
	})
	if err != nil {
		return nil, fmt.Errorf("failed to update service definition: %w", err)
	}

	return dbServiceDefToGQL(updated), nil
}

// CreateServiceDefinition is the resolver for the createServiceDefinition field.
func (r *mutationResolver) CreateServiceDefinition(ctx context.Context, input model.CreateServiceDefinitionInput) (*model.ServiceDefinition, error) {
	claims := auth.GetUserFromContext(ctx)
	if claims == nil || claims.Role != "global_admin" {
		return nil, fmt.Errorf("not authorized")
	}

	created, err := r.Queries.CreateServiceDefinition(ctx, db.CreateServiceDefinitionParams{
		ServiceType:      gqlServiceTypeToDb(input.ServiceType),
		NameRo:           input.NameRo,
		NameEn:           input.NameEn,
		BasePricePerHour: float64ToNumeric(input.BasePricePerHour),
		MinHours:         float64ToNumeric(input.MinHours),
		IsActive:         pgtype.Bool{Bool: input.IsActive, Valid: true},
	})
	if err != nil {
		return nil, fmt.Errorf("failed to create service definition: %w", err)
	}

	return dbServiceDefToGQL(created), nil
}

// UpdateServiceExtra is the resolver for the updateServiceExtra field.
func (r *mutationResolver) UpdateServiceExtra(ctx context.Context, input model.UpdateServiceExtraInput) (*model.ServiceExtra, error) {
	claims := auth.GetUserFromContext(ctx)
	if claims == nil || claims.Role != "global_admin" {
		return nil, fmt.Errorf("not authorized")
	}

	updated, err := r.Queries.UpdateServiceExtra(ctx, db.UpdateServiceExtraParams{
		ID:       stringToUUID(input.ID),
		NameRo:   input.NameRo,
		NameEn:   input.NameEn,
		Price:    float64ToNumeric(input.Price),
		IsActive: pgtype.Bool{Bool: input.IsActive, Valid: true},
	})
	if err != nil {
		return nil, fmt.Errorf("failed to update service extra: %w", err)
	}

	return dbServiceExtraToGQL(updated), nil
}

// CreateServiceExtra is the resolver for the createServiceExtra field.
func (r *mutationResolver) CreateServiceExtra(ctx context.Context, input model.CreateServiceExtraInput) (*model.ServiceExtra, error) {
	claims := auth.GetUserFromContext(ctx)
	if claims == nil || claims.Role != "global_admin" {
		return nil, fmt.Errorf("not authorized")
	}

	created, err := r.Queries.CreateServiceExtra(ctx, db.CreateServiceExtraParams{
		NameRo:   input.NameRo,
		NameEn:   input.NameEn,
		Price:    float64ToNumeric(input.Price),
		IsActive: pgtype.Bool{Bool: input.IsActive, Valid: true},
	})
	if err != nil {
		return nil, fmt.Errorf("failed to create service extra: %w", err)
	}

	return dbServiceExtraToGQL(created), nil
}

// AvailableServices is the resolver for the availableServices field.
func (r *queryResolver) AvailableServices(ctx context.Context) ([]*model.ServiceDefinition, error) {
	services, err := r.Queries.ListActiveServices(ctx)
	if err != nil {
		return nil, fmt.Errorf("failed to list services: %w", err)
	}

	result := make([]*model.ServiceDefinition, len(services))
	for i, s := range services {
		result[i] = dbServiceDefToGQL(s)
	}
	return result, nil
}

// AvailableExtras is the resolver for the availableExtras field.
func (r *queryResolver) AvailableExtras(ctx context.Context) ([]*model.ServiceExtra, error) {
	extras, err := r.Queries.ListActiveExtras(ctx)
	if err != nil {
		return nil, fmt.Errorf("failed to list extras: %w", err)
	}

	result := make([]*model.ServiceExtra, len(extras))
	for i, e := range extras {
		result[i] = dbServiceExtraToGQL(e)
	}
	return result, nil
}

// EstimatePrice is the resolver for the estimatePrice field.
func (r *queryResolver) EstimatePrice(ctx context.Context, input model.PriceEstimateInput) (*model.PriceEstimate, error) {
	dbServiceType := gqlServiceTypeToDb(input.ServiceType)
	serviceDef, err := r.Queries.GetServiceByType(ctx, dbServiceType)
	if err != nil {
		return nil, fmt.Errorf("service type not found: %w", err)
	}

	hourlyRate := numericToFloat(serviceDef.BasePricePerHour)
	minHours := numericToFloat(serviceDef.MinHours)

	// Estimate hours based on rooms and bathrooms.
	estimatedHours := float64(input.NumRooms)*0.5 + float64(input.NumBathrooms)*0.5
	if input.AreaSqm != nil {
		estimatedHours += float64(*input.AreaSqm) / 100.0
	}
	if estimatedHours < minHours {
		estimatedHours = minHours
	}
	// Round to nearest 0.5.
	estimatedHours = math.Round(estimatedHours*2) / 2

	subtotal := hourlyRate * estimatedHours

	// Calculate extras.
	var extraLineItems []*model.ExtraLineItem
	extrasTotal := 0.0
	if input.Extras != nil {
		for _, extraInput := range input.Extras {
			extra, err := r.Queries.GetExtraByID(ctx, stringToUUID(extraInput.ExtraID))
			if err != nil {
				return nil, fmt.Errorf("extra not found: %w", err)
			}
			price := numericToFloat(extra.Price)
			lineTotal := price * float64(extraInput.Quantity)
			extrasTotal += lineTotal
			extraLineItems = append(extraLineItems, &model.ExtraLineItem{
				Extra:     dbServiceExtraToGQL(extra),
				Quantity:  extraInput.Quantity,
				LineTotal: lineTotal,
			})
		}
	}

	total := subtotal + extrasTotal

	return &model.PriceEstimate{
		HourlyRate:     hourlyRate,
		EstimatedHours: estimatedHours,
		Subtotal:       subtotal,
		Extras:         extraLineItems,
		Total:          total,
	}, nil
}

// AllServices is the resolver for the allServices field.
func (r *queryResolver) AllServices(ctx context.Context) ([]*model.ServiceDefinition, error) {
	claims := auth.GetUserFromContext(ctx)
	if claims == nil || claims.Role != "global_admin" {
		return nil, fmt.Errorf("not authorized")
	}

	services, err := r.Queries.ListAllServices(ctx)
	if err != nil {
		return nil, fmt.Errorf("failed to list all services: %w", err)
	}

	result := make([]*model.ServiceDefinition, len(services))
	for i, s := range services {
		result[i] = dbServiceDefToGQL(s)
	}
	return result, nil
}

// AllExtras is the resolver for the allExtras field.
func (r *queryResolver) AllExtras(ctx context.Context) ([]*model.ServiceExtra, error) {
	claims := auth.GetUserFromContext(ctx)
	if claims == nil || claims.Role != "global_admin" {
		return nil, fmt.Errorf("not authorized")
	}

	extras, err := r.Queries.ListAllExtras(ctx)
	if err != nil {
		return nil, fmt.Errorf("failed to list all extras: %w", err)
	}

	result := make([]*model.ServiceExtra, len(extras))
	for i, e := range extras {
		result[i] = dbServiceExtraToGQL(e)
	}
	return result, nil
}
