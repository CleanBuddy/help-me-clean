package resolver

// This file will be automatically regenerated based on the schema, any resolver
// implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.86

import (
	"context"
	"fmt"
	"helpmeclean-backend/internal/auth"
	db "helpmeclean-backend/internal/db/generated"
	"helpmeclean-backend/internal/graph/model"
	"strings"
	"time"

	"github.com/jackc/pgx/v5/pgtype"
)

// UpsertBillingProfile is the resolver for the upsertBillingProfile field.
func (r *mutationResolver) UpsertBillingProfile(ctx context.Context, input model.BillingProfileInput) (*model.ClientBillingProfile, error) {
	claims := auth.GetUserFromContext(ctx)
	if claims == nil {
		return nil, fmt.Errorf("not authenticated")
	}
	if claims.Role != "client" {
		return nil, fmt.Errorf("only clients can manage billing profiles")
	}

	userID := stringToUUID(claims.UserID)

	// Check if a billing profile already exists for this user.
	existing, err := r.Queries.GetBillingProfileByUser(ctx, userID)
	if err == nil {
		// Update existing profile.
		updated, updateErr := r.Queries.UpdateBillingProfile(ctx, db.UpdateBillingProfileParams{
			ID:          existing.ID,
			IsCompany:   input.IsCompany,
			CompanyName: stringToText(input.CompanyName),
			Cui:         stringToText(input.Cui),
			RegNumber:   stringToText(input.RegNumber),
			Address:     stringToText(input.Address),
			City:        stringToText(input.City),
			County:      stringToText(input.County),
			IsVatPayer:  boolToPgBool(input.IsVatPayer),
			BankName:    stringToText(input.BankName),
			Iban:        stringToText(input.Iban),
		})
		if updateErr != nil {
			return nil, fmt.Errorf("failed to update billing profile: %w", updateErr)
		}
		return dbBillingProfileToGQL(updated), nil
	}

	// Create new profile.
	created, createErr := r.Queries.CreateBillingProfile(ctx, db.CreateBillingProfileParams{
		UserID:      userID,
		IsCompany:   input.IsCompany,
		CompanyName: stringToText(input.CompanyName),
		Cui:         stringToText(input.Cui),
		RegNumber:   stringToText(input.RegNumber),
		Address:     stringToText(input.Address),
		City:        stringToText(input.City),
		County:      stringToText(input.County),
		IsVatPayer:  boolToPgBool(input.IsVatPayer),
		BankName:    stringToText(input.BankName),
		Iban:        stringToText(input.Iban),
	})
	if createErr != nil {
		return nil, fmt.Errorf("failed to create billing profile: %w", createErr)
	}
	return dbBillingProfileToGQL(created), nil
}

// GenerateBookingInvoice is the resolver for the generateBookingInvoice field.
func (r *mutationResolver) GenerateBookingInvoice(ctx context.Context, bookingID string) (*model.Invoice, error) {
	claims := auth.GetUserFromContext(ctx)
	if claims == nil {
		return nil, fmt.Errorf("not authenticated")
	}
	if claims.Role != "company_admin" {
		return nil, fmt.Errorf("only company admins can generate booking invoices")
	}

	// Load booking.
	booking, err := r.Queries.GetBookingByID(ctx, stringToUUID(bookingID))
	if err != nil {
		return nil, fmt.Errorf("booking not found: %w", err)
	}

	// Load company for this admin.
	company, err := r.Queries.GetCompanyByAdminUserID(ctx, stringToUUID(claims.UserID))
	if err != nil {
		return nil, fmt.Errorf("company not found for admin: %w", err)
	}

	// Generate the invoice via the service.
	inv, err := r.InvoiceService.GenerateClientServiceInvoice(ctx, booking, company, booking.ClientUserID)
	if err != nil {
		return nil, fmt.Errorf("failed to generate booking invoice: %w", err)
	}

	gqlInvoice := dbInvoiceToGQL(inv)
	r.enrichInvoice(ctx, inv, gqlInvoice)
	return gqlInvoice, nil
}

// CancelInvoice is the resolver for the cancelInvoice field.
func (r *mutationResolver) CancelInvoice(ctx context.Context, id string) (*model.Invoice, error) {
	claims := auth.GetUserFromContext(ctx)
	if claims == nil {
		return nil, fmt.Errorf("not authenticated")
	}
	if claims.Role != "company_admin" {
		return nil, fmt.Errorf("only company admins can cancel invoices")
	}

	inv, err := r.InvoiceService.CancelInvoice(ctx, stringToUUID(id))
	if err != nil {
		return nil, fmt.Errorf("failed to cancel invoice: %w", err)
	}

	gqlInvoice := dbInvoiceToGQL(inv)
	r.enrichInvoice(ctx, inv, gqlInvoice)
	return gqlInvoice, nil
}

// TransmitInvoiceToEFactura is the resolver for the transmitInvoiceToEFactura field.
func (r *mutationResolver) TransmitInvoiceToEFactura(ctx context.Context, id string) (*model.Invoice, error) {
	claims := auth.GetUserFromContext(ctx)
	if claims == nil {
		return nil, fmt.Errorf("not authenticated")
	}
	if claims.Role != "company_admin" {
		return nil, fmt.Errorf("only company admins can transmit invoices to e-factura")
	}

	invoiceUUID := stringToUUID(id)
	err := r.InvoiceService.TransmitToEFactura(ctx, invoiceUUID)
	if err != nil {
		return nil, fmt.Errorf("failed to transmit invoice to e-factura: %w", err)
	}

	// Reload the invoice after transmission to get updated fields.
	inv, err := r.Queries.GetInvoiceByID(ctx, invoiceUUID)
	if err != nil {
		return nil, fmt.Errorf("failed to reload invoice after e-factura transmission: %w", err)
	}

	gqlInvoice := dbInvoiceToGQL(inv)
	r.enrichInvoice(ctx, inv, gqlInvoice)
	return gqlInvoice, nil
}

// GenerateCommissionInvoice is the resolver for the generateCommissionInvoice field.
func (r *mutationResolver) GenerateCommissionInvoice(ctx context.Context, payoutID string) (*model.Invoice, error) {
	claims := auth.GetUserFromContext(ctx)
	if claims == nil {
		return nil, fmt.Errorf("not authenticated")
	}
	if claims.Role != "global_admin" {
		return nil, fmt.Errorf("only global admins can generate commission invoices")
	}

	// Load the payout to get company, amount, and period details.
	payout, err := r.Queries.GetPayoutByID(ctx, stringToUUID(payoutID))
	if err != nil {
		return nil, fmt.Errorf("payout not found: %w", err)
	}

	periodFrom := dateToString(payout.PeriodFrom)
	periodTo := dateToString(payout.PeriodTo)

	inv, err := r.InvoiceService.GenerateCommissionInvoice(
		ctx,
		payout.CompanyID,
		payout.Amount,
		int(payout.BookingCount),
		periodFrom,
		periodTo,
	)
	if err != nil {
		return nil, fmt.Errorf("failed to generate commission invoice: %w", err)
	}

	gqlInvoice := dbInvoiceToGQL(inv)
	r.enrichInvoice(ctx, inv, gqlInvoice)
	return gqlInvoice, nil
}

// GenerateCreditNote is the resolver for the generateCreditNote field.
func (r *mutationResolver) GenerateCreditNote(ctx context.Context, invoiceID string, amount int, reason string) (*model.Invoice, error) {
	claims := auth.GetUserFromContext(ctx)
	if claims == nil {
		return nil, fmt.Errorf("not authenticated")
	}
	if claims.Role != "global_admin" {
		return nil, fmt.Errorf("only global admins can generate credit notes")
	}

	inv, err := r.InvoiceService.GenerateCreditNote(ctx, stringToUUID(invoiceID), int32(amount), reason)
	if err != nil {
		return nil, fmt.Errorf("failed to generate credit note: %w", err)
	}

	gqlInvoice := dbInvoiceToGQL(inv)
	r.enrichInvoice(ctx, inv, gqlInvoice)
	return gqlInvoice, nil
}

// MyBillingProfile is the resolver for the myBillingProfile field.
func (r *queryResolver) MyBillingProfile(ctx context.Context) (*model.ClientBillingProfile, error) {
	claims := auth.GetUserFromContext(ctx)
	if claims == nil {
		return nil, fmt.Errorf("not authenticated")
	}
	if claims.Role != "client" {
		return nil, fmt.Errorf("only clients can view billing profiles")
	}

	bp, err := r.Queries.GetBillingProfileByUser(ctx, stringToUUID(claims.UserID))
	if err != nil {
		// Not found is not an error -- return nil.
		return nil, nil
	}
	return dbBillingProfileToGQL(bp), nil
}

// MyInvoices is the resolver for the myInvoices field.
func (r *queryResolver) MyInvoices(ctx context.Context, first *int, after *string) (*model.InvoiceConnection, error) {
	claims := auth.GetUserFromContext(ctx)
	if claims == nil {
		return nil, fmt.Errorf("not authenticated")
	}
	if claims.Role != "client" {
		return nil, fmt.Errorf("only clients can view their invoices")
	}

	limit := int32(20)
	if first != nil {
		limit = int32(*first)
	}
	offset := int32(0)
	if after != nil {
		fmt.Sscanf(*after, "%d", &offset)
	}

	userID := stringToUUID(claims.UserID)

	invoices, err := r.Queries.ListInvoicesByClient(ctx, db.ListInvoicesByClientParams{
		ClientUserID: userID,
		Limit:        limit + 1,
		Offset:       offset,
	})
	if err != nil {
		return nil, fmt.Errorf("failed to list client invoices: %w", err)
	}

	hasNext := len(invoices) > int(limit)
	if hasNext {
		invoices = invoices[:limit]
	}

	edges := make([]*model.Invoice, len(invoices))
	for i, inv := range invoices {
		gqlInv := dbInvoiceToGQL(inv)
		r.enrichInvoice(ctx, inv, gqlInv)
		edges[i] = gqlInv
	}

	total, _ := r.Queries.CountInvoicesByClient(ctx, userID)

	var endCursor *string
	if len(invoices) > 0 {
		c := fmt.Sprintf("%d", offset+limit)
		endCursor = &c
	}

	return &model.InvoiceConnection{
		Edges: edges,
		PageInfo: &model.PageInfo{
			HasNextPage: hasNext,
			EndCursor:   endCursor,
		},
		TotalCount: int(total),
	}, nil
}

// InvoiceDetail is the resolver for the invoiceDetail field.
func (r *queryResolver) InvoiceDetail(ctx context.Context, id string) (*model.Invoice, error) {
	claims := auth.GetUserFromContext(ctx)
	if claims == nil {
		return nil, fmt.Errorf("not authenticated")
	}

	inv, err := r.Queries.GetInvoiceByID(ctx, stringToUUID(id))
	if err != nil {
		return nil, fmt.Errorf("invoice not found: %w", err)
	}

	gqlInvoice := dbInvoiceToGQL(inv)
	r.enrichInvoice(ctx, inv, gqlInvoice)
	return gqlInvoice, nil
}

// CompanyInvoices is the resolver for the companyInvoices field.
func (r *queryResolver) CompanyInvoices(ctx context.Context, status *model.InvoiceStatus, first *int, after *string) (*model.InvoiceConnection, error) {
	claims := auth.GetUserFromContext(ctx)
	if claims == nil {
		return nil, fmt.Errorf("not authenticated")
	}
	if claims.Role != "company_admin" {
		return nil, fmt.Errorf("only company admins can view company invoices")
	}

	company, err := r.Queries.GetCompanyByAdminUserID(ctx, stringToUUID(claims.UserID))
	if err != nil {
		return nil, fmt.Errorf("company not found for admin: %w", err)
	}

	limit := int32(20)
	if first != nil {
		limit = int32(*first)
	}
	offset := int32(0)
	if after != nil {
		fmt.Sscanf(*after, "%d", &offset)
	}

	var invoices []db.Invoice
	if status != nil {
		dbStatus := db.InvoiceStatus(strings.ToLower(string(*status)))
		invoices, err = r.Queries.ListInvoicesByCompanyAndStatus(ctx, db.ListInvoicesByCompanyAndStatusParams{
			CompanyID: company.ID,
			Status:    dbStatus,
			Limit:     limit + 1,
			Offset:    offset,
		})
	} else {
		invoices, err = r.Queries.ListInvoicesByCompany(ctx, db.ListInvoicesByCompanyParams{
			CompanyID: company.ID,
			Limit:     limit + 1,
			Offset:    offset,
		})
	}
	if err != nil {
		return nil, fmt.Errorf("failed to list company invoices: %w", err)
	}

	hasNext := len(invoices) > int(limit)
	if hasNext {
		invoices = invoices[:limit]
	}

	edges := make([]*model.Invoice, len(invoices))
	for i, inv := range invoices {
		gqlInv := dbInvoiceToGQL(inv)
		r.enrichInvoice(ctx, inv, gqlInv)
		edges[i] = gqlInv
	}

	total, _ := r.Queries.CountInvoicesByCompany(ctx, company.ID)

	var endCursor *string
	if len(invoices) > 0 {
		c := fmt.Sprintf("%d", offset+limit)
		endCursor = &c
	}

	return &model.InvoiceConnection{
		Edges: edges,
		PageInfo: &model.PageInfo{
			HasNextPage: hasNext,
			EndCursor:   endCursor,
		},
		TotalCount: int(total),
	}, nil
}

// AllInvoices is the resolver for the allInvoices field.
func (r *queryResolver) AllInvoices(ctx context.Context, typeArg *model.InvoiceType, status *model.InvoiceStatus, companyID *string, first *int, after *string) (*model.InvoiceConnection, error) {
	claims := auth.GetUserFromContext(ctx)
	if claims == nil {
		return nil, fmt.Errorf("not authenticated")
	}
	if claims.Role != "global_admin" {
		return nil, fmt.Errorf("only global admins can view all invoices")
	}

	limit := int32(20)
	if first != nil {
		limit = int32(*first)
	}
	offset := int32(0)
	if after != nil {
		fmt.Sscanf(*after, "%d", &offset)
	}

	var invoices []db.Invoice
	var err error

	switch {
	case companyID != nil:
		// Filter by company ID (ignore type/status filters when company is specified).
		invoices, err = r.Queries.ListInvoicesByCompanyID(ctx, db.ListInvoicesByCompanyIDParams{
			CompanyID: stringToUUID(*companyID),
			Limit:     limit + 1,
			Offset:    offset,
		})
	case typeArg != nil && status != nil:
		dbType := db.InvoiceType(strings.ToLower(string(*typeArg)))
		dbStatus := db.InvoiceStatus(strings.ToLower(string(*status)))
		invoices, err = r.Queries.ListInvoicesByTypeAndStatus(ctx, db.ListInvoicesByTypeAndStatusParams{
			InvoiceType: dbType,
			Status:      dbStatus,
			Limit:       limit + 1,
			Offset:      offset,
		})
	case typeArg != nil:
		dbType := db.InvoiceType(strings.ToLower(string(*typeArg)))
		invoices, err = r.Queries.ListInvoicesByType(ctx, db.ListInvoicesByTypeParams{
			InvoiceType: dbType,
			Limit:       limit + 1,
			Offset:      offset,
		})
	default:
		invoices, err = r.Queries.ListAllInvoices(ctx, db.ListAllInvoicesParams{
			Limit:  limit + 1,
			Offset: offset,
		})
	}
	if err != nil {
		return nil, fmt.Errorf("failed to list invoices: %w", err)
	}

	hasNext := len(invoices) > int(limit)
	if hasNext {
		invoices = invoices[:limit]
	}

	edges := make([]*model.Invoice, len(invoices))
	for i, inv := range invoices {
		gqlInv := dbInvoiceToGQL(inv)
		r.enrichInvoice(ctx, inv, gqlInv)
		edges[i] = gqlInv
	}

	var endCursor *string
	if len(invoices) > 0 {
		c := fmt.Sprintf("%d", offset+limit)
		endCursor = &c
	}

	return &model.InvoiceConnection{
		Edges: edges,
		PageInfo: &model.PageInfo{
			HasNextPage: hasNext,
			EndCursor:   endCursor,
		},
		TotalCount: len(edges),
	}, nil
}

// InvoiceAnalytics is the resolver for the invoiceAnalytics field.
func (r *queryResolver) InvoiceAnalytics(ctx context.Context, from string, to string) (*model.InvoiceAnalytics, error) {
	claims := auth.GetUserFromContext(ctx)
	if claims == nil {
		return nil, fmt.Errorf("not authenticated")
	}
	if claims.Role != "global_admin" {
		return nil, fmt.Errorf("only global admins can view invoice analytics")
	}

	fromTime, err := time.Parse("2006-01-02", from)
	if err != nil {
		return nil, fmt.Errorf("invalid from date: %w", err)
	}
	toTime, err := time.Parse("2006-01-02", to)
	if err != nil {
		return nil, fmt.Errorf("invalid to date: %w", err)
	}

	fromTS := pgtype.Timestamptz{Time: fromTime, Valid: true}
	toTS := pgtype.Timestamptz{Time: toTime, Valid: true}

	// Get aggregated analytics.
	analytics, err := r.Queries.GetInvoiceAnalytics(ctx, db.GetInvoiceAnalyticsParams{
		CreatedAt:   fromTS,
		CreatedAt_2: toTS,
	})
	if err != nil {
		return nil, fmt.Errorf("failed to get invoice analytics: %w", err)
	}

	// Get counts by status.
	statusCounts, err := r.Queries.GetInvoiceCountByStatus(ctx, db.GetInvoiceCountByStatusParams{
		CreatedAt:   fromTS,
		CreatedAt_2: toTS,
	})
	if err != nil {
		return nil, fmt.Errorf("failed to get invoice counts by status: %w", err)
	}

	byStatus := make([]*model.InvoiceStatusCount, len(statusCounts))
	for i, sc := range statusCounts {
		byStatus[i] = &model.InvoiceStatusCount{
			Status:      model.InvoiceStatus(strings.ToUpper(string(sc.Status))),
			Count:       int(sc.Count),
			TotalAmount: int(sc.TotalAmount),
		}
	}

	// Get counts by type.
	typeCounts, err := r.Queries.GetInvoiceCountByType(ctx, db.GetInvoiceCountByTypeParams{
		CreatedAt:   fromTS,
		CreatedAt_2: toTS,
	})
	if err != nil {
		return nil, fmt.Errorf("failed to get invoice counts by type: %w", err)
	}

	byType := make([]*model.InvoiceTypeCount, len(typeCounts))
	for i, tc := range typeCounts {
		byType[i] = &model.InvoiceTypeCount{
			Type:        model.InvoiceType(strings.ToUpper(string(tc.InvoiceType))),
			Count:       int(tc.Count),
			TotalAmount: int(tc.TotalAmount),
		}
	}

	return &model.InvoiceAnalytics{
		TotalIssued: int(analytics.TotalIssued),
		TotalAmount: int(analytics.TotalAmount),
		TotalVat:    int(analytics.TotalVat),
		ByStatus:    byStatus,
		ByType:      byType,
	}, nil
}
