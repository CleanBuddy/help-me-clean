package resolver

// This file will be automatically regenerated based on the schema, any resolver
// implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.86

import (
	"context"
	"fmt"
	"helpmeclean-backend/internal/auth"
	db "helpmeclean-backend/internal/db/generated"
	"helpmeclean-backend/internal/graph/model"
	"time"

	"github.com/jackc/pgx/v5/pgtype"
)

// RevenueByDateRange is the resolver for the revenueByDateRange field.
func (r *queryResolver) RevenueByDateRange(ctx context.Context, from string, to string) ([]*model.DailyRevenue, error) {
	claims := auth.GetUserFromContext(ctx)
	if claims == nil || claims.Role != "global_admin" {
		return nil, fmt.Errorf("not authorized")
	}

	fromTime, err := time.Parse("2006-01-02", from)
	if err != nil {
		return nil, fmt.Errorf("invalid 'from' date format: %w", err)
	}
	toTime, err := time.Parse("2006-01-02", to)
	if err != nil {
		return nil, fmt.Errorf("invalid 'to' date format: %w", err)
	}

	rows, err := r.Queries.GetRevenueByDateRange(ctx, db.GetRevenueByDateRangeParams{
		CompletedAt:   pgtype.Timestamptz{Time: fromTime, Valid: true},
		CompletedAt_2: pgtype.Timestamptz{Time: toTime, Valid: true},
	})
	if err != nil {
		return nil, fmt.Errorf("failed to get revenue by date range: %w", err)
	}

	result := make([]*model.DailyRevenue, len(rows))
	for i, row := range rows {
		result[i] = &model.DailyRevenue{
			Date:         dateToString(row.Date),
			BookingCount: int(row.BookingCount),
			Revenue:      numericToFloat(row.Revenue),
			Commission:   numericToFloat(row.Commission),
		}
	}

	return result, nil
}

// RevenueByServiceType is the resolver for the revenueByServiceType field.
func (r *queryResolver) RevenueByServiceType(ctx context.Context, from string, to string) ([]*model.ServiceRevenue, error) {
	claims := auth.GetUserFromContext(ctx)
	if claims == nil || claims.Role != "global_admin" {
		return nil, fmt.Errorf("not authorized")
	}

	fromTime, err := time.Parse("2006-01-02", from)
	if err != nil {
		return nil, fmt.Errorf("invalid 'from' date format: %w", err)
	}
	toTime, err := time.Parse("2006-01-02", to)
	if err != nil {
		return nil, fmt.Errorf("invalid 'to' date format: %w", err)
	}

	rows, err := r.Queries.GetRevenueByServiceType(ctx, db.GetRevenueByServiceTypeParams{
		CompletedAt:   pgtype.Timestamptz{Time: fromTime, Valid: true},
		CompletedAt_2: pgtype.Timestamptz{Time: toTime, Valid: true},
	})
	if err != nil {
		return nil, fmt.Errorf("failed to get revenue by service type: %w", err)
	}

	result := make([]*model.ServiceRevenue, len(rows))
	for i, row := range rows {
		result[i] = &model.ServiceRevenue{
			ServiceType:  dbServiceTypeToGQL(row.ServiceType),
			BookingCount: int(row.BookingCount),
			Revenue:      numericToFloat(row.Revenue),
		}
	}

	return result, nil
}

// TopCompaniesByRevenue is the resolver for the topCompaniesByRevenue field.
func (r *queryResolver) TopCompaniesByRevenue(ctx context.Context, from string, to string, limit *int) ([]*model.TopCompany, error) {
	claims := auth.GetUserFromContext(ctx)
	if claims == nil || claims.Role != "global_admin" {
		return nil, fmt.Errorf("not authorized")
	}

	fromTime, err := time.Parse("2006-01-02", from)
	if err != nil {
		return nil, fmt.Errorf("invalid 'from' date format: %w", err)
	}
	toTime, err := time.Parse("2006-01-02", to)
	if err != nil {
		return nil, fmt.Errorf("invalid 'to' date format: %w", err)
	}

	queryLimit := int32(10)
	if limit != nil {
		queryLimit = int32(*limit)
	}

	rows, err := r.Queries.GetTopCompaniesByRevenue(ctx, db.GetTopCompaniesByRevenueParams{
		CompletedAt:   pgtype.Timestamptz{Time: fromTime, Valid: true},
		CompletedAt_2: pgtype.Timestamptz{Time: toTime, Valid: true},
		Limit:         queryLimit,
	})
	if err != nil {
		return nil, fmt.Errorf("failed to get top companies by revenue: %w", err)
	}

	result := make([]*model.TopCompany, len(rows))
	for i, row := range rows {
		result[i] = &model.TopCompany{
			ID:           uuidToString(row.ID),
			CompanyName:  row.CompanyName,
			BookingCount: int(row.BookingCount),
			Revenue:      numericToFloat(row.Revenue),
			Commission:   numericToFloat(row.Commission),
		}
	}

	return result, nil
}

// PlatformTotals is the resolver for the platformTotals field.
func (r *queryResolver) PlatformTotals(ctx context.Context) (*model.PlatformTotals, error) {
	claims := auth.GetUserFromContext(ctx)
	if claims == nil || claims.Role != "global_admin" {
		return nil, fmt.Errorf("not authorized")
	}

	totals, err := r.Queries.GetPlatformTotals(ctx)
	if err != nil {
		return nil, fmt.Errorf("failed to get platform totals: %w", err)
	}

	return &model.PlatformTotals{
		TotalCompleted:  int(totals.TotalCompleted),
		TotalBookings:   int(totals.TotalBookings),
		TotalRevenue:    numericToFloat(totals.TotalRevenue),
		TotalCommission: numericToFloat(totals.TotalCommission),
		UniqueClients:   int(totals.UniqueClients),
		ActiveCompanies: int(totals.ActiveCompanies),
	}, nil
}

// CompanyRevenueByDateRange is the resolver for the companyRevenueByDateRange field.
func (r *queryResolver) CompanyRevenueByDateRange(ctx context.Context, from string, to string) ([]*model.DailyRevenue, error) {
	claims := auth.GetUserFromContext(ctx)
	if claims == nil {
		return nil, fmt.Errorf("not authenticated")
	}

	company, err := r.Queries.GetCompanyByAdminUserID(ctx, stringToUUID(claims.UserID))
	if err != nil {
		return nil, fmt.Errorf("company not found for user: %w", err)
	}

	fromTime, err := time.Parse("2006-01-02", from)
	if err != nil {
		return nil, fmt.Errorf("invalid 'from' date format: %w", err)
	}
	toTime, err := time.Parse("2006-01-02", to)
	if err != nil {
		return nil, fmt.Errorf("invalid 'to' date format: %w", err)
	}

	rows, err := r.Queries.GetCompanyRevenueByDateRange(ctx, db.GetCompanyRevenueByDateRangeParams{
		CompanyID:     company.ID,
		CompletedAt:   pgtype.Timestamptz{Time: fromTime, Valid: true},
		CompletedAt_2: pgtype.Timestamptz{Time: toTime, Valid: true},
	})
	if err != nil {
		return nil, fmt.Errorf("failed to get company revenue: %w", err)
	}

	result := make([]*model.DailyRevenue, len(rows))
	for i, row := range rows {
		result[i] = &model.DailyRevenue{
			Date:         dateToString(row.Date),
			BookingCount: int(row.BookingCount),
			Revenue:      numericToFloat(row.Revenue),
			Commission:   numericToFloat(row.Commission),
		}
	}

	return result, nil
}
