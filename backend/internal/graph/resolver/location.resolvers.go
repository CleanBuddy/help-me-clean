package resolver

// This file will be automatically regenerated based on the schema, any resolver
// implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.86

import (
	"context"
	"fmt"
	"helpmeclean-backend/internal/auth"
	db "helpmeclean-backend/internal/db/generated"
	"helpmeclean-backend/internal/graph/model"
	"helpmeclean-backend/internal/service/matching"
	"strings"
	"time"

	"github.com/jackc/pgx/v5/pgtype"
)

// CreateCity is the resolver for the createCity field.
func (r *mutationResolver) CreateCity(ctx context.Context, name string, county string) (*model.EnabledCity, error) {
	claims := auth.GetUserFromContext(ctx)
	if claims == nil || claims.Role != "global_admin" {
		return nil, fmt.Errorf("admin access required")
	}

	city, err := r.Queries.CreateCity(ctx, db.CreateCityParams{
		Name:   name,
		County: county,
	})
	if err != nil {
		return nil, fmt.Errorf("failed to create city: %w", err)
	}

	return r.dbCityToGQL(ctx, city)
}

// ToggleCityActive is the resolver for the toggleCityActive field.
func (r *mutationResolver) ToggleCityActive(ctx context.Context, id string, isActive bool) (*model.EnabledCity, error) {
	claims := auth.GetUserFromContext(ctx)
	if claims == nil || claims.Role != "global_admin" {
		return nil, fmt.Errorf("admin access required")
	}

	city, err := r.Queries.UpdateCityActive(ctx, db.UpdateCityActiveParams{
		ID:       stringToUUID(id),
		IsActive: isActive,
	})
	if err != nil {
		return nil, fmt.Errorf("failed to toggle city: %w", err)
	}

	return r.dbCityToGQL(ctx, city)
}

// CreateCityArea is the resolver for the createCityArea field.
func (r *mutationResolver) CreateCityArea(ctx context.Context, cityID string, name string) (*model.CityArea, error) {
	claims := auth.GetUserFromContext(ctx)
	if claims == nil || claims.Role != "global_admin" {
		return nil, fmt.Errorf("admin access required")
	}

	area, err := r.Queries.CreateArea(ctx, db.CreateAreaParams{
		CityID: stringToUUID(cityID),
		Name:   name,
	})
	if err != nil {
		return nil, fmt.Errorf("failed to create area: %w", err)
	}

	// Look up city name for the response.
	city, err := r.Queries.GetCityByID(ctx, area.CityID)
	if err != nil {
		return nil, fmt.Errorf("failed to load city: %w", err)
	}

	return &model.CityArea{
		ID:       uuidToString(area.ID),
		Name:     area.Name,
		CityID:   uuidToString(area.CityID),
		CityName: city.Name,
	}, nil
}

// DeleteCityArea is the resolver for the deleteCityArea field.
func (r *mutationResolver) DeleteCityArea(ctx context.Context, id string) (bool, error) {
	claims := auth.GetUserFromContext(ctx)
	if claims == nil || claims.Role != "global_admin" {
		return false, fmt.Errorf("admin access required")
	}

	err := r.Queries.DeleteArea(ctx, stringToUUID(id))
	if err != nil {
		return false, fmt.Errorf("failed to delete area: %w", err)
	}

	return true, nil
}

// UpdateCompanyServiceAreas is the resolver for the updateCompanyServiceAreas field.
func (r *mutationResolver) UpdateCompanyServiceAreas(ctx context.Context, areaIds []string) ([]*model.CityArea, error) {
	claims := auth.GetUserFromContext(ctx)
	if claims == nil {
		return nil, fmt.Errorf("not authenticated")
	}

	company, err := r.Queries.GetCompanyByAdminUserID(ctx, stringToUUID(claims.UserID))
	if err != nil {
		return nil, fmt.Errorf("company not found for user")
	}

	// Delete all existing areas, then insert new ones.
	if err := r.Queries.DeleteAllCompanyServiceAreas(ctx, company.ID); err != nil {
		return nil, fmt.Errorf("failed to clear service areas: %w", err)
	}

	for _, areaID := range areaIds {
		_, err := r.Queries.InsertCompanyServiceArea(ctx, db.InsertCompanyServiceAreaParams{
			CompanyID:  company.ID,
			CityAreaID: stringToUUID(areaID),
		})
		if err != nil {
			return nil, fmt.Errorf("failed to add area %s: %w", areaID, err)
		}
	}

	// Return updated list.
	rows, err := r.Queries.ListCompanyServiceAreas(ctx, company.ID)
	if err != nil {
		return nil, fmt.Errorf("failed to list areas: %w", err)
	}

	var result []*model.CityArea
	for _, row := range rows {
		result = append(result, &model.CityArea{
			ID:       uuidToString(row.CityAreaID),
			Name:     row.AreaName,
			CityID:   uuidToString(row.CityID),
			CityName: row.CityName,
		})
	}
	return result, nil
}

// UpdateCleanerServiceAreas is the resolver for the updateCleanerServiceAreas field.
func (r *mutationResolver) UpdateCleanerServiceAreas(ctx context.Context, cleanerID string, areaIds []string) ([]*model.CityArea, error) {
	claims := auth.GetUserFromContext(ctx)
	if claims == nil {
		return nil, fmt.Errorf("not authenticated")
	}

	company, err := r.Queries.GetCompanyByAdminUserID(ctx, stringToUUID(claims.UserID))
	if err != nil {
		return nil, fmt.Errorf("company not found for user")
	}

	// Validate cleaner belongs to this company.
	cleaner, err := r.Queries.GetCleanerByID(ctx, stringToUUID(cleanerID))
	if err != nil {
		return nil, fmt.Errorf("cleaner not found")
	}
	if uuidToString(cleaner.CompanyID) != uuidToString(company.ID) {
		return nil, fmt.Errorf("cleaner does not belong to your company")
	}

	// Delete all existing areas, then insert new ones.
	cleanerUUID := stringToUUID(cleanerID)
	if err := r.Queries.DeleteAllCleanerServiceAreas(ctx, cleanerUUID); err != nil {
		return nil, fmt.Errorf("failed to clear cleaner areas: %w", err)
	}

	for _, areaID := range areaIds {
		_, err := r.Queries.InsertCleanerServiceArea(ctx, db.InsertCleanerServiceAreaParams{
			CleanerID:  cleanerUUID,
			CityAreaID: stringToUUID(areaID),
		})
		if err != nil {
			return nil, fmt.Errorf("failed to add area %s: %w", areaID, err)
		}
	}

	// Return updated list.
	rows, err := r.Queries.ListCleanerServiceAreas(ctx, cleanerUUID)
	if err != nil {
		return nil, fmt.Errorf("failed to list cleaner areas: %w", err)
	}

	var result []*model.CityArea
	for _, row := range rows {
		result = append(result, &model.CityArea{
			ID:       uuidToString(row.CityAreaID),
			Name:     row.AreaName,
			CityID:   uuidToString(row.CityID),
			CityName: row.CityName,
		})
	}
	return result, nil
}

// ActiveCities is the resolver for the activeCities field.
func (r *queryResolver) ActiveCities(ctx context.Context) ([]*model.EnabledCity, error) {
	cities, err := r.Queries.ListActiveCities(ctx)
	if err != nil {
		return nil, fmt.Errorf("failed to list active cities: %w", err)
	}

	var result []*model.EnabledCity
	for _, c := range cities {
		gqlCity, err := r.dbCityToGQL(ctx, c)
		if err != nil {
			return nil, err
		}
		result = append(result, gqlCity)
	}
	return result, nil
}

// CityAreas is the resolver for the cityAreas field.
func (r *queryResolver) CityAreas(ctx context.Context, cityID string) ([]*model.CityArea, error) {
	rows, err := r.Queries.ListAreasByCity(ctx, stringToUUID(cityID))
	if err != nil {
		return nil, fmt.Errorf("failed to list areas: %w", err)
	}

	var result []*model.CityArea
	for _, row := range rows {
		result = append(result, &model.CityArea{
			ID:       uuidToString(row.ID),
			Name:     row.Name,
			CityID:   uuidToString(row.CityID),
			CityName: row.CityName,
		})
	}
	return result, nil
}

// AllCities is the resolver for the allCities field.
func (r *queryResolver) AllCities(ctx context.Context) ([]*model.EnabledCity, error) {
	claims := auth.GetUserFromContext(ctx)
	if claims == nil || claims.Role != "global_admin" {
		return nil, fmt.Errorf("admin access required")
	}

	cities, err := r.Queries.ListEnabledCities(ctx)
	if err != nil {
		return nil, fmt.Errorf("failed to list cities: %w", err)
	}

	var result []*model.EnabledCity
	for _, c := range cities {
		gqlCity, err := r.dbCityToGQL(ctx, c)
		if err != nil {
			return nil, err
		}
		result = append(result, gqlCity)
	}
	return result, nil
}

// MyCompanyServiceAreas is the resolver for the myCompanyServiceAreas field.
func (r *queryResolver) MyCompanyServiceAreas(ctx context.Context) ([]*model.CityArea, error) {
	claims := auth.GetUserFromContext(ctx)
	if claims == nil {
		return nil, fmt.Errorf("not authenticated")
	}

	company, err := r.Queries.GetCompanyByAdminUserID(ctx, stringToUUID(claims.UserID))
	if err != nil {
		return nil, fmt.Errorf("company not found for user")
	}

	rows, err := r.Queries.ListCompanyServiceAreas(ctx, company.ID)
	if err != nil {
		return nil, fmt.Errorf("failed to list company areas: %w", err)
	}

	var result []*model.CityArea
	for _, row := range rows {
		result = append(result, &model.CityArea{
			ID:       uuidToString(row.CityAreaID),
			Name:     row.AreaName,
			CityID:   uuidToString(row.CityID),
			CityName: row.CityName,
		})
	}
	return result, nil
}

// CleanerServiceAreas is the resolver for the cleanerServiceAreas field (company admin).
func (r *queryResolver) CleanerServiceAreas(ctx context.Context, cleanerID string) ([]*model.CityArea, error) {
	claims := auth.GetUserFromContext(ctx)
	if claims == nil {
		return nil, fmt.Errorf("not authenticated")
	}

	company, err := r.Queries.GetCompanyByAdminUserID(ctx, stringToUUID(claims.UserID))
	if err != nil {
		return nil, fmt.Errorf("company not found for user")
	}

	// Validate cleaner belongs to this company.
	cleaner, err := r.Queries.GetCleanerByID(ctx, stringToUUID(cleanerID))
	if err != nil {
		return nil, fmt.Errorf("cleaner not found")
	}
	if uuidToString(cleaner.CompanyID) != uuidToString(company.ID) {
		return nil, fmt.Errorf("cleaner does not belong to your company")
	}

	rows, err := r.Queries.ListCleanerServiceAreas(ctx, stringToUUID(cleanerID))
	if err != nil {
		return nil, fmt.Errorf("failed to list cleaner areas: %w", err)
	}

	var result []*model.CityArea
	for _, row := range rows {
		result = append(result, &model.CityArea{
			ID:       uuidToString(row.CityAreaID),
			Name:     row.AreaName,
			CityID:   uuidToString(row.CityID),
			CityName: row.CityName,
		})
	}
	return result, nil
}

// MyCleanerServiceAreas is the resolver for the myCleanerServiceAreas field.
func (r *queryResolver) MyCleanerServiceAreas(ctx context.Context) ([]*model.CityArea, error) {
	claims := auth.GetUserFromContext(ctx)
	if claims == nil {
		return nil, fmt.Errorf("not authenticated")
	}

	cleaner, err := r.Queries.GetCleanerByUserID(ctx, stringToUUID(claims.UserID))
	if err != nil {
		return nil, fmt.Errorf("cleaner profile not found")
	}

	rows, err := r.Queries.ListCleanerServiceAreas(ctx, cleaner.ID)
	if err != nil {
		return nil, fmt.Errorf("failed to list cleaner areas: %w", err)
	}

	var result []*model.CityArea
	for _, row := range rows {
		result = append(result, &model.CityArea{
			ID:       uuidToString(row.CityAreaID),
			Name:     row.AreaName,
			CityID:   uuidToString(row.CityID),
			CityName: row.CityName,
		})
	}
	return result, nil
}

// SuggestCleaners is the resolver for the suggestCleaners field.
func (r *queryResolver) SuggestCleaners(ctx context.Context, cityID string, areaID string, timeSlots []*model.TimeSlotInput, estimatedDurationHours float64) ([]*model.CleanerSuggestion, error) {
	if len(timeSlots) == 0 {
		return nil, fmt.Errorf("at least one time slot is required")
	}

	areaUUID := stringToUUID(areaID)

	// Parse the date from the first time slot (MVP: all slots same date).
	reqDate, err := time.Parse("2006-01-02", timeSlots[0].Date)
	if err != nil {
		return nil, fmt.Errorf("invalid date format in timeSlots (use YYYY-MM-DD): %w", err)
	}
	dayOfWeek := int32(reqDate.Weekday())

	// Build matching.TimeSlot list from the GraphQL input.
	clientSlots := make([]matching.TimeSlot, len(timeSlots))
	for i, ts := range timeSlots {
		clientSlots[i] = matching.TimeSlot{
			StartMicros: matching.HHMMToMicros(ts.StartTime),
			EndMicros:   matching.HHMMToMicros(ts.EndTime),
		}
	}

	jobDurationMicros := int64(estimatedDurationHours * float64(matching.HourMicros))

	dateFrom := pgtype.Date{Time: reqDate, Valid: true}
	dateTo := pgtype.Date{Time: reqDate, Valid: true}

	// Step 1: Find cleaners matching this area.
	candidates, err := r.Queries.FindMatchingCleaners(ctx, areaUUID)
	if err != nil {
		return nil, fmt.Errorf("failed to find matching cleaners: %w", err)
	}
	if len(candidates) == 0 {
		return []*model.CleanerSuggestion{}, nil
	}

	type scoredSuggestion struct {
		suggestion *model.CleanerSuggestion
		score      float64
	}
	var suggestions []scoredSuggestion

	for _, candidate := range candidates {
		cleaner, err := r.Queries.GetCleanerByID(ctx, candidate.ID)
		if err != nil {
			continue
		}
		company, err := r.Queries.GetCompanyByID(ctx, candidate.CompanyID)
		if err != nil {
			continue
		}

		// --- 4-tier availability cascade ---

		companySchedules, err := r.Queries.ListCompanyWorkSchedule(ctx, candidate.CompanyID)
		if err != nil {
			continue
		}
		var companyDaySchedule *db.CompanyWorkSchedule
		for i := range companySchedules {
			if companySchedules[i].DayOfWeek == dayOfWeek {
				companyDaySchedule = &companySchedules[i]
				break
			}
		}
		if companyDaySchedule != nil && !companyDaySchedule.IsWorkDay {
			continue
		}

		// Tier 1: date override.
		overrides, err := r.Queries.ListCleanerDateOverrides(ctx, db.ListCleanerDateOverridesParams{
			CleanerID:      candidate.ID,
			OverrideDate:   dateFrom,
			OverrideDate_2: dateTo,
		})
		if err != nil {
			continue
		}

		var availStart, availEnd int64

		if len(overrides) > 0 {
			override := overrides[0]
			if !override.IsAvailable {
				continue
			}
			availStart = override.StartTime.Microseconds
			availEnd = override.EndTime.Microseconds
		} else {
			// Tier 2: weekly slots.
			weeklySlots, err := r.Queries.ListCleanerAvailability(ctx, candidate.ID)
			if err != nil {
				continue
			}
			var found bool
			for _, slot := range weeklySlots {
				if slot.DayOfWeek == dayOfWeek && boolVal(slot.IsAvailable) {
					availStart = slot.StartTime.Microseconds
					availEnd = slot.EndTime.Microseconds
					found = true
					break
				}
			}
			if !found {
				// Tier 3: company schedule.
				if companyDaySchedule != nil && companyDaySchedule.IsWorkDay {
					availStart = companyDaySchedule.StartTime.Microseconds
					availEnd = companyDaySchedule.EndTime.Microseconds
				} else if companyDaySchedule == nil {
					// Tier 4: default 08:00-17:00.
					availStart = 8 * matching.HourMicros
					availEnd = 17 * matching.HourMicros
				} else {
					continue
				}
			}
		}

		// --- Smart scheduling: compute free intervals and optimal placement ---

		existingBookings, err := r.Queries.ListCleanerBookingsForDate(ctx, db.ListCleanerBookingsForDateParams{
			CleanerID:     candidate.ID,
			ScheduledDate: dateFrom,
		})
		if err != nil {
			continue
		}

		bookingSlots := make([]matching.BookingSlot, len(existingBookings))
		for i, eb := range existingBookings {
			startMicros := eb.ScheduledStartTime.Microseconds
			durationHours := numericToFloat(eb.EstimatedDurationHours)
			endMicros := startMicros + int64(durationHours*float64(matching.HourMicros))
			bookingSlots[i] = matching.BookingSlot{
				StartMicros: startMicros,
				EndMicros:   endMicros,
			}
		}

		freeIntervals := matching.ComputeFreeIntervals(availStart, availEnd, bookingSlots, matching.BufferMicros)
		placement := matching.FindOptimalPlacement(freeIntervals, clientSlots, jobDurationMicros)

		availStatus := "available"
		if !placement.Found {
			availStatus = "unavailable"
		}

		// --- Calculate match score ---

		rating := numericToFloat(candidate.RatingAvg)
		jobs := 0
		if candidate.TotalJobsCompleted.Valid {
			jobs = int(candidate.TotalJobsCompleted.Int32)
		}

		score := 50.0
		score += rating * 5.0
		jobsBonus := float64(jobs) / 100.0 * 15.0
		if jobsBonus > 15.0 {
			jobsBonus = 15.0
		}
		score += jobsBonus
		score += 10.0 // area match

		if placement.Found {
			if placement.GapScoreH == 0 {
				score += 5.0 // perfect adjacent packing bonus
			}
		} else {
			score -= 40.0 // no valid placement penalty
		}

		if score < 0 {
			score = 0
		}
		if score > 100 {
			score = 100
		}

		profile, err := r.cleanerWithCompany(ctx, cleaner)
		if err != nil {
			continue
		}

		availFromStr := microsecondsToHHMM(availStart)
		availToStr := microsecondsToHHMM(availEnd)

		suggestion := &model.CleanerSuggestion{
			Cleaner:            profile,
			Company:            dbCompanyToGQL(company),
			AvailabilityStatus: availStatus,
			AvailableFrom:      &availFromStr,
			AvailableTo:        &availToStr,
			MatchScore:         score,
		}

		if placement.Found {
			startStr := matching.MicrosToHHMM(placement.StartMicros)
			endStr := matching.MicrosToHHMM(placement.EndMicros)
			slotIdx := placement.SlotIndex
			suggestion.SuggestedStartTime = &startStr
			suggestion.SuggestedEndTime = &endStr
			suggestion.SuggestedSlotIndex = &slotIdx
		}

		suggestions = append(suggestions, scoredSuggestion{
			suggestion: suggestion,
			score:      score,
		})
	}

	// Sort by score DESC.
	for i := 0; i < len(suggestions); i++ {
		for j := i + 1; j < len(suggestions); j++ {
			if suggestions[j].score > suggestions[i].score {
				suggestions[i], suggestions[j] = suggestions[j], suggestions[i]
			}
		}
	}

	// Return top 5.
	limit := 5
	if len(suggestions) < limit {
		limit = len(suggestions)
	}
	result := make([]*model.CleanerSuggestion, limit)
	for i := 0; i < limit; i++ {
		result[i] = suggestions[i].suggestion
	}

	return result, nil
}

// IsCitySupported is the resolver for the isCitySupported field.
func (r *queryResolver) IsCitySupported(ctx context.Context, city string) (bool, error) {
	_, err := r.Queries.GetCityByName(ctx, strings.TrimSpace(city))
	if err != nil {
		return false, nil // Not found = not supported.
	}
	return true, nil
}
