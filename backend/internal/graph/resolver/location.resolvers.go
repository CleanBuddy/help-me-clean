package resolver

// This file will be automatically regenerated based on the schema, any resolver
// implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.86

import (
	"context"
	"fmt"
	"helpmeclean-backend/internal/auth"
	db "helpmeclean-backend/internal/db/generated"
	"helpmeclean-backend/internal/graph/model"
	"helpmeclean-backend/internal/service/matching"
	"log"
	"strings"
	"time"

	"github.com/jackc/pgx/v5/pgtype"
)

// CreateCity is the resolver for the createCity field.
func (r *mutationResolver) CreateCity(ctx context.Context, name string, county string) (*model.EnabledCity, error) {
	claims := auth.GetUserFromContext(ctx)
	if claims == nil || claims.Role != "global_admin" {
		return nil, fmt.Errorf("admin access required")
	}

	city, err := r.Queries.CreateCity(ctx, db.CreateCityParams{
		Name:   name,
		County: county,
	})
	if err != nil {
		return nil, fmt.Errorf("failed to create city: %w", err)
	}

	return r.dbCityToGQL(ctx, city)
}

// ToggleCityActive is the resolver for the toggleCityActive field.
func (r *mutationResolver) ToggleCityActive(ctx context.Context, id string, isActive bool) (*model.EnabledCity, error) {
	claims := auth.GetUserFromContext(ctx)
	if claims == nil || claims.Role != "global_admin" {
		return nil, fmt.Errorf("admin access required")
	}

	city, err := r.Queries.UpdateCityActive(ctx, db.UpdateCityActiveParams{
		ID:       stringToUUID(id),
		IsActive: isActive,
	})
	if err != nil {
		return nil, fmt.Errorf("failed to toggle city: %w", err)
	}

	return r.dbCityToGQL(ctx, city)
}

// CreateCityArea is the resolver for the createCityArea field.
func (r *mutationResolver) CreateCityArea(ctx context.Context, cityID string, name string) (*model.CityArea, error) {
	claims := auth.GetUserFromContext(ctx)
	if claims == nil || claims.Role != "global_admin" {
		return nil, fmt.Errorf("admin access required")
	}

	area, err := r.Queries.CreateArea(ctx, db.CreateAreaParams{
		CityID: stringToUUID(cityID),
		Name:   name,
	})
	if err != nil {
		return nil, fmt.Errorf("failed to create area: %w", err)
	}

	// Look up city name for the response.
	city, err := r.Queries.GetCityByID(ctx, area.CityID)
	if err != nil {
		return nil, fmt.Errorf("failed to load city: %w", err)
	}

	return &model.CityArea{
		ID:       uuidToString(area.ID),
		Name:     area.Name,
		CityID:   uuidToString(area.CityID),
		CityName: city.Name,
	}, nil
}

// DeleteCityArea is the resolver for the deleteCityArea field.
func (r *mutationResolver) DeleteCityArea(ctx context.Context, id string) (bool, error) {
	claims := auth.GetUserFromContext(ctx)
	if claims == nil || claims.Role != "global_admin" {
		return false, fmt.Errorf("admin access required")
	}

	err := r.Queries.DeleteArea(ctx, stringToUUID(id))
	if err != nil {
		return false, fmt.Errorf("failed to delete area: %w", err)
	}

	return true, nil
}

// UpdateCompanyServiceAreas is the resolver for the updateCompanyServiceAreas field.
func (r *mutationResolver) UpdateCompanyServiceAreas(ctx context.Context, areaIds []string) ([]*model.CityArea, error) {
	claims := auth.GetUserFromContext(ctx)
	if claims == nil {
		return nil, fmt.Errorf("not authenticated")
	}

	company, err := r.Queries.GetCompanyByAdminUserID(ctx, stringToUUID(claims.UserID))
	if err != nil {
		return nil, fmt.Errorf("company not found for user")
	}

	// Delete all existing areas, then insert new ones.
	if err := r.Queries.DeleteAllCompanyServiceAreas(ctx, company.ID); err != nil {
		return nil, fmt.Errorf("failed to clear service areas: %w", err)
	}

	for _, areaID := range areaIds {
		_, err := r.Queries.InsertCompanyServiceArea(ctx, db.InsertCompanyServiceAreaParams{
			CompanyID:  company.ID,
			CityAreaID: stringToUUID(areaID),
		})
		if err != nil {
			return nil, fmt.Errorf("failed to add area %s: %w", areaID, err)
		}
	}

	// Return updated list.
	rows, err := r.Queries.ListCompanyServiceAreas(ctx, company.ID)
	if err != nil {
		return nil, fmt.Errorf("failed to list areas: %w", err)
	}

	var result []*model.CityArea
	for _, row := range rows {
		result = append(result, &model.CityArea{
			ID:       uuidToString(row.CityAreaID),
			Name:     row.AreaName,
			CityID:   uuidToString(row.CityID),
			CityName: row.CityName,
		})
	}
	return result, nil
}

// UpdateCleanerServiceAreas is the resolver for the updateCleanerServiceAreas field.
func (r *mutationResolver) UpdateCleanerServiceAreas(ctx context.Context, cleanerID string, areaIds []string) ([]*model.CityArea, error) {
	claims := auth.GetUserFromContext(ctx)
	if claims == nil {
		return nil, fmt.Errorf("not authenticated")
	}

	company, err := r.Queries.GetCompanyByAdminUserID(ctx, stringToUUID(claims.UserID))
	if err != nil {
		return nil, fmt.Errorf("company not found for user")
	}

	// Validate cleaner belongs to this company.
	cleaner, err := r.Queries.GetCleanerByID(ctx, stringToUUID(cleanerID))
	if err != nil {
		return nil, fmt.Errorf("cleaner not found")
	}
	if uuidToString(cleaner.CompanyID) != uuidToString(company.ID) {
		return nil, fmt.Errorf("cleaner does not belong to your company")
	}

	// Delete all existing areas, then insert new ones.
	cleanerUUID := stringToUUID(cleanerID)
	if err := r.Queries.DeleteAllCleanerServiceAreas(ctx, cleanerUUID); err != nil {
		return nil, fmt.Errorf("failed to clear cleaner areas: %w", err)
	}

	for _, areaID := range areaIds {
		_, err := r.Queries.InsertCleanerServiceArea(ctx, db.InsertCleanerServiceAreaParams{
			CleanerID:  cleanerUUID,
			CityAreaID: stringToUUID(areaID),
		})
		if err != nil {
			return nil, fmt.Errorf("failed to add area %s: %w", areaID, err)
		}
	}

	// Return updated list.
	rows, err := r.Queries.ListCleanerServiceAreas(ctx, cleanerUUID)
	if err != nil {
		return nil, fmt.Errorf("failed to list cleaner areas: %w", err)
	}

	var result []*model.CityArea
	for _, row := range rows {
		result = append(result, &model.CityArea{
			ID:       uuidToString(row.CityAreaID),
			Name:     row.AreaName,
			CityID:   uuidToString(row.CityID),
			CityName: row.CityName,
		})
	}
	return result, nil
}

// ActiveCities is the resolver for the activeCities field.
func (r *queryResolver) ActiveCities(ctx context.Context) ([]*model.EnabledCity, error) {
	cities, err := r.Queries.ListActiveCities(ctx)
	if err != nil {
		return nil, fmt.Errorf("failed to list active cities: %w", err)
	}

	var result []*model.EnabledCity
	for _, c := range cities {
		gqlCity, err := r.dbCityToGQL(ctx, c)
		if err != nil {
			return nil, err
		}
		result = append(result, gqlCity)
	}
	return result, nil
}

// CityAreas is the resolver for the cityAreas field.
func (r *queryResolver) CityAreas(ctx context.Context, cityID string) ([]*model.CityArea, error) {
	rows, err := r.Queries.ListAreasByCity(ctx, stringToUUID(cityID))
	if err != nil {
		return nil, fmt.Errorf("failed to list areas: %w", err)
	}

	var result []*model.CityArea
	for _, row := range rows {
		result = append(result, &model.CityArea{
			ID:       uuidToString(row.ID),
			Name:     row.Name,
			CityID:   uuidToString(row.CityID),
			CityName: row.CityName,
		})
	}
	return result, nil
}

// AllCities is the resolver for the allCities field.
func (r *queryResolver) AllCities(ctx context.Context) ([]*model.EnabledCity, error) {
	claims := auth.GetUserFromContext(ctx)
	if claims == nil || claims.Role != "global_admin" {
		return nil, fmt.Errorf("admin access required")
	}

	cities, err := r.Queries.ListEnabledCities(ctx)
	if err != nil {
		return nil, fmt.Errorf("failed to list cities: %w", err)
	}

	var result []*model.EnabledCity
	for _, c := range cities {
		gqlCity, err := r.dbCityToGQL(ctx, c)
		if err != nil {
			return nil, err
		}
		result = append(result, gqlCity)
	}
	return result, nil
}

// MyCompanyServiceAreas is the resolver for the myCompanyServiceAreas field.
func (r *queryResolver) MyCompanyServiceAreas(ctx context.Context) ([]*model.CityArea, error) {
	claims := auth.GetUserFromContext(ctx)
	if claims == nil {
		return nil, fmt.Errorf("not authenticated")
	}

	company, err := r.Queries.GetCompanyByAdminUserID(ctx, stringToUUID(claims.UserID))
	if err != nil {
		return nil, fmt.Errorf("company not found for user")
	}

	rows, err := r.Queries.ListCompanyServiceAreas(ctx, company.ID)
	if err != nil {
		return nil, fmt.Errorf("failed to list company areas: %w", err)
	}

	var result []*model.CityArea
	for _, row := range rows {
		result = append(result, &model.CityArea{
			ID:       uuidToString(row.CityAreaID),
			Name:     row.AreaName,
			CityID:   uuidToString(row.CityID),
			CityName: row.CityName,
		})
	}
	return result, nil
}

// CleanerServiceAreas is the resolver for the cleanerServiceAreas field (company admin).
func (r *queryResolver) CleanerServiceAreas(ctx context.Context, cleanerID string) ([]*model.CityArea, error) {
	claims := auth.GetUserFromContext(ctx)
	if claims == nil {
		return nil, fmt.Errorf("not authenticated")
	}

	company, err := r.Queries.GetCompanyByAdminUserID(ctx, stringToUUID(claims.UserID))
	if err != nil {
		return nil, fmt.Errorf("company not found for user")
	}

	// Validate cleaner belongs to this company.
	cleaner, err := r.Queries.GetCleanerByID(ctx, stringToUUID(cleanerID))
	if err != nil {
		return nil, fmt.Errorf("cleaner not found")
	}
	if uuidToString(cleaner.CompanyID) != uuidToString(company.ID) {
		return nil, fmt.Errorf("cleaner does not belong to your company")
	}

	rows, err := r.Queries.ListCleanerServiceAreas(ctx, stringToUUID(cleanerID))
	if err != nil {
		return nil, fmt.Errorf("failed to list cleaner areas: %w", err)
	}

	var result []*model.CityArea
	for _, row := range rows {
		result = append(result, &model.CityArea{
			ID:       uuidToString(row.CityAreaID),
			Name:     row.AreaName,
			CityID:   uuidToString(row.CityID),
			CityName: row.CityName,
		})
	}
	return result, nil
}

// MyCleanerServiceAreas is the resolver for the myCleanerServiceAreas field.
func (r *queryResolver) MyCleanerServiceAreas(ctx context.Context) ([]*model.CityArea, error) {
	claims := auth.GetUserFromContext(ctx)
	if claims == nil {
		return nil, fmt.Errorf("not authenticated")
	}

	cleaner, err := r.Queries.GetCleanerByUserID(ctx, stringToUUID(claims.UserID))
	if err != nil {
		return nil, fmt.Errorf("cleaner profile not found")
	}

	rows, err := r.Queries.ListCleanerServiceAreas(ctx, cleaner.ID)
	if err != nil {
		return nil, fmt.Errorf("failed to list cleaner areas: %w", err)
	}

	var result []*model.CityArea
	for _, row := range rows {
		result = append(result, &model.CityArea{
			ID:       uuidToString(row.CityAreaID),
			Name:     row.AreaName,
			CityID:   uuidToString(row.CityID),
			CityName: row.CityName,
		})
	}
	return result, nil
}

// SuggestCleaners is the resolver for the suggestCleaners field.
// It evaluates ALL provided time slots across multiple dates and finds the
// best date+time+worker combination, considering company schedules, worker
// availability, existing bookings, and workload balancing.
func (r *queryResolver) SuggestCleaners(ctx context.Context, cityID string, areaID string, timeSlots []*model.TimeSlotInput, estimatedDurationHours float64) ([]*model.CleanerSuggestion, error) {
	if len(timeSlots) == 0 {
		return nil, fmt.Errorf("at least one time slot is required")
	}

	// Load admin-tunable matchmaking config.
	config := loadMatchConfig(ctx, r.Queries)
	bufferMicros := config.BufferMicros()

	areaUUID := stringToUUID(areaID)
	jobDurationMicros := int64(estimatedDurationHours * float64(matching.HourMicros))

	// Step 1: Parse ALL time slots with date context.
	datedSlots := make([]matching.DatedTimeSlot, len(timeSlots))
	uniqueDates := map[string]time.Time{} // date string -> parsed time

	for i, ts := range timeSlots {
		d, err := time.Parse("2006-01-02", ts.Date)
		if err != nil {
			return nil, fmt.Errorf("invalid date in timeSlots[%d] (use YYYY-MM-DD): %w", i, err)
		}
		datedSlots[i] = matching.DatedTimeSlot{
			Date:        ts.Date,
			DayOfWeek:   int(d.Weekday()),
			StartMicros: matching.HHMMToMicros(ts.StartTime),
			EndMicros:   matching.HHMMToMicros(ts.EndTime),
			SlotIndex:   i,
		}
		uniqueDates[ts.Date] = d
	}

	// Compute the week range (Mon-Sun) spanning all requested dates for workload query.
	var weekStart, weekEnd time.Time
	for _, d := range uniqueDates {
		if weekStart.IsZero() || d.Before(weekStart) {
			weekStart = d
		}
		if weekEnd.IsZero() || d.After(weekEnd) {
			weekEnd = d
		}
	}
	// Extend to full Monday-Sunday week of the earliest date.
	offset := (int(weekStart.Weekday()) + 6) % 7 // Monday = 0
	weekStart = weekStart.AddDate(0, 0, -offset)
	weekEnd = weekStart.AddDate(0, 0, 6)

	weekStartPG := pgtype.Date{Time: weekStart, Valid: true}
	weekEndPG := pgtype.Date{Time: weekEnd, Valid: true}

	// Step 2: Find cleaners matching this area.
	candidates, err := r.Queries.FindMatchingCleaners(ctx, areaUUID)
	if err != nil {
		return nil, fmt.Errorf("failed to find matching cleaners: %w", err)
	}
	if len(candidates) == 0 {
		log.Printf("[MATCHMAKING] No matching cleaners found for areaID=%s. Check: 1) Active cleaners exist, 2) Companies approved, 3) Service areas configured",
			areaID)
		return []*model.CleanerSuggestion{}, nil
	}

	type scoredSuggestion struct {
		suggestion *model.CleanerSuggestion
		score      float64
	}
	var available []scoredSuggestion
	var unavailable []scoredSuggestion

	// Step 3: For each candidate, evaluate ALL dates.
	for _, candidate := range candidates {
		cleaner, err := r.Queries.GetCleanerByID(ctx, candidate.ID)
		if err != nil {
			continue
		}
		company, err := r.Queries.GetCompanyByID(ctx, candidate.CompanyID)
		if err != nil {
			continue
		}

		// Load company schedules once for this candidate.
		companySchedules, err := r.Queries.ListCompanyWorkSchedule(ctx, candidate.CompanyID)
		if err != nil {
			continue
		}
		companyScheduleByDay := map[int32]*db.CompanyWorkSchedule{}
		for i := range companySchedules {
			companyScheduleByDay[companySchedules[i].DayOfWeek] = &companySchedules[i]
		}

		// Load cleaner weekly availability once.
		weeklySlots, err := r.Queries.ListCleanerAvailability(ctx, candidate.ID)
		if err != nil {
			continue
		}

		// Load cleaner date overrides for the full date range.
		var overridesDateFrom, overridesDateTo pgtype.Date
		for _, d := range uniqueDates {
			pgd := pgtype.Date{Time: d, Valid: true}
			if !overridesDateFrom.Valid || d.Before(overridesDateFrom.Time) {
				overridesDateFrom = pgd
			}
			if !overridesDateTo.Valid || d.After(overridesDateTo.Time) {
				overridesDateTo = pgd
			}
		}
		overrides, err := r.Queries.ListCleanerDateOverrides(ctx, db.ListCleanerDateOverridesParams{
			CleanerID:      candidate.ID,
			OverrideDate:   overridesDateFrom,
			OverrideDate_2: overridesDateTo,
		})
		if err != nil {
			continue
		}
		overridesByDate := map[string]*db.CleanerDateOverride{}
		for i := range overrides {
			dateStr := overrides[i].OverrideDate.Time.Format("2006-01-02")
			overridesByDate[dateStr] = &overrides[i]
		}

		// Build DateAvailability for each unique date.
		var dateAvails []matching.DateAvailability

		for dateStr, d := range uniqueDates {
			dayOfWeek := int32(d.Weekday())

			// Check company schedule for this day.
			compDaySch := companyScheduleByDay[dayOfWeek]
			if compDaySch != nil && !compDaySch.IsWorkDay {
				continue // company doesn't work this day
			}

			// 4-tier availability cascade for this specific date.
			var availStart, availEnd int64
			skipDate := false

			// Tier 1: date override.
			if override, ok := overridesByDate[dateStr]; ok {
				if !override.IsAvailable {
					continue // cleaner explicitly unavailable on this date
				}
				availStart = override.StartTime.Microseconds
				availEnd = override.EndTime.Microseconds
			} else {
				// Tier 2: weekly slots.
				found := false
				for _, slot := range weeklySlots {
					if slot.DayOfWeek == dayOfWeek && boolVal(slot.IsAvailable) {
						availStart = slot.StartTime.Microseconds
						availEnd = slot.EndTime.Microseconds
						found = true
						break
					}
				}
				if !found {
					// Tier 3: company schedule.
					if compDaySch != nil && compDaySch.IsWorkDay {
						availStart = compDaySch.StartTime.Microseconds
						availEnd = compDaySch.EndTime.Microseconds
					} else if compDaySch == nil {
						// Tier 4: default 08:00-17:00.
						availStart = 8 * matching.HourMicros
						availEnd = 17 * matching.HourMicros
					} else {
						skipDate = true
					}
				}
			}
			if skipDate {
				continue
			}

			// Load existing bookings for this date.
			pgDate := pgtype.Date{Time: d, Valid: true}
			existingBookings, err := r.Queries.ListCleanerBookingsForDate(ctx, db.ListCleanerBookingsForDateParams{
				CleanerID:     candidate.ID,
				ScheduledDate: pgDate,
			})
			if err != nil {
				continue
			}

			bookingSlots := make([]matching.BookingSlot, len(existingBookings))
			for i, eb := range existingBookings {
				startMicros := eb.ScheduledStartTime.Microseconds
				durationHours := numericToFloat(eb.EstimatedDurationHours)
				endMicros := startMicros + int64(durationHours*float64(matching.HourMicros))
				bookingSlots[i] = matching.BookingSlot{
					StartMicros: startMicros,
					EndMicros:   endMicros,
				}
			}

			freeIntervals := matching.ComputeFreeIntervals(availStart, availEnd, bookingSlots, bufferMicros)

			dateAvails = append(dateAvails, matching.DateAvailability{
				Date:          dateStr,
				AvailStart:    availStart,
				AvailEnd:      availEnd,
				FreeIntervals: freeIntervals,
				BookingCount:  len(existingBookings),
			})
		}

		// Find the best date+time placement across all dates.
		placement := matching.FindBestPlacementAcrossDates(dateAvails, datedSlots, jobDurationMicros, config)

		// Load weekly workload for scoring.
		weekBookingCount, _ := r.Queries.CountCleanerBookingsInDateRange(ctx, db.CountCleanerBookingsInDateRangeParams{
			CleanerID:       candidate.ID,
			ScheduledDate:   weekStartPG,
			ScheduledDate_2: weekEndPG,
		})

		// Determine day booking count for the matched date.
		dayBookingCount := 0
		if placement.Found {
			for _, da := range dateAvails {
				if da.Date == placement.Date {
					dayBookingCount = da.BookingCount
					break
				}
			}
		}

		// Calculate match score with workload balancing.
		rating := numericToFloat(candidate.RatingAvg)
		jobs := 0
		if candidate.TotalJobsCompleted.Valid {
			jobs = int(candidate.TotalJobsCompleted.Int32)
		}

		score := matching.ComputeMatchScore(matching.ScoreInput{
			RatingAvg:        rating,
			TotalJobsDone:    jobs,
			IsAreaMatch:      true,
			PlacementFound:   placement.Found,
			GapScoreH:        placement.GapScoreH,
			DayBookingCount:  dayBookingCount,
			WeekBookingCount: int(weekBookingCount),
			Config:           config,
		})

		// Build suggestion.
		profile, err := r.cleanerWithCompany(ctx, cleaner)
		if err != nil {
			continue
		}

		availStatus := "available"
		if !placement.Found {
			availStatus = "unavailable"
		}

		suggestion := &model.CleanerSuggestion{
			Cleaner:            profile,
			Company:            dbCompanyToGQL(company),
			AvailabilityStatus: availStatus,
			MatchScore:         score,
		}

		if placement.Found {
			startStr := matching.MicrosToHHMM(placement.StartMicros)
			endStr := matching.MicrosToHHMM(placement.EndMicros)
			slotIdx := placement.SlotIndex
			dateStr := placement.Date
			suggestion.SuggestedStartTime = &startStr
			suggestion.SuggestedEndTime = &endStr
			suggestion.SuggestedSlotIndex = &slotIdx
			suggestion.SuggestedDate = &dateStr

			// Set availableFrom/To from the matched date's availability.
			for _, da := range dateAvails {
				if da.Date == placement.Date {
					availFromStr := microsecondsToHHMM(da.AvailStart)
					availToStr := microsecondsToHHMM(da.AvailEnd)
					suggestion.AvailableFrom = &availFromStr
					suggestion.AvailableTo = &availToStr
					break
				}
			}
		}

		scored := scoredSuggestion{suggestion: suggestion, score: score}
		if placement.Found {
			available = append(available, scored)
		} else {
			unavailable = append(unavailable, scored)
		}
	}

	// Sort each group by score DESC.
	sortSuggestions := func(s []scoredSuggestion) {
		for i := 0; i < len(s); i++ {
			for j := i + 1; j < len(s); j++ {
				if s[j].score > s[i].score {
					s[i], s[j] = s[j], s[i]
				}
			}
		}
	}
	sortSuggestions(available)
	sortSuggestions(unavailable)

	// Build final result: available first, backfill with unavailable only if needed.
	var result []*model.CleanerSuggestion
	limit := config.MaxResults

	for _, s := range available {
		if len(result) >= limit {
			break
		}
		result = append(result, s.suggestion)
	}

	// Only show unavailable workers if fewer than MinAvailableCount available.
	if len(result) < config.MinAvailableCount {
		for _, s := range unavailable {
			if len(result) >= limit {
				break
			}
			result = append(result, s.suggestion)
		}
	}

	log.Printf("[MATCHMAKING] areaID=%s: %d candidates, %d available, %d unavailable, returning %d",
		areaID, len(candidates), len(available), len(unavailable), len(result))

	return result, nil
}

// IsCitySupported is the resolver for the isCitySupported field.
func (r *queryResolver) IsCitySupported(ctx context.Context, city string) (bool, error) {
	_, err := r.Queries.GetCityByName(ctx, strings.TrimSpace(city))
	if err != nil {
		return false, nil // Not found = not supported.
	}
	return true, nil
}
