package resolver

// This file will be automatically regenerated based on the schema, any resolver
// implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.86

import (
	"context"
	"fmt"
	"helpmeclean-backend/internal/auth"
	db "helpmeclean-backend/internal/db/generated"
	"helpmeclean-backend/internal/graph/model"
	"math"
	"strings"
	"time"

	"github.com/jackc/pgx/v5/pgtype"
)

// CreateBookingRequest is the resolver for the createBookingRequest field.
func (r *mutationResolver) CreateBookingRequest(ctx context.Context, input model.CreateBookingInput) (*model.Booking, error) {
	var userID pgtype.UUID

	claims := auth.GetUserFromContext(ctx)
	if claims != nil {
		userID = stringToUUID(claims.UserID)
	} else {
		// Guest booking: require guest contact fields.
		if input.GuestEmail == nil || input.GuestName == nil || input.GuestPhone == nil {
			return nil, fmt.Errorf("guest bookings require guestEmail, guestName, and guestPhone")
		}

		// Find or create a guest user by email.
		existingUser, err := r.Queries.GetUserByEmail(ctx, *input.GuestEmail)
		if err == nil {
			userID = existingUser.ID
		} else {
			newUser, createErr := r.Queries.CreateUser(ctx, db.CreateUserParams{
				Email:             *input.GuestEmail,
				FullName:          *input.GuestName,
				Phone:             pgtype.Text{String: *input.GuestPhone, Valid: true},
				Role:              db.UserRoleClient,
				Status:            db.UserStatusActive,
				PreferredLanguage: pgtype.Text{String: "ro", Valid: true},
			})
			if createErr != nil {
				return nil, fmt.Errorf("failed to create guest user: %w", createErr)
			}
			userID = newUser.ID
		}
	}

	// Resolve address: reuse existing or create new.
	var addressID pgtype.UUID
	if input.AddressID != nil {
		// Reuse an existing saved address.
		addrUUID := stringToUUID(*input.AddressID)
		existing, err := r.Queries.GetAddressByID(ctx, addrUUID)
		if err != nil {
			return nil, fmt.Errorf("address not found: %w", err)
		}
		// Verify the address belongs to this user.
		if existing.UserID != userID {
			return nil, fmt.Errorf("address does not belong to this user")
		}
		addressID = existing.ID
	} else if input.Address != nil {
		// Create a new address from inline input.
		addr, err := r.Queries.CreateAddress(ctx, db.CreateAddressParams{
			UserID:        userID,
			Label:         stringToText(input.Address.Label),
			StreetAddress: input.Address.StreetAddress,
			City:          input.Address.City,
			County:        input.Address.County,
			PostalCode:    stringToText(input.Address.PostalCode),
			Floor:         stringToText(input.Address.Floor),
			Apartment:     stringToText(input.Address.Apartment),
			EntryCode:     stringToText(input.Address.EntryCode),
			Latitude:      float64PtrToFloat8(input.Address.Latitude),
			Longitude:     float64PtrToFloat8(input.Address.Longitude),
			Notes:         stringToText(input.Address.Notes),
			IsDefault:     pgtype.Bool{Bool: false, Valid: true},
		})
		if err != nil {
			return nil, fmt.Errorf("failed to create address: %w", err)
		}
		addressID = addr.ID
	} else {
		return nil, fmt.Errorf("either addressId or address input is required")
	}

	// Look up service definition for pricing.
	dbServiceType := gqlServiceTypeToDb(input.ServiceType)
	serviceDef, err := r.Queries.GetServiceByType(ctx, dbServiceType)
	if err != nil {
		return nil, fmt.Errorf("service type not found: %w", err)
	}

	hourlyRate := numericToFloat(serviceDef.BasePricePerHour)
	minHours := numericToFloat(serviceDef.MinHours)

	// Estimate hours.
	estimatedHours := float64(input.NumRooms)*0.5 + float64(input.NumBathrooms)*0.5
	if input.AreaSqm != nil {
		estimatedHours += float64(*input.AreaSqm) / 100.0
	}
	if estimatedHours < minHours {
		estimatedHours = minHours
	}
	estimatedHours = math.Round(estimatedHours*2) / 2

	estimatedTotal := hourlyRate * estimatedHours

	// Add extras cost.
	if input.Extras != nil {
		for _, extraInput := range input.Extras {
			extra, err := r.Queries.GetExtraByID(ctx, stringToUUID(extraInput.ExtraID))
			if err != nil {
				return nil, fmt.Errorf("extra not found: %w", err)
			}
			estimatedTotal += numericToFloat(extra.Price) * float64(extraInput.Quantity)
		}
	}

	// Parse scheduled date.
	scheduledDate, err := time.Parse("2006-01-02", input.ScheduledDate)
	if err != nil {
		return nil, fmt.Errorf("invalid scheduled date format: %w", err)
	}

	// Parse scheduled start time.
	scheduledTime, err := time.Parse("15:04", input.ScheduledStartTime)
	if err != nil {
		return nil, fmt.Errorf("invalid scheduled start time format: %w", err)
	}

	referenceCode := fmt.Sprintf("HMC-%d", time.Now().UnixNano()%1000000)

	booking, err := r.Queries.CreateBooking(ctx, db.CreateBookingParams{
		ReferenceCode: referenceCode,
		ClientUserID:  userID,
		AddressID:     addressID,
		ServiceType:   dbServiceType,
		ScheduledDate: pgtype.Date{
			Time:  scheduledDate,
			Valid: true,
		},
		ScheduledStartTime: pgtype.Time{
			Microseconds: int64(scheduledTime.Hour())*3_600_000_000 + int64(scheduledTime.Minute())*60_000_000,
			Valid:        true,
		},
		EstimatedDurationHours: float64ToNumeric(estimatedHours),
		PropertyType:           stringToText(input.PropertyType),
		NumRooms:               intToInt4Val(input.NumRooms),
		NumBathrooms:           intToInt4Val(input.NumBathrooms),
		AreaSqm:                intToInt4(input.AreaSqm),
		HasPets:                boolToPgBool(input.HasPets),
		SpecialInstructions:    stringToText(input.SpecialInstructions),
		HourlyRate:             float64ToNumeric(hourlyRate),
		EstimatedTotal:         float64ToNumeric(estimatedTotal),
	})
	if err != nil {
		return nil, fmt.Errorf("failed to create booking: %w", err)
	}

	return dbBookingToGQL(booking), nil
}

// CancelBooking is the resolver for the cancelBooking field.
func (r *mutationResolver) CancelBooking(ctx context.Context, id string, reason *string) (*model.Booking, error) {
	claims := auth.GetUserFromContext(ctx)
	if claims == nil {
		return nil, fmt.Errorf("not authenticated")
	}

	// Determine cancel status based on the user's role.
	var cancelStatus db.BookingStatus
	switch claims.Role {
	case "company_admin":
		cancelStatus = db.BookingStatusCancelledByCompany
	case "global_admin":
		cancelStatus = db.BookingStatusCancelledByAdmin
	default:
		cancelStatus = db.BookingStatusCancelledByClient
	}

	// Validate status transition.
	current, err := r.Queries.GetBookingByID(ctx, stringToUUID(id))
	if err != nil {
		return nil, fmt.Errorf("booking not found: %w", err)
	}
	if err := validateStatusTransition(current.Status, cancelStatus); err != nil {
		return nil, err
	}

	var reasonText string
	if reason != nil {
		reasonText = *reason
	}

	booking, err := r.Queries.CancelBookingWithReason(ctx, db.CancelBookingWithReasonParams{
		ID:                 stringToUUID(id),
		Status:             cancelStatus,
		CancellationReason: pgtype.Text{String: reasonText, Valid: reasonText != ""},
	})
	if err != nil {
		return nil, fmt.Errorf("failed to cancel booking: %w", err)
	}

	return dbBookingToGQL(booking), nil
}

// PayForBooking is the resolver for the payForBooking field.
func (r *mutationResolver) PayForBooking(ctx context.Context, id string, paymentMethodID *string) (*model.Booking, error) {
	claims := auth.GetUserFromContext(ctx)
	if claims == nil {
		return nil, fmt.Errorf("not authenticated")
	}

	// For MVP, just mark as paid (mock Stripe).
	booking, err := r.Queries.MarkBookingPaid(ctx, stringToUUID(id))
	if err != nil {
		return nil, fmt.Errorf("failed to mark booking as paid: %w", err)
	}

	return dbBookingToGQL(booking), nil
}

// AssignCleanerToBooking is the resolver for the assignCleanerToBooking field.
func (r *mutationResolver) AssignCleanerToBooking(ctx context.Context, bookingID string, cleanerID string) (*model.Booking, error) {
	claims := auth.GetUserFromContext(ctx)
	if claims == nil {
		return nil, fmt.Errorf("not authenticated")
	}

	// Validate status transition.
	current, err := r.Queries.GetBookingByID(ctx, stringToUUID(bookingID))
	if err != nil {
		return nil, fmt.Errorf("booking not found: %w", err)
	}
	if err := validateStatusTransition(current.Status, db.BookingStatusAssigned); err != nil {
		return nil, err
	}

	// Look up the cleaner to get the company ID.
	cleaner, err := r.Queries.GetCleanerByID(ctx, stringToUUID(cleanerID))
	if err != nil {
		return nil, fmt.Errorf("cleaner not found: %w", err)
	}

	booking, err := r.Queries.AssignCleanerToBooking(ctx, db.AssignCleanerToBookingParams{
		ID:        stringToUUID(bookingID),
		CompanyID: cleaner.CompanyID,
		CleanerID: cleaner.ID,
	})
	if err != nil {
		return nil, fmt.Errorf("failed to assign cleaner: %w", err)
	}

	return dbBookingToGQL(booking), nil
}

// ConfirmBooking is the resolver for the confirmBooking field.
func (r *mutationResolver) ConfirmBooking(ctx context.Context, id string) (*model.Booking, error) {
	claims := auth.GetUserFromContext(ctx)
	if claims == nil {
		return nil, fmt.Errorf("not authenticated")
	}

	// Validate status transition.
	current, err := r.Queries.GetBookingByID(ctx, stringToUUID(id))
	if err != nil {
		return nil, fmt.Errorf("booking not found: %w", err)
	}
	if err := validateStatusTransition(current.Status, db.BookingStatusConfirmed); err != nil {
		return nil, err
	}

	booking, err := r.Queries.UpdateBookingStatus(ctx, db.UpdateBookingStatusParams{
		ID:     stringToUUID(id),
		Status: db.BookingStatusConfirmed,
	})
	if err != nil {
		return nil, fmt.Errorf("failed to confirm booking: %w", err)
	}

	// Auto-create chat room between client and cleaner (non-blocking).
	go func() {
		r.createBookingChat(context.Background(), booking, claims.UserID)
	}()

	return dbBookingToGQL(booking), nil
}

// StartJob is the resolver for the startJob field.
func (r *mutationResolver) StartJob(ctx context.Context, id string) (*model.Booking, error) {
	claims := auth.GetUserFromContext(ctx)
	if claims == nil {
		return nil, fmt.Errorf("not authenticated")
	}

	// Validate status transition.
	current, err := r.Queries.GetBookingByID(ctx, stringToUUID(id))
	if err != nil {
		return nil, fmt.Errorf("booking not found: %w", err)
	}
	if err := validateStatusTransition(current.Status, db.BookingStatusInProgress); err != nil {
		return nil, err
	}

	booking, err := r.Queries.StartBooking(ctx, stringToUUID(id))
	if err != nil {
		return nil, fmt.Errorf("failed to start job: %w", err)
	}

	return dbBookingToGQL(booking), nil
}

// CompleteJob is the resolver for the completeJob field.
func (r *mutationResolver) CompleteJob(ctx context.Context, id string) (*model.Booking, error) {
	claims := auth.GetUserFromContext(ctx)
	if claims == nil {
		return nil, fmt.Errorf("not authenticated")
	}

	// Validate status transition.
	current, err := r.Queries.GetBookingByID(ctx, stringToUUID(id))
	if err != nil {
		return nil, fmt.Errorf("booking not found: %w", err)
	}
	if err := validateStatusTransition(current.Status, db.BookingStatusCompleted); err != nil {
		return nil, err
	}

	booking, err := r.Queries.CompleteBooking(ctx, stringToUUID(id))
	if err != nil {
		return nil, fmt.Errorf("failed to complete job: %w", err)
	}

	// Calculate final total and platform commission.
	estimatedTotal := numericToFloat(booking.EstimatedTotal)
	commissionPct := numericToFloat(booking.PlatformCommissionPct)
	commissionAmount := estimatedTotal * (commissionPct / 100.0)

	booking, err = r.Queries.SetBookingFinalTotal(ctx, db.SetBookingFinalTotalParams{
		ID:                       booking.ID,
		FinalTotal:               float64ToNumeric(estimatedTotal),
		PlatformCommissionAmount: float64ToNumeric(commissionAmount),
	})
	if err != nil {
		return nil, fmt.Errorf("failed to set final total: %w", err)
	}

	return dbBookingToGQL(booking), nil
}

// MyBookings is the resolver for the myBookings field.
func (r *queryResolver) MyBookings(ctx context.Context, status *model.BookingStatus, first *int, after *string) (*model.BookingConnection, error) {
	claims := auth.GetUserFromContext(ctx)
	if claims == nil {
		return nil, fmt.Errorf("not authenticated")
	}

	limit := int32(20)
	if first != nil {
		limit = int32(*first)
	}
	offset := int32(0)
	if after != nil {
		// Simple offset-based pagination: after is the offset as a string.
		fmt.Sscanf(*after, "%d", &offset)
	}

	var bookings []db.Booking
	var err error
	if status != nil {
		bookings, err = r.Queries.ListBookingsByClientAndStatus(ctx, db.ListBookingsByClientAndStatusParams{
			ClientUserID: stringToUUID(claims.UserID),
			Status:       gqlBookingStatusToDb(*status),
			Limit:        limit + 1,
			Offset:       offset,
		})
	} else {
		bookings, err = r.Queries.ListBookingsByClient(ctx, db.ListBookingsByClientParams{
			ClientUserID: stringToUUID(claims.UserID),
			Limit:        limit + 1,
			Offset:       offset,
		})
	}
	if err != nil {
		return nil, fmt.Errorf("failed to list bookings: %w", err)
	}

	hasNext := len(bookings) > int(limit)
	if hasNext {
		bookings = bookings[:limit]
	}

	edges := make([]*model.Booking, len(bookings))
	for i, b := range bookings {
		gqlBooking := dbBookingToGQL(b)
		r.enrichBooking(ctx, b, gqlBooking)
		edges[i] = gqlBooking
	}

	var endCursor *string
	if len(bookings) > 0 {
		c := fmt.Sprintf("%d", offset+limit)
		endCursor = &c
	}

	return &model.BookingConnection{
		Edges: edges,
		PageInfo: &model.PageInfo{
			HasNextPage: hasNext,
			EndCursor:   endCursor,
		},
		TotalCount: len(edges),
	}, nil
}

// Booking is the resolver for the booking field.
func (r *queryResolver) Booking(ctx context.Context, id string) (*model.Booking, error) {
	claims := auth.GetUserFromContext(ctx)
	if claims == nil {
		return nil, fmt.Errorf("not authenticated")
	}

	booking, err := r.Queries.GetBookingByID(ctx, stringToUUID(id))
	if err != nil {
		return nil, fmt.Errorf("booking not found: %w", err)
	}

	result := dbBookingToGQL(booking)
	r.enrichBooking(ctx, booking, result)

	return result, nil
}

// CompanyBookings is the resolver for the companyBookings field.
func (r *queryResolver) CompanyBookings(ctx context.Context, status *model.BookingStatus, first *int, after *string) (*model.BookingConnection, error) {
	claims := auth.GetUserFromContext(ctx)
	if claims == nil {
		return nil, fmt.Errorf("not authenticated")
	}

	// Look up the company for the current user.
	company, err := r.Queries.GetCompanyByAdminUserID(ctx, stringToUUID(claims.UserID))
	if err != nil {
		return nil, fmt.Errorf("company not found for user: %w", err)
	}

	limit := int32(20)
	if first != nil {
		limit = int32(*first)
	}
	offset := int32(0)
	if after != nil {
		fmt.Sscanf(*after, "%d", &offset)
	}

	var bookings []db.Booking
	if status != nil {
		bookings, err = r.Queries.ListBookingsByCompanyAndStatus(ctx, db.ListBookingsByCompanyAndStatusParams{
			CompanyID: company.ID,
			Status:    gqlBookingStatusToDb(*status),
			Limit:     limit + 1,
			Offset:    offset,
		})
	} else {
		bookings, err = r.Queries.ListBookingsByCompany(ctx, db.ListBookingsByCompanyParams{
			CompanyID: company.ID,
			Limit:     limit + 1,
			Offset:    offset,
		})
	}
	if err != nil {
		return nil, fmt.Errorf("failed to list company bookings: %w", err)
	}

	hasNext := len(bookings) > int(limit)
	if hasNext {
		bookings = bookings[:limit]
	}

	edges := make([]*model.Booking, len(bookings))
	for i, b := range bookings {
		gqlBooking := dbBookingToGQL(b)
		r.enrichBooking(ctx, b, gqlBooking)
		edges[i] = gqlBooking
	}

	var endCursor *string
	if len(bookings) > 0 {
		c := fmt.Sprintf("%d", offset+limit)
		endCursor = &c
	}

	return &model.BookingConnection{
		Edges: edges,
		PageInfo: &model.PageInfo{
			HasNextPage: hasNext,
			EndCursor:   endCursor,
		},
		TotalCount: len(edges),
	}, nil
}

// MyAssignedJobs is the resolver for the myAssignedJobs field.
func (r *queryResolver) MyAssignedJobs(ctx context.Context, status *model.BookingStatus) ([]*model.Booking, error) {
	claims := auth.GetUserFromContext(ctx)
	if claims == nil {
		return nil, fmt.Errorf("not authenticated")
	}

	cleaner, err := r.Queries.GetCleanerByUserID(ctx, stringToUUID(claims.UserID))
	if err != nil {
		return nil, fmt.Errorf("cleaner profile not found: %w", err)
	}

	bookings, err := r.Queries.ListBookingsByCleaner(ctx, cleaner.ID)
	if err != nil {
		return nil, fmt.Errorf("failed to list assigned jobs: %w", err)
	}

	// Filter by status if provided, and enrich with related entities.
	var result []*model.Booking
	for _, b := range bookings {
		gqlBooking := dbBookingToGQL(b)
		if status != nil && gqlBooking.Status != *status {
			continue
		}
		r.enrichBooking(ctx, b, gqlBooking)
		result = append(result, gqlBooking)
	}

	return result, nil
}

// TodaysJobs is the resolver for the todaysJobs field.
func (r *queryResolver) TodaysJobs(ctx context.Context) ([]*model.Booking, error) {
	claims := auth.GetUserFromContext(ctx)
	if claims == nil {
		return nil, fmt.Errorf("not authenticated")
	}

	cleaner, err := r.Queries.GetCleanerByUserID(ctx, stringToUUID(claims.UserID))
	if err != nil {
		return nil, fmt.Errorf("cleaner profile not found: %w", err)
	}

	bookings, err := r.Queries.ListTodaysJobsByCleaner(ctx, cleaner.ID)
	if err != nil {
		return nil, fmt.Errorf("failed to list today's jobs: %w", err)
	}

	result := make([]*model.Booking, len(bookings))
	for i, b := range bookings {
		gqlBooking := dbBookingToGQL(b)
		r.enrichBooking(ctx, b, gqlBooking)
		result[i] = gqlBooking
	}

	return result, nil
}

// AllBookings is the resolver for the allBookings field.
func (r *queryResolver) AllBookings(ctx context.Context, status *model.BookingStatus, companyID *string, dateFrom *string, dateTo *string, first *int, after *string) (*model.BookingConnection, error) {
	claims := auth.GetUserFromContext(ctx)
	if claims == nil {
		return nil, fmt.Errorf("not authenticated")
	}

	limit := int32(20)
	if first != nil {
		limit = int32(*first)
	}
	offset := int32(0)
	if after != nil {
		fmt.Sscanf(*after, "%d", &offset)
	}

	var bookings []db.Booking
	var err error

	if status != nil {
		bookings, err = r.Queries.ListBookingsByStatus(ctx, db.ListBookingsByStatusParams{
			Status: gqlBookingStatusToDb(*status),
			Limit:  limit + 1,
			Offset: offset,
		})
	} else {
		bookings, err = r.Queries.ListAllBookings(ctx, db.ListAllBookingsParams{
			Limit:  limit + 1,
			Offset: offset,
		})
	}
	if err != nil {
		return nil, fmt.Errorf("failed to list all bookings: %w", err)
	}

	hasNext := len(bookings) > int(limit)
	if hasNext {
		bookings = bookings[:limit]
	}

	edges := make([]*model.Booking, len(bookings))
	for i, b := range bookings {
		gqlBooking := dbBookingToGQL(b)
		r.enrichBooking(ctx, b, gqlBooking)
		edges[i] = gqlBooking
	}

	var endCursor *string
	if len(bookings) > 0 {
		c := fmt.Sprintf("%d", offset+limit)
		endCursor = &c
	}

	return &model.BookingConnection{
		Edges: edges,
		PageInfo: &model.PageInfo{
			HasNextPage: hasNext,
			EndCursor:   endCursor,
		},
		TotalCount: len(edges),
	}, nil
}

// CompanyBookingsByDateRange is the resolver for the companyBookingsByDateRange field.
func (r *queryResolver) CompanyBookingsByDateRange(ctx context.Context, from string, to string) ([]*model.Booking, error) {
	claims := auth.GetUserFromContext(ctx)
	if claims == nil {
		return nil, fmt.Errorf("not authenticated")
	}

	company, err := r.Queries.GetCompanyByAdminUserID(ctx, stringToUUID(claims.UserID))
	if err != nil {
		return nil, fmt.Errorf("company not found for user: %w", err)
	}

	fromDate, err := time.Parse("2006-01-02", from)
	if err != nil {
		return nil, fmt.Errorf("invalid 'from' date: %w", err)
	}
	toDate, err := time.Parse("2006-01-02", to)
	if err != nil {
		return nil, fmt.Errorf("invalid 'to' date: %w", err)
	}

	bookings, err := r.Queries.ListBookingsByCompanyAndDateRange(ctx, db.ListBookingsByCompanyAndDateRangeParams{
		CompanyID: company.ID,
		DateFrom:  pgtype.Date{Time: fromDate, Valid: true},
		DateTo:    pgtype.Date{Time: toDate, Valid: true},
	})
	if err != nil {
		return nil, fmt.Errorf("failed to list bookings by date range: %w", err)
	}

	result := make([]*model.Booking, len(bookings))
	for i, b := range bookings {
		gqlBooking := dbBookingToGQL(b)
		r.enrichBooking(ctx, b, gqlBooking)
		result[i] = gqlBooking
	}

	return result, nil
}

// SearchCompanyBookings is the resolver for the searchCompanyBookings field.
func (r *queryResolver) SearchCompanyBookings(ctx context.Context, query *string, status *string, dateFrom *string, dateTo *string, limit *int, offset *int) (*model.BookingConnection, error) {
	claims := auth.GetUserFromContext(ctx)
	if claims == nil {
		return nil, fmt.Errorf("not authenticated")
	}

	company, err := r.Queries.GetCompanyByAdminUserID(ctx, stringToUUID(claims.UserID))
	if err != nil {
		return nil, fmt.Errorf("company not found for user: %w", err)
	}

	qLimit := int32(20)
	if limit != nil {
		qLimit = int32(*limit)
	}
	qOffset := int32(0)
	if offset != nil {
		qOffset = int32(*offset)
	}

	var queryStr string
	if query != nil {
		queryStr = *query
	}
	var statusStr string
	if status != nil {
		statusStr = strings.ToLower(*status)
	}

	// Parse date filters â€” use zero date sentinel to skip filter in SQL.
	zeroDate := pgtype.Date{Time: time.Date(1, 1, 1, 0, 0, 0, 0, time.UTC), Valid: true}
	fromDate := zeroDate
	toDate := zeroDate
	if dateFrom != nil {
		if t, err := time.Parse("2006-01-02", *dateFrom); err == nil {
			fromDate = pgtype.Date{Time: t, Valid: true}
		}
	}
	if dateTo != nil {
		if t, err := time.Parse("2006-01-02", *dateTo); err == nil {
			toDate = pgtype.Date{Time: t, Valid: true}
		}
	}

	bookings, err := r.Queries.SearchCompanyBookings(ctx, db.SearchCompanyBookingsParams{
		CompanyID:    company.ID,
		Limit:        qLimit + 1,
		Offset:       qOffset,
		Query:        queryStr,
		StatusFilter: statusStr,
		DateFrom:     fromDate,
		DateTo:       toDate,
	})
	if err != nil {
		return nil, fmt.Errorf("failed to search company bookings: %w", err)
	}

	hasNext := len(bookings) > int(qLimit)
	if hasNext {
		bookings = bookings[:qLimit]
	}

	edges := make([]*model.Booking, len(bookings))
	for i, b := range bookings {
		gqlBooking := dbBookingToGQL(b)
		r.enrichBooking(ctx, b, gqlBooking)
		edges[i] = gqlBooking
	}

	// Get total count.
	total, _ := r.Queries.CountSearchCompanyBookings(ctx, db.CountSearchCompanyBookingsParams{
		CompanyID:    company.ID,
		Query:        queryStr,
		StatusFilter: statusStr,
		DateFrom:     fromDate,
		DateTo:       toDate,
	})

	return &model.BookingConnection{
		Edges: edges,
		PageInfo: &model.PageInfo{
			HasNextPage: hasNext,
		},
		TotalCount: int(total),
	}, nil
}
