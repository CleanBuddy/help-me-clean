package resolver

// This file will be automatically regenerated based on the schema, any resolver
// implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.86

import (
	"context"
	"fmt"
	"helpmeclean-backend/internal/auth"
	db "helpmeclean-backend/internal/db/generated"
	"helpmeclean-backend/internal/graph/model"
	"log"
	"strings"
	"time"

	"github.com/jackc/pgx/v5/pgtype"
)

// CreateBookingRequest is the resolver for the createBookingRequest field.
func (r *mutationResolver) CreateBookingRequest(ctx context.Context, input model.CreateBookingInput) (*model.Booking, error) {
	var userID pgtype.UUID

	claims := auth.GetUserFromContext(ctx)
	if claims != nil {
		userID = stringToUUID(claims.UserID)
	} else {
		// Guest booking: require guest contact fields.
		if input.GuestEmail == nil || input.GuestName == nil || input.GuestPhone == nil {
			return nil, fmt.Errorf("guest bookings require guestEmail, guestName, and guestPhone")
		}

		// Find or create a guest user by email.
		existingUser, err := r.Queries.GetUserByEmail(ctx, *input.GuestEmail)
		if err == nil {
			userID = existingUser.ID
		} else {
			newUser, createErr := r.Queries.CreateUser(ctx, db.CreateUserParams{
				Email:             *input.GuestEmail,
				FullName:          *input.GuestName,
				Phone:             pgtype.Text{String: *input.GuestPhone, Valid: true},
				Role:              db.UserRoleClient,
				Status:            db.UserStatusActive,
				PreferredLanguage: pgtype.Text{String: "ro", Valid: true},
			})
			if createErr != nil {
				return nil, fmt.Errorf("failed to create guest user: %w", createErr)
			}
			userID = newUser.ID
		}
	}

	// Resolve address: reuse existing or create new.
	var addressID pgtype.UUID
	if input.AddressID != nil {
		// Reuse an existing saved address.
		addrUUID := stringToUUID(*input.AddressID)
		existing, err := r.Queries.GetAddressByID(ctx, addrUUID)
		if err != nil {
			return nil, fmt.Errorf("address not found: %w", err)
		}
		// Verify the address belongs to this user.
		if existing.UserID != userID {
			return nil, fmt.Errorf("address does not belong to this user")
		}
		addressID = existing.ID
	} else if input.Address != nil {
		// Create a new address from inline input.
		addr, err := r.Queries.CreateAddress(ctx, db.CreateAddressParams{
			UserID:        userID,
			Label:         stringToText(input.Address.Label),
			StreetAddress: input.Address.StreetAddress,
			City:          input.Address.City,
			County:        input.Address.County,
			PostalCode:    stringToText(input.Address.PostalCode),
			Floor:         stringToText(input.Address.Floor),
			Apartment:     stringToText(input.Address.Apartment),
			EntryCode:     stringToText(input.Address.EntryCode),
			Latitude:      float64PtrToFloat8(input.Address.Latitude),
			Longitude:     float64PtrToFloat8(input.Address.Longitude),
			Notes:         stringToText(input.Address.Notes),
			IsDefault:     pgtype.Bool{Bool: false, Valid: true},
		})
		if err != nil {
			return nil, fmt.Errorf("failed to create address: %w", err)
		}
		addressID = addr.ID
	} else {
		return nil, fmt.Errorf("either addressId or address input is required")
	}

	// Validate city is supported (enabled and active).
	var addrCity string
	if input.AddressID != nil {
		addr, _ := r.Queries.GetAddressByID(ctx, addressID)
		addrCity = addr.City
	} else if input.Address != nil {
		addrCity = input.Address.City
	}
	if addrCity != "" {
		_, cityErr := r.Queries.GetCityByName(ctx, strings.TrimSpace(addrCity))
		if cityErr != nil {
			return nil, fmt.Errorf("ne pare rau, nu suntem inca activi in %s", addrCity)
		}
	}

	// Look up service definition for pricing.
	dbServiceType := gqlServiceTypeToDb(input.ServiceType)
	serviceDef, err := r.Queries.GetServiceByType(ctx, dbServiceType)
	if err != nil {
		return nil, fmt.Errorf("service type not found: %w", err)
	}

	hourlyRate := numericToFloat(serviceDef.BasePricePerHour)

	// Fetch extras for duration and pricing.
	var extrasDuration []struct {
		DurationMinutes int32
		Quantity        int
	}
	extrasTotal := 0.0
	if input.Extras != nil {
		for _, extraInput := range input.Extras {
			extra, err := r.Queries.GetExtraByID(ctx, stringToUUID(extraInput.ExtraID))
			if err != nil {
				return nil, fmt.Errorf("extra not found: %w", err)
			}
			extrasTotal += numericToFloat(extra.Price) * float64(extraInput.Quantity)
			extrasDuration = append(extrasDuration, struct {
				DurationMinutes int32
				Quantity        int
			}{DurationMinutes: extra.DurationMinutes, Quantity: extraInput.Quantity})
		}
	}

	// Estimate duration using DB-driven parameters.
	estimatedHours := estimateDuration(serviceDef, input.NumRooms, input.NumBathrooms, input.AreaSqm, input.PropertyType, input.HasPets, extrasDuration)

	subtotal := hourlyRate * estimatedHours

	// Pets surcharge (flat fee).
	petsSurcharge := 0.0
	if input.HasPets != nil && *input.HasPets {
		petsSurcharge = 15.0
	}

	estimatedTotal := subtotal + extrasTotal + petsSurcharge

	// Resolve scheduled date/time from timeSlots or legacy fields.
	var scheduledDate time.Time
	var scheduledTime time.Time

	if input.TimeSlots != nil && len(input.TimeSlots) > 0 {
		// Use first time slot.
		scheduledDate, err = time.Parse("2006-01-02", input.TimeSlots[0].Date)
		if err != nil {
			return nil, fmt.Errorf("invalid time slot date format: %w", err)
		}
		scheduledTime, err = time.Parse("15:04", input.TimeSlots[0].StartTime)
		if err != nil {
			return nil, fmt.Errorf("invalid time slot start time format: %w", err)
		}
	} else if input.ScheduledDate != nil && input.ScheduledStartTime != nil {
		// Legacy single date/time.
		scheduledDate, err = time.Parse("2006-01-02", *input.ScheduledDate)
		if err != nil {
			return nil, fmt.Errorf("invalid scheduled date format: %w", err)
		}
		scheduledTime, err = time.Parse("15:04", *input.ScheduledStartTime)
		if err != nil {
			return nil, fmt.Errorf("invalid scheduled start time format: %w", err)
		}
	} else {
		return nil, fmt.Errorf("either timeSlots or scheduledDate+scheduledStartTime is required")
	}

	// Override with system-optimized start time from matchmaking if provided.
	if input.SuggestedStartTime != nil && *input.SuggestedStartTime != "" {
		suggested, parseErr := time.Parse("15:04", *input.SuggestedStartTime)
		if parseErr == nil {
			scheduledTime = suggested
		}
	}

	referenceCode := fmt.Sprintf("HMC-%d", time.Now().UnixNano()%1000000)

	booking, err := r.Queries.CreateBooking(ctx, db.CreateBookingParams{
		ReferenceCode: referenceCode,
		ClientUserID:  userID,
		AddressID:     addressID,
		ServiceType:   dbServiceType,
		ScheduledDate: pgtype.Date{
			Time:  scheduledDate,
			Valid: true,
		},
		ScheduledStartTime: pgtype.Time{
			Microseconds: int64(scheduledTime.Hour())*3_600_000_000 + int64(scheduledTime.Minute())*60_000_000,
			Valid:        true,
		},
		EstimatedDurationHours: float64ToNumeric(estimatedHours),
		PropertyType:           stringToText(input.PropertyType),
		NumRooms:               intToInt4Val(input.NumRooms),
		NumBathrooms:           intToInt4Val(input.NumBathrooms),
		AreaSqm:                intToInt4(input.AreaSqm),
		HasPets:                boolToPgBool(input.HasPets),
		SpecialInstructions:    stringToText(input.SpecialInstructions),
		HourlyRate:             float64ToNumeric(hourlyRate),
		EstimatedTotal:         float64ToNumeric(estimatedTotal),
		RecurringGroupID:       pgtype.UUID{},
		OccurrenceNumber:       pgtype.Int4{},
	})
	if err != nil {
		return nil, fmt.Errorf("failed to create booking: %w", err)
	}

	// Insert time slots if provided.
	if input.TimeSlots != nil && len(input.TimeSlots) > 0 {
		for i, slot := range input.TimeSlots {
			slotDate, _ := time.Parse("2006-01-02", slot.Date)
			slotStartTime := parseHHMMToTime(slot.StartTime)
			slotEndTime := parseHHMMToTime(slot.EndTime)

			_, tsErr := r.Queries.CreateBookingTimeSlot(ctx, db.CreateBookingTimeSlotParams{
				BookingID:  booking.ID,
				SlotDate:   pgtype.Date{Time: slotDate, Valid: true},
				StartTime:  slotStartTime,
				EndTime:    slotEndTime,
				IsSelected: i == 0,
			})
			if tsErr != nil {
				log.Printf("failed to create time slot %d: %v", i, tsErr)
			}
		}
	}

	// If preferred cleaner was selected, set company_id and cleaner_id (status stays pending).
	if input.PreferredCleanerID != nil && *input.PreferredCleanerID != "" {
		cleanerUUID := stringToUUID(*input.PreferredCleanerID)
		cleaner, err := r.Queries.GetCleanerByID(ctx, cleanerUUID)
		if err == nil {
			booking, _ = r.Queries.SetBookingPreferredCleaner(ctx, db.SetBookingPreferredCleanerParams{
				ID:        booking.ID,
				CompanyID: cleaner.CompanyID,
				CleanerID: cleanerUUID,
			})
		}
	}

	// Handle recurring bookings: generate future occurrences.
	if input.Recurrence != nil && input.PreferredCleanerID != nil && *input.PreferredCleanerID != "" {
		cleanerUUID := stringToUUID(*input.PreferredCleanerID)
		cleaner, cleanerErr := r.Queries.GetCleanerByID(ctx, cleanerUUID)
		if cleanerErr == nil {
			group, groupErr := r.createRecurringGroup(ctx, createRecurringGroupInput{
				clientUserID:        userID,
				companyID:           cleaner.CompanyID,
				cleanerID:           cleanerUUID,
				addressID:           addressID,
				recurrenceType:      gqlRecurrenceTypeToDb(input.Recurrence.Type),
				dayOfWeek:           input.Recurrence.DayOfWeek,
				preferredTime:       scheduledTime,
				serviceType:         dbServiceType,
				propertyType:        input.PropertyType,
				numRooms:            input.NumRooms,
				numBathrooms:        input.NumBathrooms,
				areaSqm:             input.AreaSqm,
				hasPets:             input.HasPets,
				specialInstructions: input.SpecialInstructions,
				hourlyRate:          hourlyRate,
				estimatedTotal:      estimatedTotal,
				estimatedHours:      estimatedHours,
				extras:              input.Extras,
				firstBooking:        booking,
			})
			if groupErr != nil {
				log.Printf("failed to create recurring group: %v", groupErr)
			} else {
				// Update first booking with group link (for return value).
				booking.RecurringGroupID = group.ID
				booking.OccurrenceNumber = pgtype.Int4{Int32: 1, Valid: true}
			}
		}
	}

	gqlBooking := dbBookingToGQL(booking)
	r.enrichBooking(ctx, booking, gqlBooking)
	return gqlBooking, nil
}

// CancelBooking is the resolver for the cancelBooking field.
func (r *mutationResolver) CancelBooking(ctx context.Context, id string, reason *string) (*model.Booking, error) {
	claims := auth.GetUserFromContext(ctx)
	if claims == nil {
		return nil, fmt.Errorf("not authenticated")
	}

	// Determine cancel status based on the user's role.
	var cancelStatus db.BookingStatus
	switch claims.Role {
	case "company_admin":
		cancelStatus = db.BookingStatusCancelledByCompany
	case "global_admin":
		cancelStatus = db.BookingStatusCancelledByAdmin
	default:
		cancelStatus = db.BookingStatusCancelledByClient
	}

	// Validate status transition.
	current, err := r.Queries.GetBookingByID(ctx, stringToUUID(id))
	if err != nil {
		return nil, fmt.Errorf("booking not found: %w", err)
	}
	if err := validateStatusTransition(current.Status, cancelStatus); err != nil {
		return nil, err
	}

	var reasonText string
	if reason != nil {
		reasonText = *reason
	}

	booking, err := r.Queries.CancelBookingWithReason(ctx, db.CancelBookingWithReasonParams{
		ID:                 stringToUUID(id),
		Status:             cancelStatus,
		CancellationReason: pgtype.Text{String: reasonText, Valid: reasonText != ""},
	})
	if err != nil {
		return nil, fmt.Errorf("failed to cancel booking: %w", err)
	}

	return dbBookingToGQL(booking), nil
}

// AssignCleanerToBooking is the resolver for the assignCleanerToBooking field.
func (r *mutationResolver) AssignCleanerToBooking(ctx context.Context, bookingID string, cleanerID string) (*model.Booking, error) {
	claims := auth.GetUserFromContext(ctx)
	if claims == nil {
		return nil, fmt.Errorf("not authenticated")
	}

	// Validate status transition.
	current, err := r.Queries.GetBookingByID(ctx, stringToUUID(bookingID))
	if err != nil {
		return nil, fmt.Errorf("booking not found: %w", err)
	}
	if err := validateStatusTransition(current.Status, db.BookingStatusAssigned); err != nil {
		return nil, err
	}

	// Look up the cleaner to get the company ID.
	cleaner, err := r.Queries.GetCleanerByID(ctx, stringToUUID(cleanerID))
	if err != nil {
		return nil, fmt.Errorf("cleaner not found: %w", err)
	}

	booking, err := r.Queries.AssignCleanerToBooking(ctx, db.AssignCleanerToBookingParams{
		ID:        stringToUUID(bookingID),
		CompanyID: cleaner.CompanyID,
		CleanerID: cleaner.ID,
	})
	if err != nil {
		return nil, fmt.Errorf("failed to assign cleaner: %w", err)
	}

	return dbBookingToGQL(booking), nil
}

// ConfirmBooking is the resolver for the confirmBooking field.
func (r *mutationResolver) ConfirmBooking(ctx context.Context, id string) (*model.Booking, error) {
	claims := auth.GetUserFromContext(ctx)
	if claims == nil {
		return nil, fmt.Errorf("not authenticated")
	}

	current, err := r.Queries.GetBookingByID(ctx, stringToUUID(id))
	if err != nil {
		return nil, fmt.Errorf("booking not found: %w", err)
	}

	// Idempotent: if already confirmed (e.g., auto-confirmed on payment), return as-is.
	if current.Status == db.BookingStatusConfirmed {
		gqlBooking := dbBookingToGQL(current)
		r.enrichBooking(ctx, current, gqlBooking)
		return gqlBooking, nil
	}

	if err := validateStatusTransition(current.Status, db.BookingStatusConfirmed); err != nil {
		return nil, err
	}

	booking, err := r.Queries.UpdateBookingStatus(ctx, db.UpdateBookingStatusParams{
		ID:     stringToUUID(id),
		Status: db.BookingStatusConfirmed,
	})
	if err != nil {
		return nil, fmt.Errorf("failed to confirm booking: %w", err)
	}

	// Auto-create chat room between client and cleaner (non-blocking).
	go func() {
		r.createBookingChat(context.Background(), booking, claims.UserID)
	}()

	return dbBookingToGQL(booking), nil
}

// StartJob is the resolver for the startJob field.
func (r *mutationResolver) StartJob(ctx context.Context, id string) (*model.Booking, error) {
	claims := auth.GetUserFromContext(ctx)
	if claims == nil {
		return nil, fmt.Errorf("not authenticated")
	}

	// Validate status transition.
	current, err := r.Queries.GetBookingByID(ctx, stringToUUID(id))
	if err != nil {
		return nil, fmt.Errorf("booking not found: %w", err)
	}
	if err := validateStatusTransition(current.Status, db.BookingStatusInProgress); err != nil {
		return nil, err
	}

	booking, err := r.Queries.StartBooking(ctx, stringToUUID(id))
	if err != nil {
		return nil, fmt.Errorf("failed to start job: %w", err)
	}

	return dbBookingToGQL(booking), nil
}

// CompleteJob is the resolver for the completeJob field.
func (r *mutationResolver) CompleteJob(ctx context.Context, id string) (*model.Booking, error) {
	claims := auth.GetUserFromContext(ctx)
	if claims == nil {
		return nil, fmt.Errorf("not authenticated")
	}

	// Validate status transition.
	current, err := r.Queries.GetBookingByID(ctx, stringToUUID(id))
	if err != nil {
		return nil, fmt.Errorf("booking not found: %w", err)
	}
	if err := validateStatusTransition(current.Status, db.BookingStatusCompleted); err != nil {
		return nil, err
	}

	booking, err := r.Queries.CompleteBooking(ctx, stringToUUID(id))
	if err != nil {
		return nil, fmt.Errorf("failed to complete job: %w", err)
	}

	// Calculate final total and platform commission.
	estimatedTotal := numericToFloat(booking.EstimatedTotal)
	commissionPct := numericToFloat(booking.PlatformCommissionPct)
	commissionAmount := estimatedTotal * (commissionPct / 100.0)

	booking, err = r.Queries.SetBookingFinalTotal(ctx, db.SetBookingFinalTotalParams{
		ID:                       booking.ID,
		FinalTotal:               float64ToNumeric(estimatedTotal),
		PlatformCommissionAmount: float64ToNumeric(commissionAmount),
	})
	if err != nil {
		return nil, fmt.Errorf("failed to set final total: %w", err)
	}

	return dbBookingToGQL(booking), nil
}

// SelectBookingTimeSlot is the resolver for the selectBookingTimeSlot field.
func (r *mutationResolver) SelectBookingTimeSlot(ctx context.Context, bookingID string, timeSlotID string) (*model.Booking, error) {
	claims := auth.GetUserFromContext(ctx)
	if claims == nil {
		return nil, fmt.Errorf("not authenticated")
	}

	bID := stringToUUID(bookingID)

	// Deselect all slots first.
	if err := r.Queries.DeselectAllBookingTimeSlots(ctx, bID); err != nil {
		return nil, fmt.Errorf("failed to deselect slots: %w", err)
	}

	// Select the chosen slot.
	slot, err := r.Queries.SelectBookingTimeSlot(ctx, stringToUUID(timeSlotID))
	if err != nil {
		return nil, fmt.Errorf("failed to select slot: %w", err)
	}

	// Update booking's scheduled_date and scheduled_start_time to match.
	_, err = r.Queries.UpdateBookingSchedule(ctx, db.UpdateBookingScheduleParams{
		ID:                 bID,
		ScheduledDate:      slot.SlotDate,
		ScheduledStartTime: slot.StartTime,
	})
	if err != nil {
		return nil, fmt.Errorf("failed to update booking schedule: %w", err)
	}

	booking, err := r.Queries.GetBookingByID(ctx, bID)
	if err != nil {
		return nil, fmt.Errorf("booking not found: %w", err)
	}

	result := dbBookingToGQL(booking)
	r.enrichBooking(ctx, booking, result)
	return result, nil
}

// MyBookings is the resolver for the myBookings field.
func (r *queryResolver) MyBookings(ctx context.Context, status *model.BookingStatus, first *int, after *string) (*model.BookingConnection, error) {
	claims := auth.GetUserFromContext(ctx)
	if claims == nil {
		return nil, fmt.Errorf("not authenticated")
	}

	limit := int32(20)
	if first != nil {
		limit = int32(*first)
	}
	offset := int32(0)
	if after != nil {
		// Simple offset-based pagination: after is the offset as a string.
		fmt.Sscanf(*after, "%d", &offset)
	}

	var bookings []db.Booking
	var err error
	if status != nil {
		bookings, err = r.Queries.ListBookingsByClientAndStatus(ctx, db.ListBookingsByClientAndStatusParams{
			ClientUserID: stringToUUID(claims.UserID),
			Status:       gqlBookingStatusToDb(*status),
			Limit:        limit + 1,
			Offset:       offset,
		})
	} else {
		bookings, err = r.Queries.ListBookingsByClient(ctx, db.ListBookingsByClientParams{
			ClientUserID: stringToUUID(claims.UserID),
			Limit:        limit + 1,
			Offset:       offset,
		})
	}
	if err != nil {
		return nil, fmt.Errorf("failed to list bookings: %w", err)
	}

	hasNext := len(bookings) > int(limit)
	if hasNext {
		bookings = bookings[:limit]
	}

	edges := make([]*model.Booking, len(bookings))
	for i, b := range bookings {
		gqlBooking := dbBookingToGQL(b)
		r.enrichBooking(ctx, b, gqlBooking)
		edges[i] = gqlBooking
	}

	var endCursor *string
	if len(bookings) > 0 {
		c := fmt.Sprintf("%d", offset+limit)
		endCursor = &c
	}

	return &model.BookingConnection{
		Edges: edges,
		PageInfo: &model.PageInfo{
			HasNextPage: hasNext,
			EndCursor:   endCursor,
		},
		TotalCount: len(edges),
	}, nil
}

// Booking is the resolver for the booking field.
func (r *queryResolver) Booking(ctx context.Context, id string) (*model.Booking, error) {
	claims := auth.GetUserFromContext(ctx)
	if claims == nil {
		return nil, fmt.Errorf("not authenticated")
	}

	booking, err := r.Queries.GetBookingByID(ctx, stringToUUID(id))
	if err != nil {
		return nil, fmt.Errorf("booking not found: %w", err)
	}

	result := dbBookingToGQL(booking)
	r.enrichBooking(ctx, booking, result)

	return result, nil
}

// CompanyBookings is the resolver for the companyBookings field.
func (r *queryResolver) CompanyBookings(ctx context.Context, status *model.BookingStatus, first *int, after *string) (*model.BookingConnection, error) {
	claims := auth.GetUserFromContext(ctx)
	if claims == nil {
		return nil, fmt.Errorf("not authenticated")
	}

	// Look up the company for the current user.
	company, err := r.Queries.GetCompanyByAdminUserID(ctx, stringToUUID(claims.UserID))
	if err != nil {
		return nil, fmt.Errorf("company not found for user: %w", err)
	}

	limit := int32(20)
	if first != nil {
		limit = int32(*first)
	}
	offset := int32(0)
	if after != nil {
		fmt.Sscanf(*after, "%d", &offset)
	}

	var bookings []db.Booking
	if status != nil {
		bookings, err = r.Queries.ListBookingsByCompanyAndStatus(ctx, db.ListBookingsByCompanyAndStatusParams{
			CompanyID: company.ID,
			Status:    gqlBookingStatusToDb(*status),
			Limit:     limit + 1,
			Offset:    offset,
		})
	} else {
		bookings, err = r.Queries.ListBookingsByCompany(ctx, db.ListBookingsByCompanyParams{
			CompanyID: company.ID,
			Limit:     limit + 1,
			Offset:    offset,
		})
	}
	if err != nil {
		return nil, fmt.Errorf("failed to list company bookings: %w", err)
	}

	hasNext := len(bookings) > int(limit)
	if hasNext {
		bookings = bookings[:limit]
	}

	edges := make([]*model.Booking, len(bookings))
	for i, b := range bookings {
		gqlBooking := dbBookingToGQL(b)
		r.enrichBooking(ctx, b, gqlBooking)
		edges[i] = gqlBooking
	}

	var endCursor *string
	if len(bookings) > 0 {
		c := fmt.Sprintf("%d", offset+limit)
		endCursor = &c
	}

	return &model.BookingConnection{
		Edges: edges,
		PageInfo: &model.PageInfo{
			HasNextPage: hasNext,
			EndCursor:   endCursor,
		},
		TotalCount: len(edges),
	}, nil
}

// MyAssignedJobs is the resolver for the myAssignedJobs field.
func (r *queryResolver) MyAssignedJobs(ctx context.Context, status *model.BookingStatus) ([]*model.Booking, error) {
	claims := auth.GetUserFromContext(ctx)
	if claims == nil {
		return nil, fmt.Errorf("not authenticated")
	}

	cleaner, err := r.Queries.GetCleanerByUserID(ctx, stringToUUID(claims.UserID))
	if err != nil {
		return nil, fmt.Errorf("cleaner profile not found: %w", err)
	}

	bookings, err := r.Queries.ListBookingsByCleaner(ctx, cleaner.ID)
	if err != nil {
		return nil, fmt.Errorf("failed to list assigned jobs: %w", err)
	}

	// Filter by status if provided, and enrich with related entities.
	var result []*model.Booking
	for _, b := range bookings {
		gqlBooking := dbBookingToGQL(b)
		if status != nil && gqlBooking.Status != *status {
			continue
		}
		r.enrichBooking(ctx, b, gqlBooking)
		result = append(result, gqlBooking)
	}

	return result, nil
}

// TodaysJobs is the resolver for the todaysJobs field.
func (r *queryResolver) TodaysJobs(ctx context.Context) ([]*model.Booking, error) {
	claims := auth.GetUserFromContext(ctx)
	if claims == nil {
		return nil, fmt.Errorf("not authenticated")
	}

	cleaner, err := r.Queries.GetCleanerByUserID(ctx, stringToUUID(claims.UserID))
	if err != nil {
		return nil, fmt.Errorf("cleaner profile not found: %w", err)
	}

	bookings, err := r.Queries.ListTodaysJobsByCleaner(ctx, cleaner.ID)
	if err != nil {
		return nil, fmt.Errorf("failed to list today's jobs: %w", err)
	}

	result := make([]*model.Booking, len(bookings))
	for i, b := range bookings {
		gqlBooking := dbBookingToGQL(b)
		r.enrichBooking(ctx, b, gqlBooking)
		result[i] = gqlBooking
	}

	return result, nil
}

// AllBookings is the resolver for the allBookings field.
func (r *queryResolver) AllBookings(ctx context.Context, status *model.BookingStatus, companyID *string, dateFrom *string, dateTo *string, first *int, after *string) (*model.BookingConnection, error) {
	claims := auth.GetUserFromContext(ctx)
	if claims == nil {
		return nil, fmt.Errorf("not authenticated")
	}

	limit := int32(20)
	if first != nil {
		limit = int32(*first)
	}
	offset := int32(0)
	if after != nil {
		fmt.Sscanf(*after, "%d", &offset)
	}

	var bookings []db.Booking
	var err error

	if status != nil {
		bookings, err = r.Queries.ListBookingsByStatus(ctx, db.ListBookingsByStatusParams{
			Status: gqlBookingStatusToDb(*status),
			Limit:  limit + 1,
			Offset: offset,
		})
	} else {
		bookings, err = r.Queries.ListAllBookings(ctx, db.ListAllBookingsParams{
			Limit:  limit + 1,
			Offset: offset,
		})
	}
	if err != nil {
		return nil, fmt.Errorf("failed to list all bookings: %w", err)
	}

	hasNext := len(bookings) > int(limit)
	if hasNext {
		bookings = bookings[:limit]
	}

	edges := make([]*model.Booking, len(bookings))
	for i, b := range bookings {
		gqlBooking := dbBookingToGQL(b)
		r.enrichBooking(ctx, b, gqlBooking)
		edges[i] = gqlBooking
	}

	var endCursor *string
	if len(bookings) > 0 {
		c := fmt.Sprintf("%d", offset+limit)
		endCursor = &c
	}

	return &model.BookingConnection{
		Edges: edges,
		PageInfo: &model.PageInfo{
			HasNextPage: hasNext,
			EndCursor:   endCursor,
		},
		TotalCount: len(edges),
	}, nil
}

// CompanyBookingsByDateRange is the resolver for the companyBookingsByDateRange field.
func (r *queryResolver) CompanyBookingsByDateRange(ctx context.Context, from string, to string) ([]*model.Booking, error) {
	claims := auth.GetUserFromContext(ctx)
	if claims == nil {
		return nil, fmt.Errorf("not authenticated")
	}

	company, err := r.Queries.GetCompanyByAdminUserID(ctx, stringToUUID(claims.UserID))
	if err != nil {
		return nil, fmt.Errorf("company not found for user: %w", err)
	}

	fromDate, err := time.Parse("2006-01-02", from)
	if err != nil {
		return nil, fmt.Errorf("invalid 'from' date: %w", err)
	}
	toDate, err := time.Parse("2006-01-02", to)
	if err != nil {
		return nil, fmt.Errorf("invalid 'to' date: %w", err)
	}

	bookings, err := r.Queries.ListBookingsByCompanyAndDateRange(ctx, db.ListBookingsByCompanyAndDateRangeParams{
		CompanyID: company.ID,
		DateFrom:  pgtype.Date{Time: fromDate, Valid: true},
		DateTo:    pgtype.Date{Time: toDate, Valid: true},
	})
	if err != nil {
		return nil, fmt.Errorf("failed to list bookings by date range: %w", err)
	}

	result := make([]*model.Booking, len(bookings))
	for i, b := range bookings {
		gqlBooking := dbBookingToGQL(b)
		r.enrichBooking(ctx, b, gqlBooking)
		result[i] = gqlBooking
	}

	return result, nil
}

// SearchCompanyBookings is the resolver for the searchCompanyBookings field.
func (r *queryResolver) SearchCompanyBookings(ctx context.Context, query *string, status *string, dateFrom *string, dateTo *string, limit *int, offset *int) (*model.BookingConnection, error) {
	claims := auth.GetUserFromContext(ctx)
	if claims == nil {
		return nil, fmt.Errorf("not authenticated")
	}

	company, err := r.Queries.GetCompanyByAdminUserID(ctx, stringToUUID(claims.UserID))
	if err != nil {
		return nil, fmt.Errorf("company not found for user: %w", err)
	}

	qLimit := int32(20)
	if limit != nil {
		qLimit = int32(*limit)
	}
	qOffset := int32(0)
	if offset != nil {
		qOffset = int32(*offset)
	}

	var queryStr string
	if query != nil {
		queryStr = *query
	}
	var statusStr string
	if status != nil {
		statusStr = strings.ToLower(*status)
	}

	// Parse date filters â€” use zero date sentinel to skip filter in SQL.
	zeroDate := pgtype.Date{Time: time.Date(1, 1, 1, 0, 0, 0, 0, time.UTC), Valid: true}
	fromDate := zeroDate
	toDate := zeroDate
	if dateFrom != nil {
		if t, err := time.Parse("2006-01-02", *dateFrom); err == nil {
			fromDate = pgtype.Date{Time: t, Valid: true}
		}
	}
	if dateTo != nil {
		if t, err := time.Parse("2006-01-02", *dateTo); err == nil {
			toDate = pgtype.Date{Time: t, Valid: true}
		}
	}

	bookings, err := r.Queries.SearchCompanyBookings(ctx, db.SearchCompanyBookingsParams{
		CompanyID:    company.ID,
		Limit:        qLimit + 1,
		Offset:       qOffset,
		Query:        queryStr,
		StatusFilter: statusStr,
		DateFrom:     fromDate,
		DateTo:       toDate,
	})
	if err != nil {
		return nil, fmt.Errorf("failed to search company bookings: %w", err)
	}

	hasNext := len(bookings) > int(qLimit)
	if hasNext {
		bookings = bookings[:qLimit]
	}

	edges := make([]*model.Booking, len(bookings))
	for i, b := range bookings {
		gqlBooking := dbBookingToGQL(b)
		r.enrichBooking(ctx, b, gqlBooking)
		edges[i] = gqlBooking
	}

	// Get total count.
	total, _ := r.Queries.CountSearchCompanyBookings(ctx, db.CountSearchCompanyBookingsParams{
		CompanyID:    company.ID,
		Query:        queryStr,
		StatusFilter: statusStr,
		DateFrom:     fromDate,
		DateTo:       toDate,
	})

	return &model.BookingConnection{
		Edges: edges,
		PageInfo: &model.PageInfo{
			HasNextPage: hasNext,
		},
		TotalCount: int(total),
	}, nil
}
