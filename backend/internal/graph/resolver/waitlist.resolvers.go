package resolver

// This file will be automatically regenerated based on the schema, any resolver
// implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.86

import (
	"context"
	"fmt"
	"helpmeclean-backend/internal/auth"
	db "helpmeclean-backend/internal/db/generated"
	"helpmeclean-backend/internal/graph/model"
	"strings"

	"github.com/jackc/pgx/v5/pgtype"
)

// JoinWaitlist is the resolver for the joinWaitlist mutation.
// Public — no authentication required.
func (r *mutationResolver) JoinWaitlist(ctx context.Context, input model.JoinWaitlistInput) (*model.WaitlistLead, error) {
	if strings.TrimSpace(input.Email) == "" {
		return nil, fmt.Errorf("email is required")
	}

	if input.LeadType == model.WaitlistLeadTypeCompany {
		if input.CompanyName == nil || strings.TrimSpace(*input.CompanyName) == "" {
			return nil, fmt.Errorf("company name is required for company leads")
		}
	}

	leadType := db.WaitlistLeadTypeClient
	if input.LeadType == model.WaitlistLeadTypeCompany {
		leadType = db.WaitlistLeadTypeCompany
	}

	nullableText := func(p *string) pgtype.Text {
		if p == nil {
			return pgtype.Text{}
		}
		return pgtype.Text{String: *p, Valid: true}
	}

	params := db.CreateWaitlistLeadParams{
		LeadType:    leadType,
		Name:        input.Name,
		Email:       input.Email,
		Phone:       nullableText(input.Phone),
		City:        nullableText(input.City),
		CompanyName: nullableText(input.CompanyName),
		Message:     nullableText(input.Message),
	}

	row, err := r.Queries.CreateWaitlistLead(ctx, params)
	if err != nil {
		return nil, fmt.Errorf("failed to join waitlist: %w", err)
	}

	return dbWaitlistLeadToGQL(row), nil
}

// PlatformMode is the resolver for the platformMode field.
// Public — no authentication required.
func (r *queryResolver) PlatformMode(ctx context.Context) (string, error) {
	setting, err := r.Queries.GetPlatformSetting(ctx, "platform_mode")
	if err != nil {
		// Row not found or any DB error: fall back to pre_release (safe default).
		return "pre_release", nil
	}
	return setting.Value, nil
}

// WaitlistLeads is the resolver for the waitlistLeads field.
// Requires GLOBAL_ADMIN role.
func (r *queryResolver) WaitlistLeads(ctx context.Context, leadType *model.WaitlistLeadType, limit *int, offset *int) ([]*model.WaitlistLead, error) {
	claims := auth.GetUserFromContext(ctx)
	if claims == nil || claims.Role != "global_admin" {
		return nil, fmt.Errorf("not authorized")
	}

	// Build the leadType filter string ($1 in the query).
	// An empty string means "all types" per the SQL WHERE clause.
	filterType := ""
	if leadType != nil {
		filterType = strings.ToLower(string(*leadType))
	}

	// Apply sensible defaults for pagination.
	lim := int32(50)
	if limit != nil && *limit > 0 {
		lim = int32(*limit)
	}
	off := int32(0)
	if offset != nil && *offset > 0 {
		off = int32(*offset)
	}

	rows, err := r.Queries.ListWaitlistLeads(ctx, db.ListWaitlistLeadsParams{
		Column1: filterType,
		Limit:   lim,
		Offset:  off,
	})
	if err != nil {
		return nil, fmt.Errorf("failed to list waitlist leads: %w", err)
	}

	result := make([]*model.WaitlistLead, len(rows))
	for i, row := range rows {
		result[i] = dbWaitlistLeadToGQL(row)
	}

	return result, nil
}

// WaitlistStats is the resolver for the waitlistStats field.
// Requires GLOBAL_ADMIN role.
func (r *queryResolver) WaitlistStats(ctx context.Context) (*model.WaitlistStats, error) {
	claims := auth.GetUserFromContext(ctx)
	if claims == nil || claims.Role != "global_admin" {
		return nil, fmt.Errorf("not authorized")
	}

	row, err := r.Queries.CountWaitlistLeads(ctx)
	if err != nil {
		return nil, fmt.Errorf("failed to count waitlist leads: %w", err)
	}

	return &model.WaitlistStats{
		ClientCount:  int(row.ClientCount),
		CompanyCount: int(row.CompanyCount),
		TotalCount:   int(row.TotalCount),
	}, nil
}
