package resolver

// This file will be automatically regenerated based on the schema, any resolver
// implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.86

import (
	"context"
	"fmt"
	"helpmeclean-backend/internal/auth"
	db "helpmeclean-backend/internal/db/generated"
	"helpmeclean-backend/internal/graph/model"

	"github.com/jackc/pgx/v5/pgtype"
)

// AddAddress is the resolver for the addAddress field.
func (r *mutationResolver) AddAddress(ctx context.Context, input model.AddAddressInput) (*model.Address, error) {
	claims := auth.GetUserFromContext(ctx)
	if claims == nil {
		return nil, fmt.Errorf("not authenticated")
	}

	addr, err := r.Queries.CreateAddress(ctx, db.CreateAddressParams{
		UserID:        stringToUUID(claims.UserID),
		Label:         stringToText(input.Label),
		StreetAddress: input.StreetAddress,
		City:          input.City,
		County:        input.County,
		PostalCode:    stringToText(input.PostalCode),
		Floor:         stringToText(input.Floor),
		Apartment:     stringToText(input.Apartment),
		EntryCode:     stringToText(input.EntryCode),
		Latitude:      float64PtrToFloat8(input.Latitude),
		Longitude:     float64PtrToFloat8(input.Longitude),
		Notes:         stringToText(input.Notes),
		IsDefault:     pgtype.Bool{Bool: false, Valid: true},
	})
	if err != nil {
		return nil, fmt.Errorf("failed to add address: %w", err)
	}

	return dbAddressToGQL(addr), nil
}

// UpdateAddress is the resolver for the updateAddress field.
func (r *mutationResolver) UpdateAddress(ctx context.Context, id string, input model.UpdateAddressInput) (*model.Address, error) {
	claims := auth.GetUserFromContext(ctx)
	if claims == nil {
		return nil, fmt.Errorf("not authenticated")
	}

	// Get current address to merge fields.
	current, err := r.Queries.GetAddressByID(ctx, stringToUUID(id))
	if err != nil {
		return nil, fmt.Errorf("address not found: %w", err)
	}

	streetAddress := current.StreetAddress
	if input.StreetAddress != nil {
		streetAddress = *input.StreetAddress
	}
	city := current.City
	if input.City != nil {
		city = *input.City
	}
	county := current.County
	if input.County != nil {
		county = *input.County
	}

	label := current.Label
	if input.Label != nil {
		label = stringToText(input.Label)
	}
	postalCode := current.PostalCode
	if input.PostalCode != nil {
		postalCode = stringToText(input.PostalCode)
	}
	floor := current.Floor
	if input.Floor != nil {
		floor = stringToText(input.Floor)
	}
	apartment := current.Apartment
	if input.Apartment != nil {
		apartment = stringToText(input.Apartment)
	}
	entryCode := current.EntryCode
	if input.EntryCode != nil {
		entryCode = stringToText(input.EntryCode)
	}
	latitude := current.Latitude
	if input.Latitude != nil {
		latitude = float64PtrToFloat8(input.Latitude)
	}
	longitude := current.Longitude
	if input.Longitude != nil {
		longitude = float64PtrToFloat8(input.Longitude)
	}
	notes := current.Notes
	if input.Notes != nil {
		notes = stringToText(input.Notes)
	}

	addr, err := r.Queries.UpdateAddress(ctx, db.UpdateAddressParams{
		ID:            stringToUUID(id),
		Label:         label,
		StreetAddress: streetAddress,
		City:          city,
		County:        county,
		PostalCode:    postalCode,
		Floor:         floor,
		Apartment:     apartment,
		EntryCode:     entryCode,
		Latitude:      latitude,
		Longitude:     longitude,
		Notes:         notes,
	})
	if err != nil {
		return nil, fmt.Errorf("failed to update address: %w", err)
	}

	return dbAddressToGQL(addr), nil
}

// DeleteAddress is the resolver for the deleteAddress field.
func (r *mutationResolver) DeleteAddress(ctx context.Context, id string) (bool, error) {
	claims := auth.GetUserFromContext(ctx)
	if claims == nil {
		return false, fmt.Errorf("not authenticated")
	}

	err := r.Queries.DeleteAddress(ctx, stringToUUID(id))
	if err != nil {
		return false, fmt.Errorf("failed to delete address: %w", err)
	}

	return true, nil
}

// SetDefaultAddress is the resolver for the setDefaultAddress field.
func (r *mutationResolver) SetDefaultAddress(ctx context.Context, id string) (*model.Address, error) {
	claims := auth.GetUserFromContext(ctx)
	if claims == nil {
		return nil, fmt.Errorf("not authenticated")
	}

	err := r.Queries.SetDefaultAddress(ctx, db.SetDefaultAddressParams{
		UserID: stringToUUID(claims.UserID),
		ID:     stringToUUID(id),
	})
	if err != nil {
		return nil, fmt.Errorf("failed to set default address: %w", err)
	}

	addr, err := r.Queries.GetAddressByID(ctx, stringToUUID(id))
	if err != nil {
		return nil, fmt.Errorf("address not found: %w", err)
	}

	return dbAddressToGQL(addr), nil
}

// DeletePaymentMethod is the resolver for the deletePaymentMethod field.
func (r *mutationResolver) DeletePaymentMethod(ctx context.Context, id string) (bool, error) {
	claims := auth.GetUserFromContext(ctx)
	if claims == nil {
		return false, fmt.Errorf("not authenticated")
	}

	err := r.Queries.DeletePaymentMethod(ctx, stringToUUID(id))
	if err != nil {
		return false, fmt.Errorf("failed to delete payment method: %w", err)
	}

	return true, nil
}

// SetDefaultPaymentMethod is the resolver for the setDefaultPaymentMethod field.
func (r *mutationResolver) SetDefaultPaymentMethod(ctx context.Context, id string) (*model.PaymentMethod, error) {
	claims := auth.GetUserFromContext(ctx)
	if claims == nil {
		return nil, fmt.Errorf("not authenticated")
	}

	err := r.Queries.SetDefaultPaymentMethod(ctx, db.SetDefaultPaymentMethodParams{
		UserID: stringToUUID(claims.UserID),
		ID:     stringToUUID(id),
	})
	if err != nil {
		return nil, fmt.Errorf("failed to set default payment method: %w", err)
	}

	// Re-fetch all payment methods and find the one that was set as default.
	methods, err := r.Queries.ListPaymentMethodsByUser(ctx, stringToUUID(claims.UserID))
	if err != nil {
		return nil, fmt.Errorf("failed to list payment methods: %w", err)
	}

	targetID := stringToUUID(id)
	for _, m := range methods {
		if m.ID == targetID {
			return dbPaymentMethodToGQL(m), nil
		}
	}

	return nil, fmt.Errorf("payment method not found after update")
}

// MyAddresses is the resolver for the myAddresses field.
func (r *queryResolver) MyAddresses(ctx context.Context) ([]*model.Address, error) {
	claims := auth.GetUserFromContext(ctx)
	if claims == nil {
		return nil, fmt.Errorf("not authenticated")
	}

	addresses, err := r.Queries.ListAddressesByUser(ctx, stringToUUID(claims.UserID))
	if err != nil {
		return nil, fmt.Errorf("failed to list addresses: %w", err)
	}

	result := make([]*model.Address, len(addresses))
	for i, a := range addresses {
		result[i] = dbAddressToGQL(a)
	}

	return result, nil
}

// MyPaymentMethods is the resolver for the myPaymentMethods field.
func (r *queryResolver) MyPaymentMethods(ctx context.Context) ([]*model.PaymentMethod, error) {
	claims := auth.GetUserFromContext(ctx)
	if claims == nil {
		return nil, fmt.Errorf("not authenticated")
	}

	methods, err := r.Queries.ListPaymentMethodsByUser(ctx, stringToUUID(claims.UserID))
	if err != nil {
		return nil, fmt.Errorf("failed to list payment methods: %w", err)
	}

	result := make([]*model.PaymentMethod, len(methods))
	for i, m := range methods {
		result[i] = dbPaymentMethodToGQL(m)
	}

	return result, nil
}
