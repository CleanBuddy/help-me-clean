package resolver

// This file will be automatically regenerated based on the schema, any resolver
// implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.86

import (
	"context"
	"fmt"
	"helpmeclean-backend/internal/auth"
	db "helpmeclean-backend/internal/db/generated"
	"helpmeclean-backend/internal/graph/model"
	"strings"
	"time"

	"github.com/jackc/pgx/v5/pgtype"
)

// CreateSetupIntent is the resolver for the createSetupIntent field.
func (r *mutationResolver) CreateSetupIntent(ctx context.Context) (*model.SetupIntentResult, error) {
	claims := auth.GetUserFromContext(ctx)
	if claims == nil {
		return nil, fmt.Errorf("not authenticated")
	}
	if claims.Role != "client" {
		return nil, fmt.Errorf("only clients can create setup intents")
	}

	userUUID := stringToUUID(claims.UserID)
	user, err := r.Queries.GetUserByID(ctx, userUUID)
	if err != nil {
		return nil, fmt.Errorf("failed to get user: %w", err)
	}

	clientSecret, err := r.PaymentService.CreateSetupIntent(ctx, userUUID, user.Email, user.FullName)
	if err != nil {
		return nil, fmt.Errorf("failed to create setup intent: %w", err)
	}

	return &model.SetupIntentResult{
		ClientSecret: clientSecret,
	}, nil
}

// AttachPaymentMethod is the resolver for the attachPaymentMethod field.
func (r *mutationResolver) AttachPaymentMethod(ctx context.Context, stripePaymentMethodID string) (*model.PaymentMethod, error) {
	claims := auth.GetUserFromContext(ctx)
	if claims == nil {
		return nil, fmt.Errorf("not authenticated")
	}
	if claims.Role != "client" {
		return nil, fmt.Errorf("only clients can attach payment methods")
	}

	userUUID := stringToUUID(claims.UserID)
	dbPM, err := r.PaymentService.AttachPaymentMethod(ctx, userUUID, stripePaymentMethodID)
	if err != nil {
		return nil, fmt.Errorf("failed to attach payment method: %w", err)
	}

	return dbPaymentMethodToGQL(dbPM), nil
}

// CreateBookingPaymentIntent is the resolver for the createBookingPaymentIntent field.
func (r *mutationResolver) CreateBookingPaymentIntent(ctx context.Context, bookingID string) (*model.PaymentIntentResult, error) {
	claims := auth.GetUserFromContext(ctx)
	if claims == nil {
		return nil, fmt.Errorf("not authenticated")
	}
	if claims.Role != "client" {
		return nil, fmt.Errorf("only clients can create payment intents")
	}

	booking, err := r.Queries.GetBookingByID(ctx, stringToUUID(bookingID))
	if err != nil {
		return nil, fmt.Errorf("booking not found: %w", err)
	}

	clientSecret, paymentIntentID, amountBani, err := r.PaymentService.CreatePaymentIntentForBooking(ctx, booking)
	if err != nil {
		return nil, fmt.Errorf("failed to create payment intent: %w", err)
	}

	return &model.PaymentIntentResult{
		ClientSecret:    clientSecret,
		PaymentIntentID: paymentIntentID,
		Amount:          int(amountBani),
		Currency:        "ron",
	}, nil
}

// RequestRefund is the resolver for the requestRefund field.
func (r *mutationResolver) RequestRefund(ctx context.Context, bookingID string, reason string) (*model.RefundRequest, error) {
	claims := auth.GetUserFromContext(ctx)
	if claims == nil {
		return nil, fmt.Errorf("not authenticated")
	}
	if claims.Role != "client" {
		return nil, fmt.Errorf("only clients can request refunds")
	}

	bookingUUID := stringToUUID(bookingID)
	txn, err := r.Queries.GetPaymentTransactionByBookingID(ctx, bookingUUID)
	if err != nil {
		return nil, fmt.Errorf("no payment found for booking: %w", err)
	}

	dbRefund, err := r.Queries.CreateRefundRequest(ctx, db.CreateRefundRequestParams{
		BookingID:            bookingUUID,
		PaymentTransactionID: txn.ID,
		RequestedByUserID:    stringToUUID(claims.UserID),
		Amount:               txn.AmountTotal,
		Reason:               reason,
		Status:               db.RefundStatusRequested,
	})
	if err != nil {
		return nil, fmt.Errorf("failed to create refund request: %w", err)
	}

	result := dbRefundRequestToGQL(dbRefund)
	// Enrich with booking data.
	if booking, err := r.Queries.GetBookingByID(ctx, dbRefund.BookingID); err == nil {
		gqlBooking := dbBookingToGQL(booking)
		r.enrichBooking(ctx, booking, gqlBooking)
		result.Booking = gqlBooking
	}
	// Enrich with requested-by user.
	if dbRefund.RequestedByUserID.Valid {
		if user, err := r.Queries.GetUserByID(ctx, dbRefund.RequestedByUserID); err == nil {
			result.RequestedBy = dbUserToGQL(user)
		}
	}

	return result, nil
}

// InitiateConnectOnboarding is the resolver for the initiateConnectOnboarding field.
func (r *mutationResolver) InitiateConnectOnboarding(ctx context.Context) (*model.ConnectOnboardingLink, error) {
	claims := auth.GetUserFromContext(ctx)
	if claims == nil {
		return nil, fmt.Errorf("not authenticated")
	}
	if claims.Role != "company_admin" {
		return nil, fmt.Errorf("only company admins can initiate connect onboarding")
	}

	company, err := r.Queries.GetCompanyByAdminUserID(ctx, stringToUUID(claims.UserID))
	if err != nil {
		return nil, fmt.Errorf("company not found: %w", err)
	}

	// Check if a connect account already exists.
	connectInfo, err := r.Queries.GetCompanyStripeConnect(ctx, company.ID)
	if err != nil {
		return nil, fmt.Errorf("failed to get connect info: %w", err)
	}

	accountID := ""
	if connectInfo.StripeConnectAccountID.Valid && connectInfo.StripeConnectAccountID.String != "" {
		accountID = connectInfo.StripeConnectAccountID.String
	} else {
		// Create a new connect account.
		accountID, err = r.PaymentService.CreateConnectAccount(ctx, company.ID, company.CompanyName, company.ContactEmail)
		if err != nil {
			return nil, fmt.Errorf("failed to create connect account: %w", err)
		}
	}

	// Generate onboarding link.
	url, err := r.PaymentService.CreateConnectOnboardingLink(ctx, accountID)
	if err != nil {
		return nil, fmt.Errorf("failed to create onboarding link: %w", err)
	}

	return &model.ConnectOnboardingLink{
		URL: url,
	}, nil
}

// RefreshConnectOnboarding is the resolver for the refreshConnectOnboarding field.
func (r *mutationResolver) RefreshConnectOnboarding(ctx context.Context) (*model.ConnectOnboardingLink, error) {
	claims := auth.GetUserFromContext(ctx)
	if claims == nil {
		return nil, fmt.Errorf("not authenticated")
	}
	if claims.Role != "company_admin" {
		return nil, fmt.Errorf("only company admins can refresh connect onboarding")
	}

	company, err := r.Queries.GetCompanyByAdminUserID(ctx, stringToUUID(claims.UserID))
	if err != nil {
		return nil, fmt.Errorf("company not found: %w", err)
	}

	connectInfo, err := r.Queries.GetCompanyStripeConnect(ctx, company.ID)
	if err != nil {
		return nil, fmt.Errorf("failed to get connect info: %w", err)
	}

	if !connectInfo.StripeConnectAccountID.Valid || connectInfo.StripeConnectAccountID.String == "" {
		return nil, fmt.Errorf("no connect account found, initiate onboarding first")
	}

	url, err := r.PaymentService.CreateConnectOnboardingLink(ctx, connectInfo.StripeConnectAccountID.String)
	if err != nil {
		return nil, fmt.Errorf("failed to create onboarding link: %w", err)
	}

	return &model.ConnectOnboardingLink{
		URL: url,
	}, nil
}

// CreateMonthlyPayout is the resolver for the createMonthlyPayout field.
func (r *mutationResolver) CreateMonthlyPayout(ctx context.Context, companyID string, periodFrom string, periodTo string) (*model.CompanyPayout, error) {
	claims := auth.GetUserFromContext(ctx)
	if claims == nil {
		return nil, fmt.Errorf("not authenticated")
	}
	if claims.Role != "global_admin" {
		return nil, fmt.Errorf("only admins can create payouts")
	}

	fromTime, err := time.Parse("2006-01-02", periodFrom)
	if err != nil {
		return nil, fmt.Errorf("invalid periodFrom date: %w", err)
	}
	toTime, err := time.Parse("2006-01-02", periodTo)
	if err != nil {
		return nil, fmt.Errorf("invalid periodTo date: %w", err)
	}

	companyUUID := stringToUUID(companyID)

	// Get unpaid transactions for the company in the date range.
	txns, err := r.Queries.ListUnpaidCompanyTransactions(ctx, db.ListUnpaidCompanyTransactionsParams{
		CompanyID:   companyUUID,
		CreatedAt:   pgtype.Timestamptz{Time: fromTime, Valid: true},
		CreatedAt_2: pgtype.Timestamptz{Time: toTime.Add(24*time.Hour - time.Nanosecond), Valid: true},
	})
	if err != nil {
		return nil, fmt.Errorf("failed to list unpaid transactions: %w", err)
	}

	if len(txns) == 0 {
		return nil, fmt.Errorf("no unpaid transactions found for this company in the given period")
	}

	// Sum up the amounts.
	var totalNet int32
	for _, txn := range txns {
		totalNet += txn.AmountCompany
	}

	// Create the payout record.
	payout, err := r.Queries.CreateCompanyPayout(ctx, db.CreateCompanyPayoutParams{
		CompanyID:    companyUUID,
		Amount:       totalNet,
		Currency:     "ron",
		PeriodFrom:   pgtype.Date{Time: fromTime, Valid: true},
		PeriodTo:     pgtype.Date{Time: toTime, Valid: true},
		BookingCount: int32(len(txns)),
		Status:       db.PayoutStatusPending,
	})
	if err != nil {
		return nil, fmt.Errorf("failed to create payout: %w", err)
	}

	// Create line items for each transaction.
	for _, txn := range txns {
		_, err := r.Queries.CreatePayoutLineItem(ctx, db.CreatePayoutLineItemParams{
			PayoutID:             payout.ID,
			PaymentTransactionID: txn.ID,
			BookingID:            txn.BookingID,
			AmountGross:          txn.AmountTotal,
			AmountCommission:     txn.AmountPlatformFee,
			AmountNet:            txn.AmountCompany,
		})
		if err != nil {
			return nil, fmt.Errorf("failed to create payout line item: %w", err)
		}
	}

	result := dbCompanyPayoutToGQL(payout)

	// Enrich with company data.
	if company, err := r.Queries.GetCompanyByID(ctx, payout.CompanyID); err == nil {
		result.Company = dbCompanyToGQL(company)
	}

	// Load line items with booking data.
	lineItems, err := r.Queries.ListPayoutLineItems(ctx, payout.ID)
	if err == nil {
		gqlLineItems := make([]*model.PayoutLineItem, len(lineItems))
		for i, li := range lineItems {
			gqlLI := dbPayoutLineItemToGQL(li)
			if booking, err := r.Queries.GetBookingByID(ctx, li.BookingID); err == nil {
				gqlBooking := dbBookingToGQL(booking)
				r.enrichBooking(ctx, booking, gqlBooking)
				gqlLI.Booking = gqlBooking
			}
			gqlLineItems[i] = gqlLI
		}
		result.LineItems = gqlLineItems
	}

	return result, nil
}

// ProcessRefund is the resolver for the processRefund field.
func (r *mutationResolver) ProcessRefund(ctx context.Context, refundRequestID string, approved bool) (*model.RefundRequest, error) {
	claims := auth.GetUserFromContext(ctx)
	if claims == nil {
		return nil, fmt.Errorf("not authenticated")
	}
	if claims.Role != "global_admin" {
		return nil, fmt.Errorf("only admins can process refunds")
	}

	refundReq, err := r.Queries.GetRefundRequestByID(ctx, stringToUUID(refundRequestID))
	if err != nil {
		return nil, fmt.Errorf("refund request not found: %w", err)
	}

	adminUUID := stringToUUID(claims.UserID)
	var updatedRefund db.RefundRequest

	if approved {
		// Get the payment transaction to find the Stripe PI ID.
		txn, err := r.Queries.GetPaymentTransactionByBookingID(ctx, refundReq.BookingID)
		if err != nil {
			return nil, fmt.Errorf("payment transaction not found: %w", err)
		}

		// Issue the Stripe refund.
		stripeRefundID, err := r.PaymentService.CreateRefund(ctx, txn.StripePaymentIntentID, int64(refundReq.Amount))
		if err != nil {
			return nil, fmt.Errorf("failed to create stripe refund: %w", err)
		}

		// Update status to processed with stripe refund ID.
		updatedRefund, err = r.Queries.UpdateRefundRequestStatus(ctx, db.UpdateRefundRequestStatusParams{
			ID:               refundReq.ID,
			Status:           db.RefundStatusProcessed,
			ApprovedByUserID: adminUUID,
			StripeRefundID:   pgtype.Text{String: stripeRefundID, Valid: true},
		})
		if err != nil {
			return nil, fmt.Errorf("failed to update refund request: %w", err)
		}
	} else {
		// Reject the refund request.
		updatedRefund, err = r.Queries.UpdateRefundRequestStatus(ctx, db.UpdateRefundRequestStatusParams{
			ID:               refundReq.ID,
			Status:           db.RefundStatusRejected,
			ApprovedByUserID: adminUUID,
			StripeRefundID:   pgtype.Text{},
		})
		if err != nil {
			return nil, fmt.Errorf("failed to update refund request: %w", err)
		}
	}

	result := dbRefundRequestToGQL(updatedRefund)
	// Enrich with booking data.
	if booking, err := r.Queries.GetBookingByID(ctx, updatedRefund.BookingID); err == nil {
		gqlBooking := dbBookingToGQL(booking)
		r.enrichBooking(ctx, booking, gqlBooking)
		result.Booking = gqlBooking
	}
	// Enrich with user data.
	if updatedRefund.RequestedByUserID.Valid {
		if user, err := r.Queries.GetUserByID(ctx, updatedRefund.RequestedByUserID); err == nil {
			result.RequestedBy = dbUserToGQL(user)
		}
	}
	if updatedRefund.ApprovedByUserID.Valid {
		if user, err := r.Queries.GetUserByID(ctx, updatedRefund.ApprovedByUserID); err == nil {
			result.ApprovedBy = dbUserToGQL(user)
		}
	}

	return result, nil
}

// AdminIssueRefund is the resolver for the adminIssueRefund field.
func (r *mutationResolver) AdminIssueRefund(ctx context.Context, bookingID string, amount int, reason string) (*model.RefundRequest, error) {
	claims := auth.GetUserFromContext(ctx)
	if claims == nil {
		return nil, fmt.Errorf("not authenticated")
	}
	if claims.Role != "global_admin" {
		return nil, fmt.Errorf("only admins can issue refunds")
	}

	bookingUUID := stringToUUID(bookingID)
	txn, err := r.Queries.GetPaymentTransactionByBookingID(ctx, bookingUUID)
	if err != nil {
		return nil, fmt.Errorf("no payment found for booking: %w", err)
	}

	adminUUID := stringToUUID(claims.UserID)

	// Issue the Stripe refund.
	stripeRefundID, err := r.PaymentService.CreateRefund(ctx, txn.StripePaymentIntentID, int64(amount))
	if err != nil {
		return nil, fmt.Errorf("failed to create stripe refund: %w", err)
	}

	// Create refund request record with status "processed" directly.
	dbRefund, err := r.Queries.CreateRefundRequest(ctx, db.CreateRefundRequestParams{
		BookingID:            bookingUUID,
		PaymentTransactionID: txn.ID,
		RequestedByUserID:    adminUUID,
		Amount:               int32(amount),
		Reason:               reason,
		Status:               db.RefundStatusProcessed,
	})
	if err != nil {
		return nil, fmt.Errorf("failed to create refund request: %w", err)
	}

	// Update with stripe refund ID and approved by.
	dbRefund, err = r.Queries.UpdateRefundRequestStatus(ctx, db.UpdateRefundRequestStatusParams{
		ID:               dbRefund.ID,
		Status:           db.RefundStatusProcessed,
		ApprovedByUserID: adminUUID,
		StripeRefundID:   pgtype.Text{String: stripeRefundID, Valid: true},
	})
	if err != nil {
		return nil, fmt.Errorf("failed to update refund request with stripe ID: %w", err)
	}

	result := dbRefundRequestToGQL(dbRefund)
	// Enrich with booking data.
	if booking, err := r.Queries.GetBookingByID(ctx, dbRefund.BookingID); err == nil {
		gqlBooking := dbBookingToGQL(booking)
		r.enrichBooking(ctx, booking, gqlBooking)
		result.Booking = gqlBooking
	}
	// Enrich with user data.
	if dbRefund.RequestedByUserID.Valid {
		if user, err := r.Queries.GetUserByID(ctx, dbRefund.RequestedByUserID); err == nil {
			result.RequestedBy = dbUserToGQL(user)
		}
	}
	if dbRefund.ApprovedByUserID.Valid {
		if user, err := r.Queries.GetUserByID(ctx, dbRefund.ApprovedByUserID); err == nil {
			result.ApprovedBy = dbUserToGQL(user)
		}
	}

	return result, nil
}

// MarkBookingPaid is the resolver for the markBookingPaid field.
func (r *mutationResolver) MarkBookingPaid(ctx context.Context, id string) (*model.Booking, error) {
	claims := auth.GetUserFromContext(ctx)
	if claims == nil {
		return nil, fmt.Errorf("not authenticated")
	}
	if claims.Role != "global_admin" {
		return nil, fmt.Errorf("only admins can mark bookings as paid")
	}

	booking, err := r.Queries.MarkBookingPaid(ctx, stringToUUID(id))
	if err != nil {
		return nil, fmt.Errorf("failed to mark booking paid: %w", err)
	}

	result := dbBookingToGQL(booking)
	r.enrichBooking(ctx, booking, result)
	return result, nil
}

// MyPaymentHistory is the resolver for the myPaymentHistory field.
func (r *queryResolver) MyPaymentHistory(ctx context.Context, first *int, after *string) (*model.PaymentHistoryConnection, error) {
	claims := auth.GetUserFromContext(ctx)
	if claims == nil {
		return nil, fmt.Errorf("not authenticated")
	}
	if claims.Role != "client" {
		return nil, fmt.Errorf("only clients can view payment history")
	}

	limit := int32(20)
	if first != nil {
		limit = int32(*first)
	}
	offset := int32(0)
	if after != nil {
		fmt.Sscanf(*after, "%d", &offset)
	}

	userUUID := stringToUUID(claims.UserID)

	txns, err := r.Queries.ListPaymentHistoryByUser(ctx, db.ListPaymentHistoryByUserParams{
		ClientUserID: userUUID,
		Limit:        limit + 1,
		Offset:       offset,
	})
	if err != nil {
		return nil, fmt.Errorf("failed to list payment history: %w", err)
	}

	hasNext := len(txns) > int(limit)
	if hasNext {
		txns = txns[:limit]
	}

	totalCount, _ := r.Queries.CountPaymentHistoryByUser(ctx, userUUID)

	edges := make([]*model.PaymentHistoryEntry, len(txns))
	for i, txn := range txns {
		entry := &model.PaymentHistoryEntry{
			ID:        uuidToString(txn.ID),
			Amount:    int(txn.AmountTotal),
			Currency:  txn.Currency,
			Status:    model.PaymentTransactionStatus(strings.ToUpper(string(txn.Status))),
			CreatedAt: timestamptzToTime(txn.CreatedAt),
		}
		// Set PaidAt if status is succeeded.
		if txn.Status == db.PaymentTransactionStatusSucceeded {
			paidAt := timestamptzToTime(txn.UpdatedAt)
			entry.PaidAt = &paidAt
		}
		// Enrich with booking data.
		if booking, err := r.Queries.GetBookingByID(ctx, txn.BookingID); err == nil {
			gqlBooking := dbBookingToGQL(booking)
			r.enrichBooking(ctx, booking, gqlBooking)
			entry.Booking = gqlBooking
		}
		edges[i] = entry
	}

	var endCursor *string
	if len(txns) > 0 {
		c := fmt.Sprintf("%d", offset+limit)
		endCursor = &c
	}

	return &model.PaymentHistoryConnection{
		Edges: edges,
		PageInfo: &model.PageInfo{
			HasNextPage: hasNext,
			EndCursor:   endCursor,
		},
		TotalCount: int(totalCount),
	}, nil
}

// BookingPaymentDetails is the resolver for the bookingPaymentDetails field.
func (r *queryResolver) BookingPaymentDetails(ctx context.Context, bookingID string) (*model.PaymentTransaction, error) {
	claims := auth.GetUserFromContext(ctx)
	if claims == nil {
		return nil, fmt.Errorf("not authenticated")
	}

	txn, err := r.Queries.GetPaymentTransactionByBookingID(ctx, stringToUUID(bookingID))
	if err != nil {
		return nil, fmt.Errorf("payment transaction not found: %w", err)
	}

	result := dbPaymentTransactionToGQL(txn)
	// Enrich with booking data.
	if booking, err := r.Queries.GetBookingByID(ctx, txn.BookingID); err == nil {
		gqlBooking := dbBookingToGQL(booking)
		r.enrichBooking(ctx, booking, gqlBooking)
		result.Booking = gqlBooking
	}

	return result, nil
}

// MyConnectStatus is the resolver for the myConnectStatus field.
func (r *queryResolver) MyConnectStatus(ctx context.Context) (*model.StripeConnectStatus, error) {
	claims := auth.GetUserFromContext(ctx)
	if claims == nil {
		return nil, fmt.Errorf("not authenticated")
	}
	if claims.Role != "company_admin" {
		return nil, fmt.Errorf("only company admins can view connect status")
	}

	company, err := r.Queries.GetCompanyByAdminUserID(ctx, stringToUUID(claims.UserID))
	if err != nil {
		return nil, fmt.Errorf("company not found: %w", err)
	}

	accountID, chargesEnabled, payoutsEnabled, onboardingComplete, err := r.PaymentService.GetConnectAccountStatus(ctx, company.ID)
	if err != nil {
		return nil, fmt.Errorf("failed to get connect status: %w", err)
	}

	// Determine onboarding status.
	var onboardingStatus model.ConnectOnboardingStatus
	if accountID == "" {
		onboardingStatus = model.ConnectOnboardingStatusNotStarted
	} else if !onboardingComplete {
		onboardingStatus = model.ConnectOnboardingStatusPending
	} else if !chargesEnabled {
		onboardingStatus = model.ConnectOnboardingStatusRestricted
	} else {
		onboardingStatus = model.ConnectOnboardingStatusComplete
	}

	var accountIDPtr *string
	if accountID != "" {
		accountIDPtr = &accountID
	}

	return &model.StripeConnectStatus{
		AccountID:        accountIDPtr,
		OnboardingStatus: onboardingStatus,
		ChargesEnabled:   chargesEnabled,
		PayoutsEnabled:   payoutsEnabled,
	}, nil
}

// MyPayouts is the resolver for the myPayouts field.
func (r *queryResolver) MyPayouts(ctx context.Context, first *int, after *string) ([]*model.CompanyPayout, error) {
	claims := auth.GetUserFromContext(ctx)
	if claims == nil {
		return nil, fmt.Errorf("not authenticated")
	}
	if claims.Role != "company_admin" {
		return nil, fmt.Errorf("only company admins can view payouts")
	}

	company, err := r.Queries.GetCompanyByAdminUserID(ctx, stringToUUID(claims.UserID))
	if err != nil {
		return nil, fmt.Errorf("company not found: %w", err)
	}

	limit := int32(20)
	if first != nil {
		limit = int32(*first)
	}
	offset := int32(0)
	if after != nil {
		fmt.Sscanf(*after, "%d", &offset)
	}

	payouts, err := r.Queries.ListPayoutsByCompany(ctx, db.ListPayoutsByCompanyParams{
		CompanyID: company.ID,
		Limit:     limit,
		Offset:    offset,
	})
	if err != nil {
		return nil, fmt.Errorf("failed to list payouts: %w", err)
	}

	gqlCompany := dbCompanyToGQL(company)
	results := make([]*model.CompanyPayout, len(payouts))
	for i, p := range payouts {
		gqlPayout := dbCompanyPayoutToGQL(p)
		gqlPayout.Company = gqlCompany
		results[i] = gqlPayout
	}

	return results, nil
}

// MyPayoutDetail is the resolver for the myPayoutDetail field.
func (r *queryResolver) MyPayoutDetail(ctx context.Context, id string) (*model.CompanyPayout, error) {
	claims := auth.GetUserFromContext(ctx)
	if claims == nil {
		return nil, fmt.Errorf("not authenticated")
	}
	if claims.Role != "company_admin" {
		return nil, fmt.Errorf("only company admins can view payout details")
	}

	company, err := r.Queries.GetCompanyByAdminUserID(ctx, stringToUUID(claims.UserID))
	if err != nil {
		return nil, fmt.Errorf("company not found: %w", err)
	}

	payout, err := r.Queries.GetPayoutByID(ctx, stringToUUID(id))
	if err != nil {
		return nil, fmt.Errorf("payout not found: %w", err)
	}

	// Verify this payout belongs to the caller's company.
	if uuidToString(payout.CompanyID) != uuidToString(company.ID) {
		return nil, fmt.Errorf("payout does not belong to your company")
	}

	result := dbCompanyPayoutToGQL(payout)
	result.Company = dbCompanyToGQL(company)

	// Load line items with booking data.
	lineItems, err := r.Queries.ListPayoutLineItems(ctx, payout.ID)
	if err == nil {
		gqlLineItems := make([]*model.PayoutLineItem, len(lineItems))
		for i, li := range lineItems {
			gqlLI := dbPayoutLineItemToGQL(li)
			if booking, err := r.Queries.GetBookingByID(ctx, li.BookingID); err == nil {
				gqlBooking := dbBookingToGQL(booking)
				r.enrichBooking(ctx, booking, gqlBooking)
				gqlLI.Booking = gqlBooking
			}
			gqlLineItems[i] = gqlLI
		}
		result.LineItems = gqlLineItems
	}

	return result, nil
}

// MyCompanyEarnings is the resolver for the myCompanyEarnings field.
func (r *queryResolver) MyCompanyEarnings(ctx context.Context, from string, to string) (*model.CompanyEarningsSummary, error) {
	claims := auth.GetUserFromContext(ctx)
	if claims == nil {
		return nil, fmt.Errorf("not authenticated")
	}
	if claims.Role != "company_admin" {
		return nil, fmt.Errorf("only company admins can view earnings")
	}

	company, err := r.Queries.GetCompanyByAdminUserID(ctx, stringToUUID(claims.UserID))
	if err != nil {
		return nil, fmt.Errorf("company not found: %w", err)
	}

	fromTime, err := time.Parse("2006-01-02", from)
	if err != nil {
		return nil, fmt.Errorf("invalid from date: %w", err)
	}
	toTime, err := time.Parse("2006-01-02", to)
	if err != nil {
		return nil, fmt.Errorf("invalid to date: %w", err)
	}

	earnings, err := r.Queries.SumCompanyEarnings(ctx, db.SumCompanyEarningsParams{
		CompanyID:   company.ID,
		CreatedAt:   pgtype.Timestamptz{Time: fromTime, Valid: true},
		CreatedAt_2: pgtype.Timestamptz{Time: toTime.Add(24*time.Hour - time.Nanosecond), Valid: true},
	})
	if err != nil {
		return nil, fmt.Errorf("failed to get earnings: %w", err)
	}

	averagePerBooking := 0
	if earnings.BookingCount > 0 {
		averagePerBooking = int(earnings.TotalNet / earnings.BookingCount)
	}

	return &model.CompanyEarningsSummary{
		TotalGross:        int(earnings.TotalGross),
		TotalCommission:   int(earnings.TotalCommission),
		TotalNet:          int(earnings.TotalNet),
		BookingCount:      int(earnings.BookingCount),
		AveragePerBooking: averagePerBooking,
	}, nil
}

// AllPaymentTransactions is the resolver for the allPaymentTransactions field.
func (r *queryResolver) AllPaymentTransactions(ctx context.Context, status *model.PaymentTransactionStatus, first *int, after *string) ([]*model.PaymentTransaction, error) {
	claims := auth.GetUserFromContext(ctx)
	if claims == nil {
		return nil, fmt.Errorf("not authenticated")
	}
	if claims.Role != "global_admin" {
		return nil, fmt.Errorf("only admins can view all payment transactions")
	}

	limit := int32(20)
	if first != nil {
		limit = int32(*first)
	}
	offset := int32(0)
	if after != nil {
		fmt.Sscanf(*after, "%d", &offset)
	}

	var txns []db.PaymentTransaction
	var err error

	if status != nil {
		dbStatus := db.PaymentTransactionStatus(strings.ToLower(string(*status)))
		txns, err = r.Queries.ListPaymentTransactionsByStatus(ctx, db.ListPaymentTransactionsByStatusParams{
			Status: dbStatus,
			Limit:  limit,
			Offset: offset,
		})
	} else {
		txns, err = r.Queries.ListAllPaymentTransactions(ctx, db.ListAllPaymentTransactionsParams{
			Limit:  limit,
			Offset: offset,
		})
	}
	if err != nil {
		return nil, fmt.Errorf("failed to list payment transactions: %w", err)
	}

	results := make([]*model.PaymentTransaction, len(txns))
	for i, txn := range txns {
		gqlTxn := dbPaymentTransactionToGQL(txn)
		if booking, err := r.Queries.GetBookingByID(ctx, txn.BookingID); err == nil {
			gqlBooking := dbBookingToGQL(booking)
			r.enrichBooking(ctx, booking, gqlBooking)
			gqlTxn.Booking = gqlBooking
		}
		results[i] = gqlTxn
	}

	return results, nil
}

// AllRefundRequests is the resolver for the allRefundRequests field.
func (r *queryResolver) AllRefundRequests(ctx context.Context, status *model.RefundStatus, first *int, after *string) ([]*model.RefundRequest, error) {
	claims := auth.GetUserFromContext(ctx)
	if claims == nil {
		return nil, fmt.Errorf("not authenticated")
	}
	if claims.Role != "global_admin" {
		return nil, fmt.Errorf("only admins can view all refund requests")
	}

	limit := int32(20)
	if first != nil {
		limit = int32(*first)
	}
	offset := int32(0)
	if after != nil {
		fmt.Sscanf(*after, "%d", &offset)
	}

	var refunds []db.RefundRequest
	var err error

	if status != nil {
		dbStatus := db.RefundStatus(strings.ToLower(string(*status)))
		refunds, err = r.Queries.ListRefundRequestsByStatus(ctx, db.ListRefundRequestsByStatusParams{
			Status: dbStatus,
			Limit:  limit,
			Offset: offset,
		})
	} else {
		refunds, err = r.Queries.ListAllRefundRequests(ctx, db.ListAllRefundRequestsParams{
			Limit:  limit,
			Offset: offset,
		})
	}
	if err != nil {
		return nil, fmt.Errorf("failed to list refund requests: %w", err)
	}

	results := make([]*model.RefundRequest, len(refunds))
	for i, ref := range refunds {
		gqlRef := dbRefundRequestToGQL(ref)
		// Enrich with booking data.
		if booking, err := r.Queries.GetBookingByID(ctx, ref.BookingID); err == nil {
			gqlBooking := dbBookingToGQL(booking)
			r.enrichBooking(ctx, booking, gqlBooking)
			gqlRef.Booking = gqlBooking
		}
		// Enrich with user data.
		if ref.RequestedByUserID.Valid {
			if user, err := r.Queries.GetUserByID(ctx, ref.RequestedByUserID); err == nil {
				gqlRef.RequestedBy = dbUserToGQL(user)
			}
		}
		if ref.ApprovedByUserID.Valid {
			if user, err := r.Queries.GetUserByID(ctx, ref.ApprovedByUserID); err == nil {
				gqlRef.ApprovedBy = dbUserToGQL(user)
			}
		}
		results[i] = gqlRef
	}

	return results, nil
}

// AllPayouts is the resolver for the allPayouts field.
func (r *queryResolver) AllPayouts(ctx context.Context, companyID *string, status *model.PayoutStatus, first *int, after *string) ([]*model.CompanyPayout, error) {
	claims := auth.GetUserFromContext(ctx)
	if claims == nil {
		return nil, fmt.Errorf("not authenticated")
	}
	if claims.Role != "global_admin" {
		return nil, fmt.Errorf("only admins can view all payouts")
	}

	limit := int32(20)
	if first != nil {
		limit = int32(*first)
	}
	offset := int32(0)
	if after != nil {
		fmt.Sscanf(*after, "%d", &offset)
	}

	var payouts []db.CompanyPayout
	var err error

	if companyID != nil && status != nil {
		dbStatus := db.PayoutStatus(strings.ToLower(string(*status)))
		payouts, err = r.Queries.ListPayoutsByCompanyAndStatus(ctx, db.ListPayoutsByCompanyAndStatusParams{
			CompanyID: stringToUUID(*companyID),
			Status:    dbStatus,
			Limit:     limit,
			Offset:    offset,
		})
	} else if companyID != nil {
		payouts, err = r.Queries.ListPayoutsByCompany(ctx, db.ListPayoutsByCompanyParams{
			CompanyID: stringToUUID(*companyID),
			Limit:     limit,
			Offset:    offset,
		})
	} else if status != nil {
		dbStatus := db.PayoutStatus(strings.ToLower(string(*status)))
		payouts, err = r.Queries.ListPayoutsByStatus(ctx, db.ListPayoutsByStatusParams{
			Status: dbStatus,
			Limit:  limit,
			Offset: offset,
		})
	} else {
		payouts, err = r.Queries.ListAllPayouts(ctx, db.ListAllPayoutsParams{
			Limit:  limit,
			Offset: offset,
		})
	}
	if err != nil {
		return nil, fmt.Errorf("failed to list payouts: %w", err)
	}

	results := make([]*model.CompanyPayout, len(payouts))
	for i, p := range payouts {
		gqlPayout := dbCompanyPayoutToGQL(p)
		// Enrich with company data.
		if company, err := r.Queries.GetCompanyByID(ctx, p.CompanyID); err == nil {
			gqlPayout.Company = dbCompanyToGQL(company)
		}
		results[i] = gqlPayout
	}

	return results, nil
}

// PlatformRevenueReport is the resolver for the platformRevenueReport field.
func (r *queryResolver) PlatformRevenueReport(ctx context.Context, from string, to string) (*model.PlatformRevenueReport, error) {
	claims := auth.GetUserFromContext(ctx)
	if claims == nil {
		return nil, fmt.Errorf("not authenticated")
	}
	if claims.Role != "global_admin" {
		return nil, fmt.Errorf("only admins can view platform revenue reports")
	}

	fromTime, err := time.Parse("2006-01-02", from)
	if err != nil {
		return nil, fmt.Errorf("invalid from date: %w", err)
	}
	toTime, err := time.Parse("2006-01-02", to)
	if err != nil {
		return nil, fmt.Errorf("invalid to date: %w", err)
	}

	fromTz := pgtype.Timestamptz{Time: fromTime, Valid: true}
	toTz := pgtype.Timestamptz{Time: toTime.Add(24*time.Hour - time.Nanosecond), Valid: true}

	// Get revenue report.
	revenue, err := r.Queries.GetPlatformRevenueReport(ctx, db.GetPlatformRevenueReportParams{
		CreatedAt:   fromTz,
		CreatedAt_2: toTz,
	})
	if err != nil {
		return nil, fmt.Errorf("failed to get revenue report: %w", err)
	}

	// Get payouts in period.
	payoutsInfo, err := r.Queries.GetTotalPayoutsInPeriod(ctx, db.GetTotalPayoutsInPeriodParams{
		CreatedAt:   fromTz,
		CreatedAt_2: toTz,
	})
	if err != nil {
		return nil, fmt.Errorf("failed to get payouts info: %w", err)
	}

	// Get refunds in period.
	totalRefunds, err := r.Queries.GetTotalRefundsInPeriod(ctx, db.GetTotalRefundsInPeriodParams{
		ProcessedAt:   fromTz,
		ProcessedAt_2: toTz,
	})
	if err != nil {
		return nil, fmt.Errorf("failed to get refunds info: %w", err)
	}

	netRevenue := int(revenue.TotalCommission) - int(totalRefunds)

	return &model.PlatformRevenueReport{
		TotalRevenue:    int(revenue.TotalRevenue),
		TotalCommission: int(revenue.TotalCommission),
		TotalPayouts:    int(payoutsInfo.TotalPaid),
		PendingPayouts:  int(payoutsInfo.TotalPending),
		TotalRefunds:    int(totalRefunds),
		NetRevenue:      netRevenue,
		BookingCount:    int(revenue.BookingCount),
	}, nil
}
