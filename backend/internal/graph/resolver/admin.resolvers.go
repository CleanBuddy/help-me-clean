package resolver

// This file will be automatically regenerated based on the schema, any resolver
// implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.86

import (
	"context"
	"fmt"
	"helpmeclean-backend/internal/auth"
	db "helpmeclean-backend/internal/db/generated"
	"helpmeclean-backend/internal/graph/model"
	"strings"

	"github.com/99designs/gqlgen/graphql"
)

// AdminCancelBooking is the resolver for the adminCancelBooking field.
func (r *mutationResolver) AdminCancelBooking(ctx context.Context, id string, reason string) (*model.Booking, error) {
	claims := auth.GetUserFromContext(ctx)
	if claims == nil {
		return nil, fmt.Errorf("not authenticated")
	}

	booking, err := r.Queries.UpdateBookingStatus(ctx, db.UpdateBookingStatusParams{
		ID:     stringToUUID(id),
		Status: db.BookingStatusCancelledByAdmin,
	})
	if err != nil {
		return nil, fmt.Errorf("failed to cancel booking: %w", err)
	}

	return dbBookingToGQL(booking), nil
}

// SuspendUser is the resolver for the suspendUser field.
func (r *mutationResolver) SuspendUser(ctx context.Context, id string, reason string) (*model.User, error) {
	claims := auth.GetUserFromContext(ctx)
	if claims == nil {
		return nil, fmt.Errorf("not authenticated")
	}

	user, err := r.Queries.UpdateUserStatus(ctx, db.UpdateUserStatusParams{
		ID:     stringToUUID(id),
		Status: db.UserStatusSuspended,
	})
	if err != nil {
		return nil, fmt.Errorf("failed to suspend user: %w", err)
	}

	return dbUserToGQL(user), nil
}

// ReactivateUser is the resolver for the reactivateUser field.
func (r *mutationResolver) ReactivateUser(ctx context.Context, id string) (*model.User, error) {
	claims := auth.GetUserFromContext(ctx)
	if claims == nil {
		return nil, fmt.Errorf("not authenticated")
	}

	user, err := r.Queries.UpdateUserStatus(ctx, db.UpdateUserStatusParams{
		ID:     stringToUUID(id),
		Status: db.UserStatusActive,
	})
	if err != nil {
		return nil, fmt.Errorf("failed to reactivate user: %w", err)
	}

	return dbUserToGQL(user), nil
}

// UploadFile is the resolver for the uploadFile field.
func (r *mutationResolver) UploadFile(ctx context.Context, file graphql.Upload, purpose string) (*model.UploadResult, error) {
	claims := auth.GetUserFromContext(ctx)
	if claims == nil {
		return nil, fmt.Errorf("not authenticated")
	}

	// For MVP, return a mock URL.
	mockURL := fmt.Sprintf("https://storage.helpmeclean.ro/uploads/%s/%s", purpose, file.Filename)

	return &model.UploadResult{
		URL:      mockURL,
		FileName: file.Filename,
	}, nil
}

// AdminUpdateCompanyProfile is the resolver for the adminUpdateCompanyProfile field.
func (r *mutationResolver) AdminUpdateCompanyProfile(ctx context.Context, input model.AdminUpdateCompanyInput) (*model.Company, error) {
	claims := auth.GetUserFromContext(ctx)
	if claims == nil {
		return nil, fmt.Errorf("not authenticated")
	}

	company, err := r.Queries.AdminUpdateCompanyProfile(ctx, db.AdminUpdateCompanyProfileParams{
		ID:           stringToUUID(input.ID),
		CompanyName:  input.CompanyName,
		Cui:          input.Cui,
		Address:      input.Address,
		ContactPhone: input.ContactPhone,
		ContactEmail: input.ContactEmail,
	})
	if err != nil {
		return nil, fmt.Errorf("failed to update company profile: %w", err)
	}

	return dbCompanyToGQL(company), nil
}

// AdminUpdateCompanyStatus is the resolver for the adminUpdateCompanyStatus field.
func (r *mutationResolver) AdminUpdateCompanyStatus(ctx context.Context, id string, status model.CompanyStatus) (*model.Company, error) {
	claims := auth.GetUserFromContext(ctx)
	if claims == nil {
		return nil, fmt.Errorf("not authenticated")
	}

	company, err := r.Queries.UpdateCompanyStatus(ctx, db.UpdateCompanyStatusParams{
		ID:     stringToUUID(id),
		Status: gqlCompanyStatusToDb(status),
	})
	if err != nil {
		return nil, fmt.Errorf("failed to update company status: %w", err)
	}

	return dbCompanyToGQL(company), nil
}

// DeleteReview is the resolver for the deleteReview field.
func (r *mutationResolver) DeleteReview(ctx context.Context, id string) (bool, error) {
	claims := auth.GetUserFromContext(ctx)
	if claims == nil {
		return false, fmt.Errorf("not authenticated")
	}

	err := r.Queries.DeleteReview(ctx, stringToUUID(id))
	if err != nil {
		return false, fmt.Errorf("failed to delete review: %w", err)
	}

	return true, nil
}

// PlatformStats is the resolver for the platformStats field.
func (r *queryResolver) PlatformStats(ctx context.Context, dateFrom *string, dateTo *string) (*model.PlatformStats, error) {
	claims := auth.GetUserFromContext(ctx)
	if claims == nil {
		return nil, fmt.Errorf("not authenticated")
	}

	stats, err := r.Queries.GetPlatformStats(ctx)
	if err != nil {
		return nil, fmt.Errorf("failed to get platform stats: %w", err)
	}

	// Parse TotalRevenue from interface{}.
	var totalRevenue float64
	switch v := stats.TotalRevenue.(type) {
	case float64:
		totalRevenue = v
	case int64:
		totalRevenue = float64(v)
	case string:
		fmt.Sscanf(v, "%f", &totalRevenue)
	}

	return &model.PlatformStats{
		TotalClients:            int(stats.TotalUsers),
		TotalCompanies:          int(stats.ActiveCompanies),
		TotalCleaners:           int(stats.ActiveCleaners),
		TotalBookings:           int(stats.TotalBookings),
		TotalRevenue:            totalRevenue,
		PlatformCommissionTotal: totalRevenue,
		AverageRating:           0,
		BookingsThisMonth:       0,
		RevenueThisMonth:        0,
		NewClientsThisMonth:     0,
		NewCompaniesThisMonth:   0,
	}, nil
}

// BookingsByStatus is the resolver for the bookingsByStatus field.
func (r *queryResolver) BookingsByStatus(ctx context.Context) ([]*model.BookingsByStatus, error) {
	claims := auth.GetUserFromContext(ctx)
	if claims == nil {
		return nil, fmt.Errorf("not authenticated")
	}

	rows, err := r.Queries.GetBookingCountByStatus(ctx)
	if err != nil {
		return nil, fmt.Errorf("failed to get bookings by status: %w", err)
	}

	result := make([]*model.BookingsByStatus, len(rows))
	for i, row := range rows {
		result[i] = &model.BookingsByStatus{
			Status: dbBookingStatusToGQL(row.Status),
			Count:  int(row.Count),
		}
	}

	return result, nil
}

// RevenueByMonth is the resolver for the revenueByMonth field.
func (r *queryResolver) RevenueByMonth(ctx context.Context, months *int) ([]*model.RevenueByMonth, error) {
	claims := auth.GetUserFromContext(ctx)
	if claims == nil {
		return nil, fmt.Errorf("not authenticated")
	}

	limit := int32(12)
	if months != nil {
		limit = int32(*months)
	}

	rows, err := r.Queries.GetRevenueByMonth(ctx, limit)
	if err != nil {
		return nil, fmt.Errorf("failed to get revenue by month: %w", err)
	}

	result := make([]*model.RevenueByMonth, len(rows))
	for i, row := range rows {
		// The Month field is a pgtype.Interval from DATE_TRUNC.
		// We format it as a string representation.
		monthStr := fmt.Sprintf("%d months", row.Month.Months)
		result[i] = &model.RevenueByMonth{
			Month:        monthStr,
			Revenue:      float64(row.TotalRevenue),
			Commission:   float64(row.CommissionRevenue),
			BookingCount: int(row.BookingCount),
		}
	}

	return result, nil
}

// CompanyPerformance is the resolver for the companyPerformance field.
func (r *queryResolver) CompanyPerformance(ctx context.Context, first *int) ([]*model.CompanyPerformance, error) {
	claims := auth.GetUserFromContext(ctx)
	if claims == nil {
		return nil, fmt.Errorf("not authenticated")
	}

	limit := int32(20)
	if first != nil {
		limit = int32(*first)
	}

	rows, err := r.Queries.GetCompanyPerformance(ctx, db.GetCompanyPerformanceParams{
		Limit:  limit,
		Offset: 0,
	})
	if err != nil {
		return nil, fmt.Errorf("failed to get company performance: %w", err)
	}

	result := make([]*model.CompanyPerformance, len(rows))
	for i, row := range rows {
		// Fetch the full company data.
		company, err := r.Queries.GetCompanyByID(ctx, row.ID)
		if err != nil {
			continue
		}

		result[i] = &model.CompanyPerformance{
			Company:        dbCompanyToGQL(company),
			TotalBookings:  int4Val(row.TotalJobsCompleted),
			TotalRevenue:   0,
			AverageRating:  numericToFloat(row.RatingAvg),
			CompletionRate: 0,
		}
	}

	return result, nil
}

// PendingCompanyApplications is the resolver for the pendingCompanyApplications field.
func (r *queryResolver) PendingCompanyApplications(ctx context.Context) ([]*model.Company, error) {
	claims := auth.GetUserFromContext(ctx)
	if claims == nil {
		return nil, fmt.Errorf("not authenticated")
	}

	companies, err := r.Queries.ListCompaniesByStatus(ctx, db.ListCompaniesByStatusParams{
		Status: db.CompanyStatusPendingReview,
		Limit:  100,
		Offset: 0,
	})
	if err != nil {
		return nil, fmt.Errorf("failed to list pending applications: %w", err)
	}

	result := make([]*model.Company, len(companies))
	for i, c := range companies {
		result[i] = dbCompanyToGQL(c)
	}

	return result, nil
}

// AllCleaners is the resolver for the allCleaners field.
func (r *queryResolver) AllCleaners(ctx context.Context) ([]*model.CleanerProfile, error) {
	claims := auth.GetUserFromContext(ctx)
	if claims == nil {
		return nil, fmt.Errorf("not authenticated")
	}

	cleaners, err := r.Queries.ListAllActiveCleaners(ctx)
	if err != nil {
		return nil, fmt.Errorf("failed to list cleaners: %w", err)
	}

	result := make([]*model.CleanerProfile, len(cleaners))
	for i, c := range cleaners {
		profile := dbCleanerToGQL(c)
		company, err := r.Queries.GetCompanyByID(ctx, c.CompanyID)
		if err == nil {
			profile.Company = dbCompanyToGQL(company)
		}
		result[i] = profile
	}

	return result, nil
}

// AllChatRooms is the resolver for the allChatRooms field.
func (r *queryResolver) AllChatRooms(ctx context.Context) ([]*model.ChatRoom, error) {
	claims := auth.GetUserFromContext(ctx)
	if claims == nil || claims.Role != "global_admin" {
		return nil, fmt.Errorf("not authorized")
	}

	rooms, err := r.Queries.ListAllChatRooms(ctx)
	if err != nil {
		return nil, fmt.Errorf("failed to list chat rooms: %w", err)
	}

	result := make([]*model.ChatRoom, len(rooms))
	for i, room := range rooms {
		gqlRoom := dbChatRoomToGQL(room)

		// Load participants.
		participants, err := r.Queries.ListChatParticipants(ctx, room.ID)
		if err == nil {
			var gqlParticipants []*model.ChatParticipant
			for _, p := range participants {
				user, err := r.Queries.GetUserByID(ctx, p.UserID)
				if err != nil {
					continue
				}
				gqlParticipants = append(gqlParticipants, &model.ChatParticipant{
					User:     dbUserToGQL(user),
					JoinedAt: timestamptzToTime(p.JoinedAt),
				})
			}
			gqlRoom.Participants = gqlParticipants
		}

		// Load last message.
		lastMsgRow, err := r.Queries.GetLastChatMessage(ctx, room.ID)
		if err == nil {
			lastMsg := dbChatMessageToGQL(lastMsgRow)
			sender, err := r.Queries.GetUserByID(ctx, lastMsgRow.SenderID)
			if err == nil {
				lastMsg.Sender = dbUserToGQL(sender)
			}
			gqlRoom.LastMessage = lastMsg
		}

		result[i] = gqlRoom
	}

	return result, nil
}

// AllUsers is the resolver for the allUsers field.
func (r *queryResolver) AllUsers(ctx context.Context) ([]*model.User, error) {
	claims := auth.GetUserFromContext(ctx)
	if claims == nil || claims.Role != "global_admin" {
		return nil, fmt.Errorf("not authorized")
	}

	users, err := r.Queries.ListAllUsers(ctx)
	if err != nil {
		return nil, fmt.Errorf("failed to list users: %w", err)
	}

	result := make([]*model.User, len(users))
	for i, u := range users {
		result[i] = dbUserToGQL(u)
	}

	return result, nil
}

// SearchCompanies is the resolver for the searchCompanies field.
func (r *queryResolver) SearchCompanies(ctx context.Context, query *string, status *model.CompanyStatus, limit *int, offset *int) (*model.CompanyConnection, error) {
	claims := auth.GetUserFromContext(ctx)
	if claims == nil {
		return nil, fmt.Errorf("not authenticated")
	}

	l := int32(50)
	if limit != nil {
		l = int32(*limit)
	}
	o := int32(0)
	if offset != nil {
		o = int32(*offset)
	}
	q := ""
	if query != nil {
		q = *query
	}
	statusFilter := ""
	if status != nil {
		statusFilter = strings.ToLower(string(*status))
	}

	companies, err := r.Queries.SearchCompanies(ctx, db.SearchCompaniesParams{
		Limit:        l,
		Offset:       o,
		Query:        q,
		StatusFilter: statusFilter,
	})
	if err != nil {
		return nil, fmt.Errorf("failed to search companies: %w", err)
	}

	count, err := r.Queries.CountSearchCompanies(ctx, db.CountSearchCompaniesParams{
		Query:        q,
		StatusFilter: statusFilter,
	})
	if err != nil {
		return nil, fmt.Errorf("failed to count companies: %w", err)
	}

	edges := make([]*model.Company, len(companies))
	for i, c := range companies {
		edges[i] = dbCompanyToGQL(c)
	}

	return &model.CompanyConnection{
		Edges:      edges,
		TotalCount: int(count),
		PageInfo: &model.PageInfo{
			HasNextPage: int64(o)+int64(l) < count,
		},
	}, nil
}

// CompanyFinancialSummary is the resolver for the companyFinancialSummary field.
func (r *queryResolver) CompanyFinancialSummary(ctx context.Context, companyID string) (*model.CompanyFinancialSummary, error) {
	claims := auth.GetUserFromContext(ctx)
	if claims == nil {
		return nil, fmt.Errorf("not authenticated")
	}

	row, err := r.Queries.GetCompanyFinancialSummary(ctx, stringToUUID(companyID))
	if err != nil {
		return nil, fmt.Errorf("failed to get company financial summary: %w", err)
	}

	return &model.CompanyFinancialSummary{
		CompletedBookings: int(row.CompletedBookings),
		TotalRevenue:      numericToFloat(row.TotalRevenue),
		TotalCommission:   numericToFloat(row.TotalCommission),
		NetPayout:         numericToFloat(row.NetPayout),
	}, nil
}

// SearchBookings is the resolver for the searchBookings field.
func (r *queryResolver) SearchBookings(ctx context.Context, query *string, status *model.BookingStatus, limit *int, offset *int) (*model.BookingConnection, error) {
	claims := auth.GetUserFromContext(ctx)
	if claims == nil {
		return nil, fmt.Errorf("not authenticated")
	}

	l := int32(50)
	if limit != nil {
		l = int32(*limit)
	}
	o := int32(0)
	if offset != nil {
		o = int32(*offset)
	}
	q := ""
	if query != nil {
		q = *query
	}
	statusFilter := ""
	if status != nil {
		statusFilter = strings.ToLower(string(*status))
	}

	dbBookings, err := r.Queries.SearchBookings(ctx, db.SearchBookingsParams{
		Limit:        l,
		Offset:       o,
		Query:        q,
		StatusFilter: statusFilter,
	})
	if err != nil {
		return nil, fmt.Errorf("failed to search bookings: %w", err)
	}

	count, err := r.Queries.CountSearchBookings(ctx, db.CountSearchBookingsParams{
		Query:        q,
		StatusFilter: statusFilter,
	})
	if err != nil {
		return nil, fmt.Errorf("failed to count bookings: %w", err)
	}

	bookings := make([]*model.Booking, len(dbBookings))
	for i, b := range dbBookings {
		gqlBooking := dbBookingToGQL(b)
		r.enrichBooking(ctx, b, gqlBooking)
		bookings[i] = gqlBooking
	}

	return &model.BookingConnection{
		Edges:      bookings,
		TotalCount: int(count),
		PageInfo: &model.PageInfo{
			HasNextPage: int64(o)+int64(l) < count,
		},
	}, nil
}

// AllReviews is the resolver for the allReviews field.
func (r *queryResolver) AllReviews(ctx context.Context, limit *int, offset *int) (*model.ReviewConnection, error) {
	claims := auth.GetUserFromContext(ctx)
	if claims == nil {
		return nil, fmt.Errorf("not authenticated")
	}

	l := int32(50)
	if limit != nil {
		l = int32(*limit)
	}
	o := int32(0)
	if offset != nil {
		o = int32(*offset)
	}

	dbReviews, err := r.Queries.ListAllReviews(ctx, db.ListAllReviewsParams{
		Limit:  l,
		Offset: o,
	})
	if err != nil {
		return nil, fmt.Errorf("failed to list reviews: %w", err)
	}

	count, err := r.Queries.CountAllReviews(ctx)
	if err != nil {
		return nil, fmt.Errorf("failed to count reviews: %w", err)
	}

	reviews := make([]*model.Review, len(dbReviews))
	for i, rv := range dbReviews {
		review := dbReviewToGQL(rv)

		// Populate the associated booking.
		if booking, err := r.Queries.GetBookingByID(ctx, rv.BookingID); err == nil {
			review.Booking = dbBookingToGQL(booking)
		}

		// Populate the reviewer user.
		if rv.ReviewerUserID.Valid {
			if user, err := r.Queries.GetUserByID(ctx, rv.ReviewerUserID); err == nil {
				review.Reviewer = dbUserToGQL(user)
			}
		}

		reviews[i] = review
	}

	return &model.ReviewConnection{
		Reviews:    reviews,
		TotalCount: int(count),
	}, nil
}
