package resolver

// This file will be automatically regenerated based on the schema, any resolver
// implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.86

import (
	"context"
	"fmt"
	"helpmeclean-backend/internal/auth"
	db "helpmeclean-backend/internal/db/generated"
	"helpmeclean-backend/internal/graph"
	"helpmeclean-backend/internal/graph/model"
	"helpmeclean-backend/internal/storage"
	"strings"

	"github.com/99designs/gqlgen/graphql"
)

// UpdateProfile is the resolver for the updateProfile field.
func (r *mutationResolver) UpdateProfile(ctx context.Context, input model.UpdateProfileInput) (*model.User, error) {
	claims := auth.GetUserFromContext(ctx)
	if claims == nil {
		return nil, fmt.Errorf("not authenticated")
	}

	userID := stringToUUID(claims.UserID)

	// Get current user to preserve fields that are not being updated.
	currentUser, err := r.Queries.GetUserByID(ctx, userID)
	if err != nil {
		return nil, fmt.Errorf("user not found: %w", err)
	}

	fullName := currentUser.FullName
	if input.FullName != nil {
		fullName = *input.FullName
	}

	phone := currentUser.Phone
	if input.Phone != nil {
		phone = stringToText(input.Phone)
	}

	avatarURL := currentUser.AvatarUrl
	if input.AvatarURL != nil {
		avatarURL = stringToText(input.AvatarURL)
	}

	preferredLang := currentUser.PreferredLanguage
	if input.PreferredLanguage != nil {
		preferredLang = stringToText(input.PreferredLanguage)
	}

	updatedUser, err := r.Queries.UpdateUser(ctx, db.UpdateUserParams{
		ID:                userID,
		FullName:          fullName,
		Phone:             phone,
		AvatarUrl:         avatarURL,
		PreferredLanguage: preferredLang,
	})
	if err != nil {
		return nil, fmt.Errorf("failed to update profile: %w", err)
	}

	return dbUserToGQL(updatedUser), nil
}

// UploadAvatar is the resolver for the uploadAvatar field.
func (r *mutationResolver) UploadAvatar(ctx context.Context, file graphql.Upload) (*model.User, error) {
	claims := auth.GetUserFromContext(ctx)
	if claims == nil {
		return nil, fmt.Errorf("not authenticated")
	}

	// Validate file type (images only)
	if !isImageFile(file.Filename) {
		return nil, fmt.Errorf("doar imagini sunt permise (jpg, png, webp)")
	}

	// Validate file size (max 10MB)
	if file.Size > 10*1024*1024 {
		return nil, fmt.Errorf("fisierul depaseste limita de 10MB")
	}

	// Build GCS path: uploads/clients/{userId}/avatars/{uuid}_{filename}
	path := fmt.Sprintf("uploads/clients/%s/avatars", claims.UserID)

	// Upload to GCS with public access
	avatarURL, err := r.Storage.Upload(ctx, path, file.Filename, file.File, storage.StorageTypePublic)
	if err != nil {
		return nil, fmt.Errorf("eroare la incarcarea fisierului: %w", err)
	}

	// Update user record in DB
	user, err := r.Queries.UpdateUserAvatar(ctx, db.UpdateUserAvatarParams{
		ID:        stringToUUID(claims.UserID),
		AvatarUrl: stringToText(&avatarURL),
	})
	if err != nil {
		return nil, fmt.Errorf("failed to update user avatar: %w", err)
	}

	return dbUserToGQL(user), nil
}

// UpdateUserRole is the resolver for the updateUserRole field.
func (r *mutationResolver) UpdateUserRole(ctx context.Context, userID string, role model.UserRole) (*model.User, error) {
	claims := auth.GetUserFromContext(ctx)
	if claims == nil || claims.Role != "global_admin" {
		return nil, fmt.Errorf("not authorized")
	}

	updated, err := r.Queries.UpdateUserRole(ctx, db.UpdateUserRoleParams{
		ID:   stringToUUID(userID),
		Role: gqlUserRoleToDb(role),
	})
	if err != nil {
		return nil, fmt.Errorf("failed to update user role: %w", err)
	}

	return dbUserToGQL(updated), nil
}

// AdminUpdateUserProfile is the resolver for the adminUpdateUserProfile field.
func (r *mutationResolver) AdminUpdateUserProfile(ctx context.Context, userID string, fullName string, phone *string) (*model.User, error) {
	claims := auth.GetUserFromContext(ctx)
	if claims == nil || claims.Role != "global_admin" {
		return nil, fmt.Errorf("not authorized")
	}

	updated, err := r.Queries.AdminUpdateUserProfile(ctx, db.AdminUpdateUserProfileParams{
		ID:       stringToUUID(userID),
		FullName: fullName,
		Phone:    stringToText(phone),
	})
	if err != nil {
		return nil, fmt.Errorf("failed to update user profile: %w", err)
	}

	return dbUserToGQL(updated), nil
}

// Me is the resolver for the me field.
// Returns nil (not an error) when unauthenticated so the frontend treats
// a null response as "not logged in" rather than a hard failure.
func (r *queryResolver) Me(ctx context.Context) (*model.User, error) {
	claims := auth.GetUserFromContext(ctx)
	if claims == nil {
		return nil, nil
	}

	dbUser, err := r.Queries.GetUserByID(ctx, stringToUUID(claims.UserID))
	if err != nil {
		return nil, fmt.Errorf("user not found: %w", err)
	}

	return dbUserToGQL(dbUser), nil
}

// SearchUsers is the resolver for the searchUsers field.
func (r *queryResolver) SearchUsers(ctx context.Context, query *string, role *model.UserRole, status *model.UserStatus, limit *int, offset *int) (*model.UserConnection, error) {
	claims := auth.GetUserFromContext(ctx)
	if claims == nil || claims.Role != "global_admin" {
		return nil, fmt.Errorf("not authorized")
	}

	// Apply defaults.
	lim := int32(50)
	if limit != nil {
		lim = int32(*limit)
	}
	off := int32(0)
	if offset != nil {
		off = int32(*offset)
	}

	queryStr := ""
	if query != nil {
		queryStr = *query
	}

	roleFilter := ""
	if role != nil {
		roleFilter = strings.ToLower(string(*role))
	}

	statusFilter := ""
	if status != nil {
		statusFilter = strings.ToLower(string(*status))
	}

	users, err := r.Queries.SearchUsers(ctx, db.SearchUsersParams{
		Limit:        lim,
		Offset:       off,
		Query:        queryStr,
		RoleFilter:   roleFilter,
		StatusFilter: statusFilter,
	})
	if err != nil {
		return nil, fmt.Errorf("failed to search users: %w", err)
	}

	totalCount, err := r.Queries.CountSearchUsers(ctx, db.CountSearchUsersParams{
		Query:        queryStr,
		RoleFilter:   roleFilter,
		StatusFilter: statusFilter,
	})
	if err != nil {
		return nil, fmt.Errorf("failed to count users: %w", err)
	}

	result := make([]*model.User, len(users))
	for i, u := range users {
		result[i] = dbUserToGQL(u)
	}

	return &model.UserConnection{
		Users:      result,
		TotalCount: int(totalCount),
	}, nil
}

// User is the resolver for the user field.
func (r *queryResolver) User(ctx context.Context, id string) (*model.User, error) {
	claims := auth.GetUserFromContext(ctx)
	if claims == nil || claims.Role != "global_admin" {
		return nil, fmt.Errorf("not authorized")
	}

	dbUser, err := r.Queries.GetUserByID(ctx, stringToUUID(id))
	if err != nil {
		return nil, fmt.Errorf("user not found: %w", err)
	}

	return dbUserToGQL(dbUser), nil
}

// CleanerProfile is the resolver for the cleanerProfile field.
func (r *userResolver) CleanerProfile(ctx context.Context, obj *model.User) (*model.CleanerProfile, error) {
	// Only return cleaner data if user role is CLEANER
	if obj.Role != model.UserRoleCleaner {
		return nil, nil
	}

	// Fetch cleaner profile by user ID
	cleaner, err := r.Queries.GetCleanerByUserID(ctx, stringToUUID(obj.ID))
	if err != nil {
		// No cleaner profile found - return nil (not an error)
		return nil, nil
	}

	// Use cleanerWithCompany helper to load all nested data (company, documents, personality)
	return r.Resolver.cleanerWithCompany(ctx, cleaner)
}

// User returns graph.UserResolver implementation.
func (r *Resolver) User() graph.UserResolver { return &userResolver{r} }

type userResolver struct{ *Resolver }
