package resolver

// This file will be automatically regenerated based on the schema, any resolver
// implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.86

import (
	"context"
	"fmt"
	"helpmeclean-backend/internal/auth"
	db "helpmeclean-backend/internal/db/generated"
	"helpmeclean-backend/internal/graph/model"

	"github.com/jackc/pgx/v5/pgtype"
)

// CancelRecurringGroup is the resolver for the cancelRecurringGroup field.
func (r *mutationResolver) CancelRecurringGroup(ctx context.Context, id string, reason *string) (*model.RecurringBookingGroup, error) {
	claims := auth.GetUserFromContext(ctx)
	if claims == nil {
		return nil, fmt.Errorf("not authenticated")
	}

	groupUUID := stringToUUID(id)
	group, err := r.Queries.GetRecurringGroupByID(ctx, groupUUID)
	if err != nil {
		return nil, fmt.Errorf("recurring group not found: %w", err)
	}

	if uuidToString(group.ClientUserID) != claims.UserID && claims.Role != "global_admin" {
		return nil, fmt.Errorf("not authorized")
	}

	var reasonText string
	if reason != nil {
		reasonText = *reason
	}

	group, err = r.Queries.CancelRecurringGroup(ctx, db.CancelRecurringGroupParams{
		ID:                 groupUUID,
		CancellationReason: pgtype.Text{String: reasonText, Valid: reasonText != ""},
	})
	if err != nil {
		return nil, fmt.Errorf("failed to cancel recurring group: %w", err)
	}

	// Cancel all future pending/confirmed occurrences.
	_ = r.Queries.CancelFutureOccurrences(ctx, db.CancelFutureOccurrencesParams{
		RecurringGroupID:   groupUUID,
		CancellationReason: pgtype.Text{String: reasonText, Valid: reasonText != ""},
	})

	return r.enrichRecurringGroup(ctx, group)
}

// PauseRecurringGroup is the resolver for the pauseRecurringGroup field.
func (r *mutationResolver) PauseRecurringGroup(ctx context.Context, id string) (*model.RecurringBookingGroup, error) {
	claims := auth.GetUserFromContext(ctx)
	if claims == nil {
		return nil, fmt.Errorf("not authenticated")
	}

	groupUUID := stringToUUID(id)
	group, err := r.Queries.GetRecurringGroupByID(ctx, groupUUID)
	if err != nil {
		return nil, fmt.Errorf("recurring group not found: %w", err)
	}

	if uuidToString(group.ClientUserID) != claims.UserID && claims.Role != "global_admin" {
		return nil, fmt.Errorf("not authorized")
	}

	group, err = r.Queries.PauseRecurringGroup(ctx, groupUUID)
	if err != nil {
		return nil, fmt.Errorf("failed to pause recurring group: %w", err)
	}

	return r.enrichRecurringGroup(ctx, group)
}

// ResumeRecurringGroup is the resolver for the resumeRecurringGroup field.
func (r *mutationResolver) ResumeRecurringGroup(ctx context.Context, id string) (*model.RecurringBookingGroup, error) {
	claims := auth.GetUserFromContext(ctx)
	if claims == nil {
		return nil, fmt.Errorf("not authenticated")
	}

	groupUUID := stringToUUID(id)
	group, err := r.Queries.GetRecurringGroupByID(ctx, groupUUID)
	if err != nil {
		return nil, fmt.Errorf("recurring group not found: %w", err)
	}

	if uuidToString(group.ClientUserID) != claims.UserID && claims.Role != "global_admin" {
		return nil, fmt.Errorf("not authorized")
	}

	group, err = r.Queries.ResumeRecurringGroup(ctx, groupUUID)
	if err != nil {
		return nil, fmt.Errorf("failed to resume recurring group: %w", err)
	}

	return r.enrichRecurringGroup(ctx, group)
}

// MyRecurringGroups is the resolver for the myRecurringGroups field.
func (r *queryResolver) MyRecurringGroups(ctx context.Context) ([]*model.RecurringBookingGroup, error) {
	claims := auth.GetUserFromContext(ctx)
	if claims == nil {
		return nil, fmt.Errorf("not authenticated")
	}

	groups, err := r.Queries.ListRecurringGroupsByClient(ctx, stringToUUID(claims.UserID))
	if err != nil {
		return nil, fmt.Errorf("failed to list recurring groups: %w", err)
	}

	result := make([]*model.RecurringBookingGroup, len(groups))
	for i, g := range groups {
		enriched, err := r.enrichRecurringGroup(ctx, g)
		if err != nil {
			return nil, err
		}
		result[i] = enriched
	}

	return result, nil
}

// RecurringGroup is the resolver for the recurringGroup field.
func (r *queryResolver) RecurringGroup(ctx context.Context, id string) (*model.RecurringBookingGroup, error) {
	claims := auth.GetUserFromContext(ctx)
	if claims == nil {
		return nil, fmt.Errorf("not authenticated")
	}

	group, err := r.Queries.GetRecurringGroupByID(ctx, stringToUUID(id))
	if err != nil {
		return nil, fmt.Errorf("recurring group not found: %w", err)
	}

	return r.enrichRecurringGroup(ctx, group)
}
