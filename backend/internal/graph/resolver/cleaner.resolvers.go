package resolver

// This file will be automatically regenerated based on the schema, any resolver
// implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.86

import (
	"context"
	"crypto/rand"
	"encoding/hex"
	"fmt"
	"helpmeclean-backend/internal/auth"
	db "helpmeclean-backend/internal/db/generated"
	"helpmeclean-backend/internal/graph/model"
	"time"

	"github.com/jackc/pgx/v5/pgtype"
)

// InviteCleaner is the resolver for the inviteCleaner field.
func (r *mutationResolver) InviteCleaner(ctx context.Context, input model.InviteCleanerInput) (*model.CleanerProfile, error) {
	claims := auth.GetUserFromContext(ctx)
	if claims == nil {
		return nil, fmt.Errorf("not authenticated")
	}

	// Get the company for this admin user.
	company, err := r.Queries.GetCompanyByAdminUserID(ctx, stringToUUID(claims.UserID))
	if err != nil {
		return nil, fmt.Errorf("you need to register your company before inviting cleaners")
	}

	// Verify company is approved before allowing cleaner invitations.
	if company.Status != db.CompanyStatusApproved {
		return nil, fmt.Errorf("your company is not yet approved. only approved companies can invite cleaners")
	}

	// Generate unique random invite token (32 bytes = 64 hex chars).
	tokenBytes := make([]byte, 32)
	if _, err := rand.Read(tokenBytes); err != nil {
		return nil, fmt.Errorf("failed to generate invite token: %w", err)
	}
	inviteToken := "inv-" + hex.EncodeToString(tokenBytes)

	cleaner, err := r.Queries.CreateCleaner(ctx, db.CreateCleanerParams{
		CompanyID:      company.ID,
		FullName:       input.FullName,
		Phone:          stringToText(input.Phone),
		Email:          stringToTextVal(input.Email),
		Status:         db.CleanerStatusInvited,
		IsCompanyAdmin: pgtype.Bool{Bool: false, Valid: true},
		InviteToken:    stringToTextVal(inviteToken),
		InviteExpiresAt: pgtype.Timestamptz{
			Time:  time.Now().Add(7 * 24 * time.Hour),
			Valid: true,
		},
	})
	if err != nil {
		return nil, fmt.Errorf("failed to invite cleaner: %w", err)
	}

	return r.cleanerWithCompany(ctx, cleaner)
}

// InviteSelfAsCleaner is the resolver for the inviteSelfAsCleaner field.
func (r *mutationResolver) InviteSelfAsCleaner(ctx context.Context) (*model.CleanerProfile, error) {
	claims := auth.GetUserFromContext(ctx)
	if claims == nil {
		return nil, fmt.Errorf("not authenticated")
	}

	// Get the company for this admin user.
	company, err := r.Queries.GetCompanyByAdminUserID(ctx, stringToUUID(claims.UserID))
	if err != nil {
		return nil, fmt.Errorf("company not found for user: %w", err)
	}

	// Get user info to populate cleaner record.
	user, err := r.Queries.GetUserByID(ctx, stringToUUID(claims.UserID))
	if err != nil {
		return nil, fmt.Errorf("user not found: %w", err)
	}

	cleaner, err := r.Queries.CreateCleaner(ctx, db.CreateCleanerParams{
		CompanyID:       company.ID,
		FullName:        user.FullName,
		Phone:           user.Phone,
		Email:           pgtype.Text{String: user.Email, Valid: true},
		Status:          db.CleanerStatusActive,
		IsCompanyAdmin:  pgtype.Bool{Bool: true, Valid: true},
		InviteToken:     pgtype.Text{},
		InviteExpiresAt: pgtype.Timestamptz{},
	})
	if err != nil {
		return nil, fmt.Errorf("failed to create cleaner profile: %w", err)
	}

	// Link cleaner to the current user.
	cleaner, err = r.Queries.LinkCleanerToUser(ctx, db.LinkCleanerToUserParams{
		ID:     cleaner.ID,
		UserID: stringToUUID(claims.UserID),
	})
	if err != nil {
		return nil, fmt.Errorf("failed to link cleaner to user: %w", err)
	}

	return r.cleanerWithCompany(ctx, cleaner)
}

// UpdateCleanerStatus is the resolver for the updateCleanerStatus field.
func (r *mutationResolver) UpdateCleanerStatus(ctx context.Context, id string, status model.CleanerStatus) (*model.CleanerProfile, error) {
	claims := auth.GetUserFromContext(ctx)
	if claims == nil {
		return nil, fmt.Errorf("not authenticated")
	}

	cleaner, err := r.Queries.UpdateCleanerStatus(ctx, db.UpdateCleanerStatusParams{
		ID:     stringToUUID(id),
		Status: gqlCleanerStatusToDb(status),
	})
	if err != nil {
		return nil, fmt.Errorf("failed to update cleaner status: %w", err)
	}

	return r.cleanerWithCompany(ctx, cleaner)
}

// AcceptInvitation is the resolver for the acceptInvitation field.
func (r *mutationResolver) AcceptInvitation(ctx context.Context, token string) (*model.CleanerProfile, error) {
	claims := auth.GetUserFromContext(ctx)
	if claims == nil {
		return nil, fmt.Errorf("not authenticated")
	}

	// Look up cleaner by invite token.
	cleaner, err := r.Queries.GetCleanerByInviteToken(ctx, stringToTextVal(token))
	if err != nil {
		return nil, fmt.Errorf("invalid invitation token: %w", err)
	}

	// Link cleaner to the current user (also sets status to active).
	cleaner, err = r.Queries.LinkCleanerToUser(ctx, db.LinkCleanerToUserParams{
		ID:     cleaner.ID,
		UserID: stringToUUID(claims.UserID),
	})
	if err != nil {
		return nil, fmt.Errorf("failed to accept invitation: %w", err)
	}

	return r.cleanerWithCompany(ctx, cleaner)
}

// UpdateAvailability is the resolver for the updateAvailability field.
func (r *mutationResolver) UpdateAvailability(ctx context.Context, slots []*model.AvailabilitySlotInput) ([]*model.AvailabilitySlot, error) {
	claims := auth.GetUserFromContext(ctx)
	if claims == nil {
		return nil, fmt.Errorf("not authenticated")
	}

	cleaner, err := r.Queries.GetCleanerByUserID(ctx, stringToUUID(claims.UserID))
	if err != nil {
		return nil, fmt.Errorf("cleaner profile not found: %w", err)
	}

	// Delete existing availability and recreate.
	err = r.Queries.DeleteCleanerAvailability(ctx, cleaner.ID)
	if err != nil {
		return nil, fmt.Errorf("failed to clear availability: %w", err)
	}

	var result []*model.AvailabilitySlot
	for _, slot := range slots {
		// Parse start time.
		startTime, _ := time.Parse("15:04", slot.StartTime)
		endTime, _ := time.Parse("15:04", slot.EndTime)

		avail, err := r.Queries.SetCleanerAvailability(ctx, db.SetCleanerAvailabilityParams{
			CleanerID: cleaner.ID,
			DayOfWeek: int32(slot.DayOfWeek),
			StartTime: pgtype.Time{
				Microseconds: int64(startTime.Hour())*3_600_000_000 + int64(startTime.Minute())*60_000_000,
				Valid:        true,
			},
			EndTime: pgtype.Time{
				Microseconds: int64(endTime.Hour())*3_600_000_000 + int64(endTime.Minute())*60_000_000,
				Valid:        true,
			},
			IsAvailable: pgtype.Bool{Bool: slot.IsAvailable, Valid: true},
		})
		if err != nil {
			return nil, fmt.Errorf("failed to set availability: %w", err)
		}

		result = append(result, &model.AvailabilitySlot{
			ID:          uuidToString(avail.ID),
			DayOfWeek:   int(avail.DayOfWeek),
			StartTime:   timeToString(avail.StartTime),
			EndTime:     timeToString(avail.EndTime),
			IsAvailable: boolVal(avail.IsAvailable),
		})
	}

	return result, nil
}

// MyCleaners is the resolver for the myCleaners field.
func (r *queryResolver) MyCleaners(ctx context.Context) ([]*model.CleanerProfile, error) {
	claims := auth.GetUserFromContext(ctx)
	if claims == nil {
		return nil, fmt.Errorf("not authenticated")
	}

	company, err := r.Queries.GetCompanyByAdminUserID(ctx, stringToUUID(claims.UserID))
	if err != nil {
		return nil, fmt.Errorf("company not found for user. please register your company first: %w", err)
	}

	cleaners, err := r.Queries.ListCleanersByCompany(ctx, company.ID)
	if err != nil {
		return nil, fmt.Errorf("failed to list cleaners: %w", err)
	}

	companyGQL := dbCompanyToGQL(company)
	result := make([]*model.CleanerProfile, len(cleaners))
	for i, c := range cleaners {
		profile := dbCleanerToGQL(c)
		profile.Company = companyGQL
		result[i] = profile
	}

	return result, nil
}

// MyCleanerProfile is the resolver for the myCleanerProfile field.
func (r *queryResolver) MyCleanerProfile(ctx context.Context) (*model.CleanerProfile, error) {
	claims := auth.GetUserFromContext(ctx)
	if claims == nil {
		return nil, fmt.Errorf("not authenticated")
	}

	cleaner, err := r.Queries.GetCleanerByUserID(ctx, stringToUUID(claims.UserID))
	if err != nil {
		return nil, fmt.Errorf("cleaner profile not found: %w", err)
	}

	return r.cleanerWithCompany(ctx, cleaner)
}

// MyCleanerStats is the resolver for the myCleanerStats field.
func (r *queryResolver) MyCleanerStats(ctx context.Context) (*model.CleanerStats, error) {
	claims := auth.GetUserFromContext(ctx)
	if claims == nil {
		return nil, fmt.Errorf("not authenticated")
	}

	cleaner, err := r.Queries.GetCleanerByUserID(ctx, stringToUUID(claims.UserID))
	if err != nil {
		return nil, fmt.Errorf("cleaner profile not found: %w", err)
	}

	avgRating, err := r.Queries.GetAverageCleanerRating(ctx, cleaner.ID)
	if err != nil {
		return nil, fmt.Errorf("failed to get average rating: %w", err)
	}

	reviews, err := r.Queries.ListReviewsByCleanerID(ctx, db.ListReviewsByCleanerIDParams{
		ReviewedCleanerID: cleaner.ID,
		Limit:             1000,
		Offset:            0,
	})
	if err != nil {
		return nil, fmt.Errorf("failed to list reviews: %w", err)
	}

	completedCount, err := r.Queries.CountCompletedJobsByCleaner(ctx, cleaner.ID)
	if err != nil {
		return nil, fmt.Errorf("failed to count completed jobs: %w", err)
	}

	thisMonthJobs, err := r.Queries.CountThisMonthJobsByCleaner(ctx, cleaner.ID)
	if err != nil {
		return nil, fmt.Errorf("failed to count this month jobs: %w", err)
	}

	thisMonthEarnings, err := r.Queries.SumThisMonthEarningsByCleaner(ctx, cleaner.ID)
	if err != nil {
		return nil, fmt.Errorf("failed to sum this month earnings: %w", err)
	}

	return &model.CleanerStats{
		TotalJobsCompleted: int(completedCount),
		AverageRating:      numericToFloat(avgRating),
		TotalReviews:       len(reviews),
		ThisMonthJobs:      int(thisMonthJobs),
		ThisMonthEarnings:  numericToFloat(thisMonthEarnings),
	}, nil
}
