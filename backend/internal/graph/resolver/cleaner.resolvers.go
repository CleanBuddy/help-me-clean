package resolver

// This file will be automatically regenerated based on the schema, any resolver
// implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.86

import (
	"context"
	"crypto/rand"
	"encoding/hex"
	"fmt"
	"helpmeclean-backend/internal/auth"
	db "helpmeclean-backend/internal/db/generated"
	"helpmeclean-backend/internal/graph/model"
	"helpmeclean-backend/internal/storage"
	"strings"
	"time"

	"github.com/99designs/gqlgen/graphql"
	"github.com/jackc/pgx/v5/pgtype"
)

// InviteCleaner is the resolver for the inviteCleaner field.
func (r *mutationResolver) InviteCleaner(ctx context.Context, input model.InviteCleanerInput) (*model.CleanerProfile, error) {
	claims := auth.GetUserFromContext(ctx)
	if claims == nil {
		return nil, fmt.Errorf("not authenticated")
	}

	// Get the company for this admin user.
	company, err := r.Queries.GetCompanyByAdminUserID(ctx, stringToUUID(claims.UserID))
	if err != nil {
		return nil, fmt.Errorf("you need to register your company before inviting cleaners")
	}

	// Verify company is approved before allowing cleaner invitations.
	if company.Status != db.CompanyStatusApproved {
		return nil, fmt.Errorf("your company is not yet approved. only approved companies can invite cleaners")
	}

	// Generate unique random invite token (32 bytes = 64 hex chars).
	tokenBytes := make([]byte, 32)
	if _, err := rand.Read(tokenBytes); err != nil {
		return nil, fmt.Errorf("failed to generate invite token: %w", err)
	}
	inviteToken := "inv-" + hex.EncodeToString(tokenBytes)

	cleaner, err := r.Queries.CreateCleaner(ctx, db.CreateCleanerParams{
		CompanyID:      company.ID,
		FullName:       input.FullName,
		Phone:          stringToText(input.Phone),
		Email:          stringToTextVal(input.Email),
		Status:         db.CleanerStatusInvited,
		IsCompanyAdmin: pgtype.Bool{Bool: false, Valid: true},
		InviteToken:    stringToTextVal(inviteToken),
		InviteExpiresAt: pgtype.Timestamptz{
			Time:  time.Now().Add(7 * 24 * time.Hour),
			Valid: true,
		},
	})
	if err != nil {
		return nil, fmt.Errorf("failed to invite cleaner: %w", err)
	}

	// Auto-assign all company service areas to the new cleaner.
	r.copyCompanyAreasToCleanerHelper(ctx, company.ID, cleaner.ID)

	return r.cleanerWithCompany(ctx, cleaner)
}

// InviteSelfAsCleaner is the resolver for the inviteSelfAsCleaner field.
func (r *mutationResolver) InviteSelfAsCleaner(ctx context.Context) (*model.CleanerProfile, error) {
	claims := auth.GetUserFromContext(ctx)
	if claims == nil {
		return nil, fmt.Errorf("not authenticated")
	}

	// Get the company for this admin user.
	company, err := r.Queries.GetCompanyByAdminUserID(ctx, stringToUUID(claims.UserID))
	if err != nil {
		return nil, fmt.Errorf("company not found for user: %w", err)
	}

	// Get user info to populate cleaner record.
	user, err := r.Queries.GetUserByID(ctx, stringToUUID(claims.UserID))
	if err != nil {
		return nil, fmt.Errorf("user not found: %w", err)
	}

	cleaner, err := r.Queries.CreateCleaner(ctx, db.CreateCleanerParams{
		CompanyID:       company.ID,
		FullName:        user.FullName,
		Phone:           user.Phone,
		Email:           pgtype.Text{String: user.Email, Valid: true},
		Status:          db.CleanerStatusActive,
		IsCompanyAdmin:  pgtype.Bool{Bool: true, Valid: true},
		InviteToken:     pgtype.Text{},
		InviteExpiresAt: pgtype.Timestamptz{},
	})
	if err != nil {
		return nil, fmt.Errorf("failed to create cleaner profile: %w", err)
	}

	// Link cleaner to the current user.
	cleaner, err = r.Queries.LinkCleanerToUser(ctx, db.LinkCleanerToUserParams{
		ID:     cleaner.ID,
		UserID: stringToUUID(claims.UserID),
	})
	if err != nil {
		return nil, fmt.Errorf("failed to link cleaner to user: %w", err)
	}

	// Auto-assign all company service areas to the new cleaner.
	r.copyCompanyAreasToCleanerHelper(ctx, company.ID, cleaner.ID)

	return r.cleanerWithCompany(ctx, cleaner)
}

// UpdateCleanerStatus is the resolver for the updateCleanerStatus field.
func (r *mutationResolver) UpdateCleanerStatus(ctx context.Context, id string, status model.CleanerStatus) (*model.CleanerProfile, error) {
	claims := auth.GetUserFromContext(ctx)
	if claims == nil {
		return nil, fmt.Errorf("not authenticated")
	}

	cleaner, err := r.Queries.UpdateCleanerStatus(ctx, db.UpdateCleanerStatusParams{
		ID:     stringToUUID(id),
		Status: gqlCleanerStatusToDb(status),
	})
	if err != nil {
		return nil, fmt.Errorf("failed to update cleaner status: %w", err)
	}

	return r.cleanerWithCompany(ctx, cleaner)
}

// AcceptInvitation is the resolver for the acceptInvitation field.
func (r *mutationResolver) AcceptInvitation(ctx context.Context, token string) (*model.CleanerProfile, error) {
	claims := auth.GetUserFromContext(ctx)
	if claims == nil {
		return nil, fmt.Errorf("not authenticated")
	}

	// Look up cleaner by invite token.
	cleaner, err := r.Queries.GetCleanerByInviteToken(ctx, stringToTextVal(token))
	if err != nil {
		return nil, fmt.Errorf("invalid invitation token: %w", err)
	}

	// Link cleaner to the current user (also sets status to active).
	cleaner, err = r.Queries.LinkCleanerToUser(ctx, db.LinkCleanerToUserParams{
		ID:     cleaner.ID,
		UserID: stringToUUID(claims.UserID),
	})
	if err != nil {
		return nil, fmt.Errorf("failed to accept invitation: %w", err)
	}

	// Upgrade the user's role to CLEANER regardless of what role they signed up with.
	// This handles the case where someone signed in as CLIENT before accepting an invitation.
	_, err = r.Queries.UpdateUserRole(ctx, db.UpdateUserRoleParams{
		ID:   stringToUUID(claims.UserID),
		Role: db.UserRoleCleaner,
	})
	if err != nil {
		// Non-fatal â€” the cleaner profile is linked; log but don't fail.
		fmt.Printf("warning: failed to upgrade user role to cleaner after invitation: %v\n", err)
	}

	return r.cleanerWithCompany(ctx, cleaner)
}

// UpdateAvailability is the resolver for the updateAvailability field.
func (r *mutationResolver) UpdateAvailability(ctx context.Context, slots []*model.AvailabilitySlotInput) ([]*model.AvailabilitySlot, error) {
	claims := auth.GetUserFromContext(ctx)
	if claims == nil {
		return nil, fmt.Errorf("not authenticated")
	}

	cleaner, err := r.Queries.GetCleanerByUserID(ctx, stringToUUID(claims.UserID))
	if err != nil {
		return nil, fmt.Errorf("cleaner profile not found: %w", err)
	}

	// Delete existing availability and recreate.
	err = r.Queries.DeleteCleanerAvailability(ctx, cleaner.ID)
	if err != nil {
		return nil, fmt.Errorf("failed to clear availability: %w", err)
	}

	var result []*model.AvailabilitySlot
	for _, slot := range slots {
		// Parse start time.
		startTime, _ := time.Parse("15:04", slot.StartTime)
		endTime, _ := time.Parse("15:04", slot.EndTime)

		avail, err := r.Queries.SetCleanerAvailability(ctx, db.SetCleanerAvailabilityParams{
			CleanerID: cleaner.ID,
			DayOfWeek: int32(slot.DayOfWeek),
			StartTime: pgtype.Time{
				Microseconds: int64(startTime.Hour())*3_600_000_000 + int64(startTime.Minute())*60_000_000,
				Valid:        true,
			},
			EndTime: pgtype.Time{
				Microseconds: int64(endTime.Hour())*3_600_000_000 + int64(endTime.Minute())*60_000_000,
				Valid:        true,
			},
			IsAvailable: pgtype.Bool{Bool: slot.IsAvailable, Valid: true},
		})
		if err != nil {
			return nil, fmt.Errorf("failed to set availability: %w", err)
		}

		result = append(result, &model.AvailabilitySlot{
			ID:          uuidToString(avail.ID),
			DayOfWeek:   int(avail.DayOfWeek),
			StartTime:   timeToString(avail.StartTime),
			EndTime:     timeToString(avail.EndTime),
			IsAvailable: boolVal(avail.IsAvailable),
		})
	}

	return result, nil
}

// UpdateCleanerAvailability is the resolver for the updateCleanerAvailability field.
func (r *mutationResolver) UpdateCleanerAvailability(ctx context.Context, cleanerID string, slots []*model.AvailabilitySlotInput) ([]*model.AvailabilitySlot, error) {
	claims := auth.GetUserFromContext(ctx)
	if claims == nil {
		return nil, fmt.Errorf("not authenticated")
	}

	// Verify the cleaner belongs to the company admin's company.
	company, err := r.Queries.GetCompanyByAdminUserID(ctx, stringToUUID(claims.UserID))
	if err != nil {
		return nil, fmt.Errorf("company not found for user: %w", err)
	}

	cleaner, err := r.Queries.GetCleanerByID(ctx, stringToUUID(cleanerID))
	if err != nil {
		return nil, fmt.Errorf("cleaner not found: %w", err)
	}

	if cleaner.CompanyID != company.ID {
		return nil, fmt.Errorf("cleaner does not belong to your company")
	}

	// Delete existing availability and recreate.
	err = r.Queries.DeleteCleanerAvailability(ctx, cleaner.ID)
	if err != nil {
		return nil, fmt.Errorf("failed to clear availability: %w", err)
	}

	var result []*model.AvailabilitySlot
	for _, slot := range slots {
		startTime, _ := time.Parse("15:04", slot.StartTime)
		endTime, _ := time.Parse("15:04", slot.EndTime)

		avail, err := r.Queries.SetCleanerAvailability(ctx, db.SetCleanerAvailabilityParams{
			CleanerID: cleaner.ID,
			DayOfWeek: int32(slot.DayOfWeek),
			StartTime: pgtype.Time{
				Microseconds: int64(startTime.Hour())*3_600_000_000 + int64(startTime.Minute())*60_000_000,
				Valid:        true,
			},
			EndTime: pgtype.Time{
				Microseconds: int64(endTime.Hour())*3_600_000_000 + int64(endTime.Minute())*60_000_000,
				Valid:        true,
			},
			IsAvailable: pgtype.Bool{Bool: slot.IsAvailable, Valid: true},
		})
		if err != nil {
			return nil, fmt.Errorf("failed to set availability: %w", err)
		}

		result = append(result, &model.AvailabilitySlot{
			ID:          uuidToString(avail.ID),
			DayOfWeek:   int(avail.DayOfWeek),
			StartTime:   timeToString(avail.StartTime),
			EndTime:     timeToString(avail.EndTime),
			IsAvailable: boolVal(avail.IsAvailable),
		})
	}

	return result, nil
}

// UpdateCleanerProfile is the resolver for the updateCleanerProfile field.
func (r *mutationResolver) UpdateCleanerProfile(ctx context.Context, input model.UpdateCleanerProfileInput) (*model.CleanerProfile, error) {
	claims := auth.GetUserFromContext(ctx)
	if claims == nil {
		return nil, fmt.Errorf("not authenticated")
	}

	cleaner, err := r.Queries.GetCleanerByUserID(ctx, stringToUUID(claims.UserID))
	if err != nil {
		return nil, fmt.Errorf("cleaner profile not found: %w", err)
	}

	var phone, bio string
	if input.Phone != nil {
		phone = *input.Phone
	} else {
		phone = cleaner.Phone.String
	}
	if input.Bio != nil {
		bio = *input.Bio
	} else {
		bio = cleaner.Bio.String
	}

	updated, err := r.Queries.UpdateCleanerOwnProfile(ctx, db.UpdateCleanerOwnProfileParams{
		ID:       cleaner.ID,
		NewPhone: phone,
		NewBio:   bio,
	})
	if err != nil {
		return nil, fmt.Errorf("failed to update cleaner profile: %w", err)
	}

	return r.cleanerWithCompany(ctx, updated)
}

// UploadCleanerAvatar is the resolver for the uploadCleanerAvatar field.
func (r *mutationResolver) UploadCleanerAvatar(ctx context.Context, cleanerID string, file graphql.Upload) (*model.CleanerProfile, error) {
	claims := auth.GetUserFromContext(ctx)
	if claims == nil {
		return nil, fmt.Errorf("not authenticated")
	}

	// Get cleaner record
	cleaner, err := r.Queries.GetCleanerByID(ctx, stringToUUID(cleanerID))
	if err != nil {
		return nil, fmt.Errorf("cleaner not found: %w", err)
	}

	// Authorization: user must be the cleaner OR company admin OR global admin
	isOwnProfile := cleaner.UserID.Valid && uuidToString(cleaner.UserID) == claims.UserID
	isCompanyAdmin := false
	if claims.Role == "company_admin" {
		company, err := r.Queries.GetCompanyByAdminUserID(ctx, stringToUUID(claims.UserID))
		if err == nil {
			isCompanyAdmin = company.ID == cleaner.CompanyID
		}
	}

	if !isOwnProfile && !isCompanyAdmin && claims.Role != "global_admin" {
		return nil, fmt.Errorf("not authorized")
	}

	// Validate file type (images only)
	if !isImageFile(file.Filename) {
		return nil, fmt.Errorf("doar imagini sunt permise (jpg, png, webp)")
	}

	// Validate file size (max 10MB)
	if file.Size > 10*1024*1024 {
		return nil, fmt.Errorf("fisierul depaseste limita de 10MB")
	}

	// Build GCS path: uploads/users/{userId}/avatars (avatar belongs to user, not cleaner)
	path := fmt.Sprintf("uploads/users/%s/avatars", uuidToString(cleaner.UserID))

	// Upload to GCS with public access
	avatarURL, err := r.Storage.Upload(ctx, path, file.Filename, file.File, storage.StorageTypePublic)
	if err != nil {
		return nil, fmt.Errorf("eroare la incarcarea imaginii: %w", err)
	}

	// Update USER's avatar (not cleaner's) - avatar is a user-level attribute
	_, err = r.Queries.UpdateUserAvatar(ctx, db.UpdateUserAvatarParams{
		ID:        stringToUUID(uuidToString(cleaner.UserID)),
		AvatarUrl: stringToText(&avatarURL),
	})
	if err != nil {
		return nil, fmt.Errorf("failed to update avatar: %w", err)
	}

	// Refetch cleaner to return updated profile
	updated, err := r.Queries.GetCleanerByID(ctx, stringToUUID(cleanerID))
	if err != nil {
		return nil, fmt.Errorf("failed to refetch cleaner: %w", err)
	}

	return r.cleanerWithCompany(ctx, updated)
}

// SetCleanerDateOverride is the resolver for the setCleanerDateOverride field.
func (r *mutationResolver) SetCleanerDateOverride(ctx context.Context, date string, isAvailable bool, startTime string, endTime string) (*model.CleanerDateOverride, error) {
	claims := auth.GetUserFromContext(ctx)
	if claims == nil {
		return nil, fmt.Errorf("not authenticated")
	}

	cleaner, err := r.Queries.GetCleanerByUserID(ctx, stringToUUID(claims.UserID))
	if err != nil {
		return nil, fmt.Errorf("cleaner profile not found: %w", err)
	}

	parsedDate, err := time.Parse("2006-01-02", date)
	if err != nil {
		return nil, fmt.Errorf("invalid date format: %w", err)
	}

	row, err := r.Queries.UpsertCleanerDateOverride(ctx, db.UpsertCleanerDateOverrideParams{
		CleanerID:    cleaner.ID,
		OverrideDate: pgtype.Date{Time: parsedDate, Valid: true},
		IsAvailable:  isAvailable,
		StartTime:    parseHHMMToTime(startTime),
		EndTime:      parseHHMMToTime(endTime),
	})
	if err != nil {
		return nil, fmt.Errorf("failed to set date override: %w", err)
	}

	return &model.CleanerDateOverride{
		ID:          uuidToString(row.ID),
		Date:        dateToString(row.OverrideDate),
		IsAvailable: row.IsAvailable,
		StartTime:   timeToString(row.StartTime),
		EndTime:     timeToString(row.EndTime),
	}, nil
}

// SetCleanerDateOverrideByAdmin is the resolver for the setCleanerDateOverrideByAdmin field.
func (r *mutationResolver) SetCleanerDateOverrideByAdmin(ctx context.Context, cleanerID string, date string, isAvailable bool, startTime string, endTime string) (*model.CleanerDateOverride, error) {
	claims := auth.GetUserFromContext(ctx)
	if claims == nil {
		return nil, fmt.Errorf("not authenticated")
	}

	// Verify the caller is a company admin.
	company, err := r.Queries.GetCompanyByAdminUserID(ctx, stringToUUID(claims.UserID))
	if err != nil {
		return nil, fmt.Errorf("company not found for user: %w", err)
	}

	// Verify the cleaner belongs to the admin's company.
	cleaner, err := r.Queries.GetCleanerByID(ctx, stringToUUID(cleanerID))
	if err != nil {
		return nil, fmt.Errorf("cleaner not found: %w", err)
	}

	if cleaner.CompanyID != company.ID {
		return nil, fmt.Errorf("cleaner does not belong to your company")
	}

	parsedDate, err := time.Parse("2006-01-02", date)
	if err != nil {
		return nil, fmt.Errorf("invalid date format: %w", err)
	}

	row, err := r.Queries.UpsertCleanerDateOverride(ctx, db.UpsertCleanerDateOverrideParams{
		CleanerID:    cleaner.ID,
		OverrideDate: pgtype.Date{Time: parsedDate, Valid: true},
		IsAvailable:  isAvailable,
		StartTime:    parseHHMMToTime(startTime),
		EndTime:      parseHHMMToTime(endTime),
	})
	if err != nil {
		return nil, fmt.Errorf("failed to set date override: %w", err)
	}

	return &model.CleanerDateOverride{
		ID:          uuidToString(row.ID),
		Date:        dateToString(row.OverrideDate),
		IsAvailable: row.IsAvailable,
		StartTime:   timeToString(row.StartTime),
		EndTime:     timeToString(row.EndTime),
	}, nil
}

// UploadCleanerDocument is the resolver for the uploadCleanerDocument field.
func (r *mutationResolver) UploadCleanerDocument(ctx context.Context, cleanerID string, documentType string, file graphql.Upload) (*model.CleanerDocument, error) {
	claims := auth.GetUserFromContext(ctx)
	if claims == nil {
		return nil, fmt.Errorf("not authenticated")
	}

	// Get the cleaner record
	cleaner, err := r.Queries.GetCleanerByID(ctx, stringToUUID(cleanerID))
	if err != nil {
		return nil, fmt.Errorf("cleaner not found: %w", err)
	}

	// Authorization: Either the cleaner's own user OR the company admin OR global admin
	isOwnCleaner := cleaner.UserID.Valid && uuidToString(cleaner.UserID) == claims.UserID

	var isCompanyAdmin bool
	if !isOwnCleaner {
		// Check if user is company admin for this cleaner's company
		company, err := r.Queries.GetCompanyByAdminUserID(ctx, stringToUUID(claims.UserID))
		if err == nil && uuidToString(company.ID) == uuidToString(cleaner.CompanyID) {
			isCompanyAdmin = true
		}
	}

	if !isOwnCleaner && !isCompanyAdmin && claims.Role != "global_admin" {
		return nil, fmt.Errorf("not authorized to upload documents for this cleaner")
	}

	path := fmt.Sprintf("uploads/cleaners/%s/documents", cleanerID)
	fileURL, err := r.Storage.Upload(ctx, path, file.Filename, file.File, storage.StorageTypePrivate)
	if err != nil {
		return nil, fmt.Errorf("failed to upload file: %w", err)
	}

	doc, err := r.Queries.CreateCleanerDocument(ctx, db.CreateCleanerDocumentParams{
		CleanerID:    stringToUUID(cleanerID),
		DocumentType: documentType,
		FileUrl:      fileURL,
		FileName:     file.Filename,
	})
	if err != nil {
		return nil, fmt.Errorf("failed to save cleaner document: %w", err)
	}

	return dbCleanerDocToGQL(doc), nil
}

// DeleteCleanerDocument is the resolver for the deleteCleanerDocument field.
func (r *mutationResolver) DeleteCleanerDocument(ctx context.Context, id string) (bool, error) {
	claims := auth.GetUserFromContext(ctx)
	if claims == nil {
		return false, fmt.Errorf("not authenticated")
	}

	if err := r.Queries.DeleteCleanerDocument(ctx, stringToUUID(id)); err != nil {
		return false, fmt.Errorf("failed to delete document: %w", err)
	}
	return true, nil
}

// ReviewCleanerDocument is the resolver for the reviewCleanerDocument field.
func (r *mutationResolver) ReviewCleanerDocument(ctx context.Context, id string, approved bool, rejectionReason *string) (*model.CleanerDocument, error) {
	claims := auth.GetUserFromContext(ctx)
	if claims == nil || claims.Role != "global_admin" {
		return nil, fmt.Errorf("not authorized")
	}

	status := "approved"
	if !approved {
		status = "rejected"
	}

	var reason pgtype.Text
	if rejectionReason != nil {
		reason = pgtype.Text{String: *rejectionReason, Valid: true}
	}

	doc, err := r.Queries.UpdateCleanerDocumentStatus(ctx, db.UpdateCleanerDocumentStatusParams{
		ID:              stringToUUID(id),
		Status:          status,
		ReviewedBy:      stringToUUID(claims.UserID),
		RejectionReason: reason,
	})
	if err != nil {
		return nil, fmt.Errorf("failed to review document: %w", err)
	}

	return dbCleanerDocToGQL(doc), nil
}

// ActivateCleaner is the resolver for the activateCleaner field.
func (r *mutationResolver) ActivateCleaner(ctx context.Context, id string) (*model.CleanerProfile, error) {
	claims := auth.GetUserFromContext(ctx)
	if claims == nil || claims.Role != "global_admin" {
		return nil, fmt.Errorf("not authorized")
	}

	// Require personality assessment before activation.
	cleanerUUID := stringToUUID(id)
	has, err := r.Queries.HasPersonalityAssessment(ctx, cleanerUUID)
	if err != nil {
		return nil, fmt.Errorf("failed to check personality assessment: %w", err)
	}
	if !has {
		return nil, fmt.Errorf("cleaner must complete personality assessment before activation")
	}

	cleaner, err := r.Queries.ActivateCleanerStatus(ctx, cleanerUUID)
	if err != nil {
		return nil, fmt.Errorf("failed to activate cleaner: %w", err)
	}

	return r.cleanerWithCompany(ctx, cleaner)
}

// MyCleaners is the resolver for the myCleaners field.
func (r *queryResolver) MyCleaners(ctx context.Context) ([]*model.CleanerProfile, error) {
	claims := auth.GetUserFromContext(ctx)
	if claims == nil {
		return nil, fmt.Errorf("not authenticated")
	}

	company, err := r.Queries.GetCompanyByAdminUserID(ctx, stringToUUID(claims.UserID))
	if err != nil {
		return nil, fmt.Errorf("company not found for user. please register your company first: %w", err)
	}

	cleaners, err := r.Queries.ListCleanersByCompany(ctx, company.ID)
	if err != nil {
		return nil, fmt.Errorf("failed to list cleaners: %w", err)
	}

	result := make([]*model.CleanerProfile, len(cleaners))
	for i, c := range cleaners {
		// Load full cleaner profile with User/Company/Documents/PersonalityAssessment relationships
		profile, err := r.cleanerWithCompany(ctx, c)
		if err != nil {
			return nil, fmt.Errorf("failed to load cleaner %s: %w", uuidToString(c.ID), err)
		}

		// Load availability for each cleaner.
		avails, err := r.Queries.ListCleanerAvailability(ctx, c.ID)
		if err == nil {
			slots := make([]*model.AvailabilitySlot, len(avails))
			for j, a := range avails {
				slots[j] = &model.AvailabilitySlot{
					ID:          uuidToString(a.ID),
					DayOfWeek:   int(a.DayOfWeek),
					StartTime:   timeToString(a.StartTime),
					EndTime:     timeToString(a.EndTime),
					IsAvailable: boolVal(a.IsAvailable),
				}
			}
			profile.Availability = slots
		}

		result[i] = profile
	}

	return result, nil
}

// MyCleanerProfile is the resolver for the myCleanerProfile field.
func (r *queryResolver) MyCleanerProfile(ctx context.Context) (*model.CleanerProfile, error) {
	claims := auth.GetUserFromContext(ctx)
	if claims == nil {
		return nil, fmt.Errorf("not authenticated")
	}

	cleaner, err := r.Queries.GetCleanerByUserID(ctx, stringToUUID(claims.UserID))
	if err != nil {
		return nil, fmt.Errorf("cleaner profile not found: %w", err)
	}

	return r.cleanerWithCompany(ctx, cleaner)
}

// MyCleanerStats is the resolver for the myCleanerStats field.
func (r *queryResolver) MyCleanerStats(ctx context.Context) (*model.CleanerStats, error) {
	claims := auth.GetUserFromContext(ctx)
	if claims == nil {
		return nil, fmt.Errorf("not authenticated")
	}

	cleaner, err := r.Queries.GetCleanerByUserID(ctx, stringToUUID(claims.UserID))
	if err != nil {
		return nil, fmt.Errorf("cleaner profile not found: %w", err)
	}

	avgRating, err := r.Queries.GetAverageCleanerRating(ctx, cleaner.ID)
	if err != nil {
		return nil, fmt.Errorf("failed to get average rating: %w", err)
	}

	reviews, err := r.Queries.ListReviewsByCleanerID(ctx, db.ListReviewsByCleanerIDParams{
		ReviewedCleanerID: cleaner.ID,
		Limit:             1000,
		Offset:            0,
	})
	if err != nil {
		return nil, fmt.Errorf("failed to list reviews: %w", err)
	}

	completedCount, err := r.Queries.CountCompletedJobsByCleaner(ctx, cleaner.ID)
	if err != nil {
		return nil, fmt.Errorf("failed to count completed jobs: %w", err)
	}

	thisMonthJobs, err := r.Queries.CountThisMonthJobsByCleaner(ctx, cleaner.ID)
	if err != nil {
		return nil, fmt.Errorf("failed to count this month jobs: %w", err)
	}

	thisMonthEarnings, err := r.Queries.SumThisMonthEarningsByCleaner(ctx, cleaner.ID)
	if err != nil {
		return nil, fmt.Errorf("failed to sum this month earnings: %w", err)
	}

	return &model.CleanerStats{
		TotalJobsCompleted: int(completedCount),
		AverageRating:      numericToFloat(avgRating),
		TotalReviews:       len(reviews),
		ThisMonthJobs:      int(thisMonthJobs),
		ThisMonthEarnings:  numericToFloat(thisMonthEarnings),
	}, nil
}

// CleanerPerformance is the resolver for the cleanerPerformance field.
func (r *queryResolver) CleanerPerformance(ctx context.Context, cleanerID string) (*model.CleanerPerformance, error) {
	claims := auth.GetUserFromContext(ctx)
	if claims == nil {
		return nil, fmt.Errorf("not authenticated")
	}

	stats, err := r.Queries.GetCleanerPerformanceStats(ctx, stringToUUID(cleanerID))
	if err != nil {
		return nil, fmt.Errorf("failed to get cleaner performance: %w", err)
	}

	return &model.CleanerPerformance{
		CleanerID:          cleanerID,
		FullName:           stats.FullName,
		RatingAvg:          numericToFloat(stats.RatingAvg),
		TotalCompletedJobs: int(stats.TotalCompletedJobs),
		ThisMonthCompleted: int(stats.ThisMonthCompleted),
		TotalEarnings:      numericToFloat(stats.TotalEarnings),
		ThisMonthEarnings:  numericToFloat(stats.ThisMonthEarnings),
	}, nil
}

// MyCleanerAvailability is the resolver for the myCleanerAvailability field.
func (r *queryResolver) MyCleanerAvailability(ctx context.Context) ([]*model.AvailabilitySlot, error) {
	claims := auth.GetUserFromContext(ctx)
	if claims == nil {
		return nil, fmt.Errorf("not authenticated")
	}

	cleaner, err := r.Queries.GetCleanerByUserID(ctx, stringToUUID(claims.UserID))
	if err != nil {
		return nil, fmt.Errorf("cleaner profile not found: %w", err)
	}

	avails, err := r.Queries.ListCleanerAvailability(ctx, cleaner.ID)
	if err != nil {
		return nil, fmt.Errorf("failed to list availability: %w", err)
	}

	result := make([]*model.AvailabilitySlot, len(avails))
	for i, a := range avails {
		result[i] = &model.AvailabilitySlot{
			ID:          uuidToString(a.ID),
			DayOfWeek:   int(a.DayOfWeek),
			StartTime:   timeToString(a.StartTime),
			EndTime:     timeToString(a.EndTime),
			IsAvailable: boolVal(a.IsAvailable),
		}
	}
	return result, nil
}

// MyCleanerBookingsByDateRange is the resolver for the myCleanerBookingsByDateRange field.
func (r *queryResolver) MyCleanerBookingsByDateRange(ctx context.Context, from string, to string) ([]*model.Booking, error) {
	claims := auth.GetUserFromContext(ctx)
	if claims == nil {
		return nil, fmt.Errorf("not authenticated")
	}

	cleaner, err := r.Queries.GetCleanerByUserID(ctx, stringToUUID(claims.UserID))
	if err != nil {
		return nil, fmt.Errorf("cleaner profile not found: %w", err)
	}

	fromDate, err := time.Parse("2006-01-02", from)
	if err != nil {
		return nil, fmt.Errorf("invalid 'from' date: %w", err)
	}
	toDate, err := time.Parse("2006-01-02", to)
	if err != nil {
		return nil, fmt.Errorf("invalid 'to' date: %w", err)
	}

	bookings, err := r.Queries.ListBookingsByCleanerAndDateRange(ctx, db.ListBookingsByCleanerAndDateRangeParams{
		CleanerID: cleaner.ID,
		DateFrom:  pgtype.Date{Time: fromDate, Valid: true},
		DateTo:    pgtype.Date{Time: toDate, Valid: true},
	})
	if err != nil {
		return nil, fmt.Errorf("failed to list bookings: %w", err)
	}

	result := make([]*model.Booking, len(bookings))
	for i, b := range bookings {
		gqlBooking := dbBookingToGQL(b)
		r.enrichBooking(ctx, b, gqlBooking)
		result[i] = gqlBooking
	}
	return result, nil
}

// CleanerEarningsByDateRange is the resolver for the cleanerEarningsByDateRange field.
func (r *queryResolver) CleanerEarningsByDateRange(ctx context.Context, from string, to string) ([]*model.CleanerDailyEarnings, error) {
	claims := auth.GetUserFromContext(ctx)
	if claims == nil {
		return nil, fmt.Errorf("not authenticated")
	}

	cleaner, err := r.Queries.GetCleanerByUserID(ctx, stringToUUID(claims.UserID))
	if err != nil {
		return nil, fmt.Errorf("cleaner profile not found: %w", err)
	}

	fromDate, err := time.Parse("2006-01-02", from)
	if err != nil {
		return nil, fmt.Errorf("invalid 'from' date: %w", err)
	}
	toDate, err := time.Parse("2006-01-02", to)
	if err != nil {
		return nil, fmt.Errorf("invalid 'to' date: %w", err)
	}

	rows, err := r.Queries.GetCleanerEarningsByDateRange(ctx, db.GetCleanerEarningsByDateRangeParams{
		CleanerID:     cleaner.ID,
		CompletedAt:   pgtype.Timestamptz{Time: fromDate, Valid: true},
		CompletedAt_2: pgtype.Timestamptz{Time: toDate.Add(24 * time.Hour), Valid: true},
	})
	if err != nil {
		return nil, fmt.Errorf("failed to get earnings: %w", err)
	}

	result := make([]*model.CleanerDailyEarnings, len(rows))
	for i, row := range rows {
		result[i] = &model.CleanerDailyEarnings{
			Date:   row.Date.Time.Format("2006-01-02"),
			Amount: numericToFloat(row.Amount),
		}
	}
	return result, nil
}

// SearchCleanerBookings is the resolver for the searchCleanerBookings field.
func (r *queryResolver) SearchCleanerBookings(ctx context.Context, query *string, status *string, dateFrom *string, dateTo *string, limit *int, offset *int) (*model.BookingConnection, error) {
	claims := auth.GetUserFromContext(ctx)
	if claims == nil {
		return nil, fmt.Errorf("not authenticated")
	}

	cleaner, err := r.Queries.GetCleanerByUserID(ctx, stringToUUID(claims.UserID))
	if err != nil {
		return nil, fmt.Errorf("cleaner profile not found: %w", err)
	}

	qLimit := int32(20)
	if limit != nil {
		qLimit = int32(*limit)
	}
	qOffset := int32(0)
	if offset != nil {
		qOffset = int32(*offset)
	}

	var queryStr string
	if query != nil {
		queryStr = *query
	}
	var statusStr string
	if status != nil {
		statusStr = strings.ToLower(*status)
	}

	zeroDate := pgtype.Date{Time: time.Date(1, 1, 1, 0, 0, 0, 0, time.UTC), Valid: true}
	fromDate := zeroDate
	toDate := zeroDate
	if dateFrom != nil {
		if t, err := time.Parse("2006-01-02", *dateFrom); err == nil {
			fromDate = pgtype.Date{Time: t, Valid: true}
		}
	}
	if dateTo != nil {
		if t, err := time.Parse("2006-01-02", *dateTo); err == nil {
			toDate = pgtype.Date{Time: t, Valid: true}
		}
	}

	bookings, err := r.Queries.SearchCleanerBookings(ctx, db.SearchCleanerBookingsParams{
		CleanerID:    cleaner.ID,
		Limit:        qLimit + 1,
		Offset:       qOffset,
		Query:        queryStr,
		StatusFilter: statusStr,
		DateFrom:     fromDate,
		DateTo:       toDate,
	})
	if err != nil {
		return nil, fmt.Errorf("failed to search cleaner bookings: %w", err)
	}

	hasNext := len(bookings) > int(qLimit)
	if hasNext {
		bookings = bookings[:qLimit]
	}

	edges := make([]*model.Booking, len(bookings))
	for i, b := range bookings {
		gqlBooking := dbBookingToGQL(b)
		r.enrichBooking(ctx, b, gqlBooking)
		edges[i] = gqlBooking
	}

	total, _ := r.Queries.CountSearchCleanerBookings(ctx, db.CountSearchCleanerBookingsParams{
		CleanerID:    cleaner.ID,
		Query:        queryStr,
		StatusFilter: statusStr,
		DateFrom:     fromDate,
		DateTo:       toDate,
	})

	return &model.BookingConnection{
		Edges: edges,
		PageInfo: &model.PageInfo{
			HasNextPage: hasNext,
		},
		TotalCount: int(total),
	}, nil
}

// MyCleanerReviews is the resolver for the myCleanerReviews field.
func (r *queryResolver) MyCleanerReviews(ctx context.Context, limit *int, offset *int) (*model.ReviewConnection, error) {
	claims := auth.GetUserFromContext(ctx)
	if claims == nil {
		return nil, fmt.Errorf("not authenticated")
	}

	cleaner, err := r.Queries.GetCleanerByUserID(ctx, stringToUUID(claims.UserID))
	if err != nil {
		return nil, fmt.Errorf("cleaner profile not found: %w", err)
	}

	l := int32(20)
	if limit != nil {
		l = int32(*limit)
	}
	o := int32(0)
	if offset != nil {
		o = int32(*offset)
	}

	dbReviews, err := r.Queries.ListReviewsByCleanerID(ctx, db.ListReviewsByCleanerIDParams{
		ReviewedCleanerID: cleaner.ID,
		Limit:             l,
		Offset:            o,
	})
	if err != nil {
		return nil, fmt.Errorf("failed to list reviews: %w", err)
	}

	count, err := r.Queries.CountReviewsByCleanerID(ctx, cleaner.ID)
	if err != nil {
		return nil, fmt.Errorf("failed to count reviews: %w", err)
	}

	reviews := make([]*model.Review, len(dbReviews))
	for i, rv := range dbReviews {
		review := dbReviewToGQL(rv)
		if booking, bErr := r.Queries.GetBookingByID(ctx, rv.BookingID); bErr == nil {
			review.Booking = dbBookingToGQL(booking)
		}
		if rv.ReviewerUserID.Valid {
			if user, uErr := r.Queries.GetUserByID(ctx, rv.ReviewerUserID); uErr == nil {
				review.Reviewer = dbUserToGQL(user)
			}
		}
		reviews[i] = review
	}

	return &model.ReviewConnection{
		Reviews:    reviews,
		TotalCount: int(count),
	}, nil
}

// MyCleanerCompanySchedule is the resolver for the myCleanerCompanySchedule field.
func (r *queryResolver) MyCleanerCompanySchedule(ctx context.Context) ([]*model.CompanyWorkSchedule, error) {
	claims := auth.GetUserFromContext(ctx)
	if claims == nil {
		return nil, fmt.Errorf("not authenticated")
	}

	cleaner, err := r.Queries.GetCleanerByUserID(ctx, stringToUUID(claims.UserID))
	if err != nil {
		return nil, fmt.Errorf("cleaner profile not found: %w", err)
	}

	rows, err := r.Queries.ListCompanyWorkSchedule(ctx, cleaner.CompanyID)
	if err != nil {
		return nil, fmt.Errorf("failed to list company work schedule: %w", err)
	}

	result := make([]*model.CompanyWorkSchedule, len(rows))
	for i, row := range rows {
		result[i] = &model.CompanyWorkSchedule{
			ID:        uuidToString(row.ID),
			DayOfWeek: int(row.DayOfWeek),
			StartTime: timeToString(row.StartTime),
			EndTime:   timeToString(row.EndTime),
			IsWorkDay: row.IsWorkDay,
		}
	}
	return result, nil
}

// MyCleanerDateOverrides is the resolver for the myCleanerDateOverrides field.
func (r *queryResolver) MyCleanerDateOverrides(ctx context.Context, from string, to string) ([]*model.CleanerDateOverride, error) {
	claims := auth.GetUserFromContext(ctx)
	if claims == nil {
		return nil, fmt.Errorf("not authenticated")
	}

	cleaner, err := r.Queries.GetCleanerByUserID(ctx, stringToUUID(claims.UserID))
	if err != nil {
		return nil, fmt.Errorf("cleaner profile not found: %w", err)
	}

	fromDate, err := time.Parse("2006-01-02", from)
	if err != nil {
		return nil, fmt.Errorf("invalid from date: %w", err)
	}
	toDate, err := time.Parse("2006-01-02", to)
	if err != nil {
		return nil, fmt.Errorf("invalid to date: %w", err)
	}

	rows, err := r.Queries.ListCleanerDateOverrides(ctx, db.ListCleanerDateOverridesParams{
		CleanerID:      cleaner.ID,
		OverrideDate:   pgtype.Date{Time: fromDate, Valid: true},
		OverrideDate_2: pgtype.Date{Time: toDate, Valid: true},
	})
	if err != nil {
		return nil, fmt.Errorf("failed to list date overrides: %w", err)
	}

	result := make([]*model.CleanerDateOverride, len(rows))
	for i, row := range rows {
		result[i] = &model.CleanerDateOverride{
			ID:          uuidToString(row.ID),
			Date:        dateToString(row.OverrideDate),
			IsAvailable: row.IsAvailable,
			StartTime:   timeToString(row.StartTime),
			EndTime:     timeToString(row.EndTime),
		}
	}
	return result, nil
}

// CleanerDateOverrides is the resolver for the cleanerDateOverrides field.
func (r *queryResolver) CleanerDateOverrides(ctx context.Context, cleanerID string, from string, to string) ([]*model.CleanerDateOverride, error) {
	claims := auth.GetUserFromContext(ctx)
	if claims == nil {
		return nil, fmt.Errorf("not authenticated")
	}

	// Verify the caller is a company admin.
	company, err := r.Queries.GetCompanyByAdminUserID(ctx, stringToUUID(claims.UserID))
	if err != nil {
		return nil, fmt.Errorf("company not found for user: %w", err)
	}

	// Verify the cleaner belongs to the admin's company.
	cleaner, err := r.Queries.GetCleanerByID(ctx, stringToUUID(cleanerID))
	if err != nil {
		return nil, fmt.Errorf("cleaner not found: %w", err)
	}

	if cleaner.CompanyID != company.ID {
		return nil, fmt.Errorf("cleaner does not belong to your company")
	}

	fromDate, err := time.Parse("2006-01-02", from)
	if err != nil {
		return nil, fmt.Errorf("invalid from date: %w", err)
	}
	toDate, err := time.Parse("2006-01-02", to)
	if err != nil {
		return nil, fmt.Errorf("invalid to date: %w", err)
	}

	rows, err := r.Queries.ListCleanerDateOverrides(ctx, db.ListCleanerDateOverridesParams{
		CleanerID:      cleaner.ID,
		OverrideDate:   pgtype.Date{Time: fromDate, Valid: true},
		OverrideDate_2: pgtype.Date{Time: toDate, Valid: true},
	})
	if err != nil {
		return nil, fmt.Errorf("failed to list date overrides: %w", err)
	}

	result := make([]*model.CleanerDateOverride, len(rows))
	for i, row := range rows {
		result[i] = &model.CleanerDateOverride{
			ID:          uuidToString(row.ID),
			Date:        dateToString(row.OverrideDate),
			IsAvailable: row.IsAvailable,
			StartTime:   timeToString(row.StartTime),
			EndTime:     timeToString(row.EndTime),
		}
	}
	return result, nil
}

// CleanerDocuments is the resolver for the cleanerDocuments field.
func (r *queryResolver) CleanerDocuments(ctx context.Context, cleanerID string) ([]*model.CleanerDocument, error) {
	docs, err := r.Queries.ListCleanerDocuments(ctx, stringToUUID(cleanerID))
	if err != nil {
		return nil, fmt.Errorf("failed to list cleaner documents: %w", err)
	}

	result := make([]*model.CleanerDocument, len(docs))
	for i, d := range docs {
		result[i] = dbCleanerDocToGQL(d)
	}
	return result, nil
}

// PendingCleanerDocuments is the resolver for the pendingCleanerDocuments field.
func (r *queryResolver) PendingCleanerDocuments(ctx context.Context) ([]*model.CleanerDocument, error) {
	claims := auth.GetUserFromContext(ctx)
	if claims == nil || claims.Role != "global_admin" {
		return nil, fmt.Errorf("not authorized")
	}

	docs, err := r.Queries.ListPendingCleanerDocuments(ctx)
	if err != nil {
		return nil, fmt.Errorf("failed to list pending cleaner documents: %w", err)
	}

	result := make([]*model.CleanerDocument, len(docs))
	for i, d := range docs {
		result[i] = dbCleanerDocToGQL(d)
	}
	return result, nil
}
