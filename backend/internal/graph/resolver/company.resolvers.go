package resolver

// This file will be automatically regenerated based on the schema, any resolver
// implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.86

import (
	"context"
	"crypto/rand"
	"encoding/hex"
	"fmt"
	"helpmeclean-backend/internal/auth"
	db "helpmeclean-backend/internal/db/generated"
	"helpmeclean-backend/internal/graph/model"

	"github.com/99designs/gqlgen/graphql"
	"github.com/jackc/pgx/v5/pgtype"
)

// ApplyAsCompany is the resolver for the applyAsCompany field.
func (r *mutationResolver) ApplyAsCompany(ctx context.Context, input model.CompanyApplicationInput) (*model.CompanyApplicationResult, error) {
	// Allow unauthenticated applications; link to user if authenticated.
	var adminUserID pgtype.UUID
	var claimTokenText pgtype.Text

	claims := auth.GetUserFromContext(ctx)
	if claims != nil {
		adminUserID = stringToUUID(claims.UserID)
	} else {
		// Generate a claim token for unauthenticated applications so the user
		// can link their account later.
		tokenBytes := make([]byte, 32)
		if _, err := rand.Read(tokenBytes); err != nil {
			return nil, fmt.Errorf("failed to generate claim token: %w", err)
		}
		claimTokenText = pgtype.Text{String: hex.EncodeToString(tokenBytes), Valid: true}
	}

	company, err := r.Queries.CreateCompany(ctx, db.CreateCompanyParams{
		AdminUserID:         adminUserID,
		CompanyName:         input.CompanyName,
		Cui:                 input.Cui,
		CompanyType:         gqlCompanyTypeToDb(input.CompanyType),
		LegalRepresentative: input.LegalRepresentative,
		ContactEmail:        input.ContactEmail,
		ContactPhone:        input.ContactPhone,
		Address:             input.Address,
		City:                input.City,
		County:              input.County,
		Description:         stringToText(input.Description),
		ClaimToken:          claimTokenText,
	})
	if err != nil {
		return nil, fmt.Errorf("failed to create company application: %w", err)
	}

	result := &model.CompanyApplicationResult{
		Company: dbCompanyToGQL(company),
	}
	if claimTokenText.Valid {
		result.ClaimToken = &claimTokenText.String
	}
	return result, nil
}

// ClaimCompany is the resolver for the claimCompany field.
func (r *mutationResolver) ClaimCompany(ctx context.Context, claimToken string) (*model.Company, error) {
	claims := auth.GetUserFromContext(ctx)
	if claims == nil {
		return nil, fmt.Errorf("not authenticated")
	}

	company, err := r.Queries.ClaimCompanyByToken(ctx, db.ClaimCompanyByTokenParams{
		AdminUserID: stringToUUID(claims.UserID),
		ClaimToken:  pgtype.Text{String: claimToken, Valid: true},
	})
	if err != nil {
		return nil, fmt.Errorf("invalid or already claimed token: %w", err)
	}

	return dbCompanyToGQL(company), nil
}

// UpdateCompanyProfile is the resolver for the updateCompanyProfile field.
func (r *mutationResolver) UpdateCompanyProfile(ctx context.Context, input model.UpdateCompanyInput) (*model.Company, error) {
	claims := auth.GetUserFromContext(ctx)
	if claims == nil {
		return nil, fmt.Errorf("not authenticated")
	}

	// Get the company for this admin user.
	company, err := r.Queries.GetCompanyByAdminUserID(ctx, stringToUUID(claims.UserID))
	if err != nil {
		return nil, fmt.Errorf("company not found for user: %w", err)
	}

	// For MVP, we use UpdateCompanyStatus as a way to touch the record.
	// Since there is no dedicated UpdateCompany query, we return the existing
	// company data. In a full implementation, a dedicated SQL query would be added.
	_ = input
	return dbCompanyToGQL(company), nil
}

// UploadCompanyDocument is the resolver for the uploadCompanyDocument field.
func (r *mutationResolver) UploadCompanyDocument(ctx context.Context, companyID string, documentType string, file graphql.Upload) (*model.CompanyDocument, error) {
	claims := auth.GetUserFromContext(ctx)
	if claims == nil {
		return nil, fmt.Errorf("not authenticated")
	}

	// For MVP, store with a placeholder URL.
	placeholderURL := fmt.Sprintf("https://storage.helpmeclean.ro/documents/%s/%s", companyID, file.Filename)

	doc, err := r.Queries.CreateCompanyDocument(ctx, db.CreateCompanyDocumentParams{
		CompanyID:    stringToUUID(companyID),
		DocumentType: documentType,
		FileUrl:      placeholderURL,
		FileName:     file.Filename,
	})
	if err != nil {
		return nil, fmt.Errorf("failed to upload company document: %w", err)
	}

	return dbCompanyDocToGQL(doc), nil
}

// ApproveCompany is the resolver for the approveCompany field.
func (r *mutationResolver) ApproveCompany(ctx context.Context, id string) (*model.Company, error) {
	claims := auth.GetUserFromContext(ctx)
	if claims == nil {
		return nil, fmt.Errorf("not authenticated")
	}

	company, err := r.Queries.ApproveCompany(ctx, stringToUUID(id))
	if err != nil {
		return nil, fmt.Errorf("failed to approve company: %w", err)
	}

	return dbCompanyToGQL(company), nil
}

// RejectCompany is the resolver for the rejectCompany field.
func (r *mutationResolver) RejectCompany(ctx context.Context, id string, reason string) (*model.Company, error) {
	claims := auth.GetUserFromContext(ctx)
	if claims == nil {
		return nil, fmt.Errorf("not authenticated")
	}

	company, err := r.Queries.RejectCompany(ctx, db.RejectCompanyParams{
		ID:              stringToUUID(id),
		RejectionReason: stringToTextVal(reason),
	})
	if err != nil {
		return nil, fmt.Errorf("failed to reject company: %w", err)
	}

	return dbCompanyToGQL(company), nil
}

// SuspendCompany is the resolver for the suspendCompany field.
func (r *mutationResolver) SuspendCompany(ctx context.Context, id string, reason string) (*model.Company, error) {
	claims := auth.GetUserFromContext(ctx)
	if claims == nil {
		return nil, fmt.Errorf("not authenticated")
	}

	company, err := r.Queries.UpdateCompanyStatus(ctx, db.UpdateCompanyStatusParams{
		ID:     stringToUUID(id),
		Status: db.CompanyStatusSuspended,
	})
	if err != nil {
		return nil, fmt.Errorf("failed to suspend company: %w", err)
	}

	return dbCompanyToGQL(company), nil
}

// MyCompany is the resolver for the myCompany field.
func (r *queryResolver) MyCompany(ctx context.Context) (*model.Company, error) {
	claims := auth.GetUserFromContext(ctx)
	if claims == nil {
		return nil, fmt.Errorf("not authenticated")
	}

	// Try finding company already linked to this user.
	company, err := r.Queries.GetCompanyByAdminUserID(ctx, stringToUUID(claims.UserID))
	if err == nil {
		return dbCompanyToGQL(company), nil
	}

	// Auto-claim: find unclaimed company matching the user's email.
	company, err = r.Queries.GetUnclaimedCompanyByContactEmail(ctx, claims.Email)
	if err != nil {
		return nil, fmt.Errorf("company not found: %w", err)
	}

	// Link the company to this user.
	company, err = r.Queries.SetCompanyAdminUser(ctx, db.SetCompanyAdminUserParams{
		AdminUserID: stringToUUID(claims.UserID),
		ID:          company.ID,
	})
	if err != nil {
		return nil, fmt.Errorf("failed to claim company: %w", err)
	}

	return dbCompanyToGQL(company), nil
}

// Companies is the resolver for the companies field.
func (r *queryResolver) Companies(ctx context.Context, status *model.CompanyStatus, first *int, after *string) (*model.CompanyConnection, error) {
	claims := auth.GetUserFromContext(ctx)
	if claims == nil {
		return nil, fmt.Errorf("not authenticated")
	}

	limit := int32(20)
	if first != nil {
		limit = int32(*first)
	}
	offset := int32(0)
	if after != nil {
		fmt.Sscanf(*after, "%d", &offset)
	}

	var companies []db.Company
	var err error

	if status != nil {
		companies, err = r.Queries.ListCompaniesByStatus(ctx, db.ListCompaniesByStatusParams{
			Status: gqlCompanyStatusToDb(*status),
			Limit:  limit + 1,
			Offset: offset,
		})
	} else {
		companies, err = r.Queries.ListAllCompanies(ctx, db.ListAllCompaniesParams{
			Limit:  limit + 1,
			Offset: offset,
		})
	}
	if err != nil {
		return nil, fmt.Errorf("failed to list companies: %w", err)
	}

	hasNext := len(companies) > int(limit)
	if hasNext {
		companies = companies[:limit]
	}

	edges := make([]*model.Company, len(companies))
	for i, c := range companies {
		edges[i] = dbCompanyToGQL(c)
	}

	var endCursor *string
	if len(companies) > 0 {
		c := fmt.Sprintf("%d", offset+limit)
		endCursor = &c
	}

	return &model.CompanyConnection{
		Edges: edges,
		PageInfo: &model.PageInfo{
			HasNextPage: hasNext,
			EndCursor:   endCursor,
		},
		TotalCount: len(edges),
	}, nil
}

// Company is the resolver for the company field.
func (r *queryResolver) Company(ctx context.Context, id string) (*model.Company, error) {
	claims := auth.GetUserFromContext(ctx)
	if claims == nil {
		return nil, fmt.Errorf("not authenticated")
	}

	company, err := r.Queries.GetCompanyByID(ctx, stringToUUID(id))
	if err != nil {
		return nil, fmt.Errorf("company not found: %w", err)
	}

	return dbCompanyToGQL(company), nil
}

// CompanyChatRooms is the resolver for the companyChatRooms field.
func (r *queryResolver) CompanyChatRooms(ctx context.Context) ([]*model.ChatRoom, error) {
	claims := auth.GetUserFromContext(ctx)
	if claims == nil {
		return nil, fmt.Errorf("not authenticated")
	}

	company, err := r.Queries.GetCompanyByAdminUserID(ctx, stringToUUID(claims.UserID))
	if err != nil {
		return nil, fmt.Errorf("company not found: %w", err)
	}

	rooms, err := r.Queries.ListChatRoomsByCompanyCleaners(ctx, company.ID)
	if err != nil {
		return nil, fmt.Errorf("failed to list company chat rooms: %w", err)
	}

	result := make([]*model.ChatRoom, len(rooms))
	for i, room := range rooms {
		gqlRoom := dbChatRoomToGQL(room)

		// Load participants.
		participants, err := r.Queries.ListChatParticipants(ctx, room.ID)
		if err == nil {
			var gqlParticipants []*model.ChatParticipant
			for _, p := range participants {
				user, err := r.Queries.GetUserByID(ctx, p.UserID)
				if err != nil {
					continue
				}
				gqlParticipants = append(gqlParticipants, &model.ChatParticipant{
					User:     dbUserToGQL(user),
					JoinedAt: timestamptzToTime(p.JoinedAt),
				})
			}
			gqlRoom.Participants = gqlParticipants
		}

		// Load last message.
		lastMsgRow, err := r.Queries.GetLastChatMessage(ctx, room.ID)
		if err == nil {
			lastMsg := dbChatMessageToGQL(lastMsgRow)
			sender, err := r.Queries.GetUserByID(ctx, lastMsgRow.SenderID)
			if err == nil {
				lastMsg.Sender = dbUserToGQL(sender)
			}
			gqlRoom.LastMessage = lastMsg
		}

		result[i] = gqlRoom
	}

	return result, nil
}
