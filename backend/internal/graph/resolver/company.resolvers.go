package resolver

// This file will be automatically regenerated based on the schema, any resolver
// implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.86

import (
	"context"
	"crypto/rand"
	"encoding/hex"
	"fmt"
	"helpmeclean-backend/internal/auth"
	db "helpmeclean-backend/internal/db/generated"
	"helpmeclean-backend/internal/graph/model"
	"helpmeclean-backend/internal/storage"

	"github.com/99designs/gqlgen/graphql"
	"github.com/jackc/pgx/v5/pgtype"
)

// ApplyAsCompany is the resolver for the applyAsCompany field.
func (r *mutationResolver) ApplyAsCompany(ctx context.Context, input model.CompanyApplicationInput) (*model.CompanyApplicationResult, error) {
	// Allow unauthenticated applications; link to user if authenticated.
	var adminUserID pgtype.UUID
	var claimTokenText pgtype.Text

	claims := auth.GetUserFromContext(ctx)
	if claims != nil {
		adminUserID = stringToUUID(claims.UserID)
	} else {
		// Generate a claim token for unauthenticated applications so the user
		// can link their account later.
		tokenBytes := make([]byte, 32)
		if _, err := rand.Read(tokenBytes); err != nil {
			return nil, fmt.Errorf("failed to generate claim token: %w", err)
		}
		claimTokenText = pgtype.Text{String: hex.EncodeToString(tokenBytes), Valid: true}
	}

	company, err := r.Queries.CreateCompany(ctx, db.CreateCompanyParams{
		AdminUserID:         adminUserID,
		CompanyName:         input.CompanyName,
		Cui:                 input.Cui,
		CompanyType:         gqlCompanyTypeToDb(input.CompanyType),
		LegalRepresentative: input.LegalRepresentative,
		ContactEmail:        input.ContactEmail,
		ContactPhone:        input.ContactPhone,
		Address:             input.Address,
		City:                input.City,
		County:              input.County,
		Description:         stringToText(input.Description),
		ClaimToken:          claimTokenText,
	})
	if err != nil {
		return nil, fmt.Errorf("failed to create company application: %w", err)
	}

	// For authenticated users, upgrade their role to COMPANY_ADMIN immediately.
	// (Unauthenticated users get upgraded later via ClaimCompany.)
	if claims != nil {
		_, err = r.Queries.UpdateUserRole(ctx, db.UpdateUserRoleParams{
			ID:   stringToUUID(claims.UserID),
			Role: db.UserRoleCompanyAdmin,
		})
		if err != nil {
			return nil, fmt.Errorf("failed to upgrade user role: %w", err)
		}
	}

	result := &model.CompanyApplicationResult{
		Company: dbCompanyToGQL(company),
	}
	if claimTokenText.Valid {
		result.ClaimToken = &claimTokenText.String
	}
	return result, nil
}

// ClaimCompany is the resolver for the claimCompany field.
func (r *mutationResolver) ClaimCompany(ctx context.Context, claimToken string) (*model.Company, error) {
	claims := auth.GetUserFromContext(ctx)
	if claims == nil {
		return nil, fmt.Errorf("not authenticated")
	}

	company, err := r.Queries.ClaimCompanyByToken(ctx, db.ClaimCompanyByTokenParams{
		AdminUserID: stringToUUID(claims.UserID),
		ClaimToken:  pgtype.Text{String: claimToken, Valid: true},
	})
	if err != nil {
		return nil, fmt.Errorf("invalid or already claimed token: %w", err)
	}

	// Upgrade user role to COMPANY_ADMIN
	_, err = r.Queries.UpdateUserRole(ctx, db.UpdateUserRoleParams{
		ID:   stringToUUID(claims.UserID),
		Role: db.UserRoleCompanyAdmin,
	})
	if err != nil {
		return nil, fmt.Errorf("failed to upgrade user role: %w", err)
	}

	return dbCompanyToGQL(company), nil
}

// UpdateCompanyProfile is the resolver for the updateCompanyProfile field.
func (r *mutationResolver) UpdateCompanyProfile(ctx context.Context, input model.UpdateCompanyInput) (*model.Company, error) {
	claims := auth.GetUserFromContext(ctx)
	if claims == nil {
		return nil, fmt.Errorf("not authenticated")
	}

	company, err := r.Queries.GetCompanyByAdminUserID(ctx, stringToUUID(claims.UserID))
	if err != nil {
		return nil, fmt.Errorf("company not found for user: %w", err)
	}

	var desc, phone, email string
	if input.Description != nil {
		desc = *input.Description
	}
	if input.ContactPhone != nil {
		phone = *input.ContactPhone
	}
	if input.ContactEmail != nil {
		email = *input.ContactEmail
	}
	var radius int32
	if input.MaxServiceRadiusKm != nil {
		radius = int32(*input.MaxServiceRadiusKm)
	}

	updated, err := r.Queries.UpdateCompanyOwnProfile(ctx, db.UpdateCompanyOwnProfileParams{
		ID:           company.ID,
		Description:  desc,
		ContactPhone: phone,
		ContactEmail: email,
		MaxRadius:    radius,
	})
	if err != nil {
		return nil, fmt.Errorf("failed to update company profile: %w", err)
	}

	// Update work schedule if provided.
	if input.WorkSchedule != nil {
		for _, day := range input.WorkSchedule {
			startTime := parseHHMMToTime(day.StartTime)
			endTime := parseHHMMToTime(day.EndTime)
			_, err := r.Queries.UpsertCompanyWorkScheduleDay(ctx, db.UpsertCompanyWorkScheduleDayParams{
				CompanyID: company.ID,
				DayOfWeek: int32(day.DayOfWeek),
				StartTime: startTime,
				EndTime:   endTime,
				IsWorkDay: day.IsWorkDay,
			})
			if err != nil {
				return nil, fmt.Errorf("failed to update work schedule day %d: %w", day.DayOfWeek, err)
			}
		}
	}

	return dbCompanyToGQL(updated), nil
}

// UploadCompanyLogo is the resolver for the uploadCompanyLogo field.
func (r *mutationResolver) UploadCompanyLogo(ctx context.Context, file graphql.Upload) (*model.Company, error) {
	claims := auth.GetUserFromContext(ctx)
	if claims == nil {
		return nil, fmt.Errorf("not authenticated")
	}

	// Get company for this admin user
	company, err := r.Queries.GetCompanyByAdminUserID(ctx, stringToUUID(claims.UserID))
	if err != nil {
		return nil, fmt.Errorf("company not found: %w", err)
	}

	// Validate file type (images only)
	if !isImageFile(file.Filename) {
		return nil, fmt.Errorf("doar imagini sunt permise (jpg, png, webp)")
	}

	// Validate file size (max 10MB)
	if file.Size > 10*1024*1024 {
		return nil, fmt.Errorf("fisierul depaseste limita de 10MB")
	}

	// Build GCS path: uploads/companies/{companyId}/logos
	path := fmt.Sprintf("uploads/companies/%s/logos", uuidToString(company.ID))

	// Upload to GCS with public access
	logoURL, err := r.Storage.Upload(ctx, path, file.Filename, file.File, storage.StorageTypePublic)
	if err != nil {
		return nil, fmt.Errorf("eroare la incarcarea logo-ului: %w", err)
	}

	// Update company logo in DB
	updated, err := r.Queries.UpdateCompanyLogo(ctx, db.UpdateCompanyLogoParams{
		ID:      company.ID,
		LogoUrl: stringToText(&logoURL),
	})
	if err != nil {
		return nil, fmt.Errorf("failed to update logo: %w", err)
	}

	return dbCompanyToGQL(updated), nil
}

// UploadCompanyDocument is the resolver for the uploadCompanyDocument field.
func (r *mutationResolver) UploadCompanyDocument(ctx context.Context, companyID string, documentType string, file graphql.Upload) (*model.CompanyDocument, error) {
	claims := auth.GetUserFromContext(ctx)
	if claims == nil {
		return nil, fmt.Errorf("not authenticated")
	}

	path := fmt.Sprintf("uploads/companies/%s/documents", companyID)
	fileURL, err := r.Storage.Upload(ctx, path, file.Filename, file.File, storage.StorageTypePrivate)
	if err != nil {
		return nil, fmt.Errorf("failed to upload file: %w", err)
	}

	doc, err := r.Queries.CreateCompanyDocument(ctx, db.CreateCompanyDocumentParams{
		CompanyID:    stringToUUID(companyID),
		DocumentType: documentType,
		FileUrl:      fileURL,
		FileName:     file.Filename,
	})
	if err != nil {
		return nil, fmt.Errorf("failed to save company document: %w", err)
	}

	return dbCompanyDocToGQL(doc), nil
}

// DeleteCompanyDocument is the resolver for the deleteCompanyDocument field.
func (r *mutationResolver) DeleteCompanyDocument(ctx context.Context, id string) (bool, error) {
	claims := auth.GetUserFromContext(ctx)
	if claims == nil {
		return false, fmt.Errorf("not authenticated")
	}

	// Verify the document belongs to the caller's company.
	doc, err := r.Queries.GetCompanyDocument(ctx, stringToUUID(id))
	if err != nil {
		return false, fmt.Errorf("document not found: %w", err)
	}

	// Only allow deletion of pending or rejected documents.
	if doc.Status != "pending" && doc.Status != "rejected" {
		return false, fmt.Errorf("cannot delete an approved document")
	}

	// Verify ownership: caller must be admin of the company that owns the doc.
	if claims.Role == "company_admin" {
		company, err := r.Queries.GetCompanyByAdminUserID(ctx, stringToUUID(claims.UserID))
		if err != nil || company.ID != doc.CompanyID {
			return false, fmt.Errorf("not authorized")
		}
	} else if claims.Role != "global_admin" {
		return false, fmt.Errorf("not authorized")
	}

	if err := r.Queries.DeleteCompanyDocument(ctx, stringToUUID(id)); err != nil {
		return false, fmt.Errorf("failed to delete document: %w", err)
	}

	return true, nil
}

// ApproveCompany is the resolver for the approveCompany field.
func (r *mutationResolver) ApproveCompany(ctx context.Context, id string) (*model.Company, error) {
	claims := auth.GetUserFromContext(ctx)
	if claims == nil || claims.Role != "global_admin" {
		return nil, fmt.Errorf("not authenticated or not authorized")
	}

	companyUUID := stringToUUID(id)

	// Check if all required documents are approved
	docsReady, err := r.Queries.CheckCompanyDocumentsReady(ctx, companyUUID)
	if err != nil {
		return nil, fmt.Errorf("failed to check documents: %w", err)
	}

	if !docsReady.Valid || !docsReady.Bool {
		return nil, fmt.Errorf("cannot approve company: all required documents (Certificat Constatator, Asigurare RCA, Document CUI) must be uploaded and approved first")
	}

	company, err := r.Queries.ApproveCompany(ctx, companyUUID)
	if err != nil {
		return nil, fmt.Errorf("failed to approve company: %w", err)
	}

	return dbCompanyToGQL(company), nil
}

// RejectCompany is the resolver for the rejectCompany field.
func (r *mutationResolver) RejectCompany(ctx context.Context, id string, reason string) (*model.Company, error) {
	claims := auth.GetUserFromContext(ctx)
	if claims == nil {
		return nil, fmt.Errorf("not authenticated")
	}

	company, err := r.Queries.RejectCompany(ctx, db.RejectCompanyParams{
		ID:              stringToUUID(id),
		RejectionReason: stringToTextVal(reason),
	})
	if err != nil {
		return nil, fmt.Errorf("failed to reject company: %w", err)
	}

	return dbCompanyToGQL(company), nil
}

// SuspendCompany is the resolver for the suspendCompany field.
func (r *mutationResolver) SuspendCompany(ctx context.Context, id string, reason string) (*model.Company, error) {
	claims := auth.GetUserFromContext(ctx)
	if claims == nil {
		return nil, fmt.Errorf("not authenticated")
	}

	company, err := r.Queries.UpdateCompanyStatus(ctx, db.UpdateCompanyStatusParams{
		ID:     stringToUUID(id),
		Status: db.CompanyStatusSuspended,
	})
	if err != nil {
		return nil, fmt.Errorf("failed to suspend company: %w", err)
	}

	return dbCompanyToGQL(company), nil
}

// ReviewCompanyDocument is the resolver for the reviewCompanyDocument field.
func (r *mutationResolver) ReviewCompanyDocument(ctx context.Context, id string, approved bool, rejectionReason *string) (*model.CompanyDocument, error) {
	claims := auth.GetUserFromContext(ctx)
	if claims == nil || claims.Role != "global_admin" {
		return nil, fmt.Errorf("not authorized")
	}

	status := "approved"
	if !approved {
		status = "rejected"
	}

	var reason pgtype.Text
	if rejectionReason != nil {
		reason = pgtype.Text{String: *rejectionReason, Valid: true}
	}

	doc, err := r.Queries.UpdateCompanyDocumentStatus(ctx, db.UpdateCompanyDocumentStatusParams{
		ID:              stringToUUID(id),
		Status:          status,
		ReviewedBy:      stringToUUID(claims.UserID),
		RejectionReason: reason,
	})
	if err != nil {
		return nil, fmt.Errorf("failed to review document: %w", err)
	}

	return dbCompanyDocToGQL(doc), nil
}

// MyCompany is the resolver for the myCompany field.
func (r *queryResolver) MyCompany(ctx context.Context) (*model.Company, error) {
	claims := auth.GetUserFromContext(ctx)
	if claims == nil {
		return nil, fmt.Errorf("not authenticated")
	}

	// Try finding company already linked to this user.
	company, err := r.Queries.GetCompanyByAdminUserID(ctx, stringToUUID(claims.UserID))
	if err == nil {
		result := dbCompanyToGQL(company)
		r.populateCompanyDocuments(ctx, result, company.ID)
		return result, nil
	}

	// Auto-claim: find unclaimed company matching the user's email.
	company, err = r.Queries.GetUnclaimedCompanyByContactEmail(ctx, claims.Email)
	if err != nil {
		return nil, fmt.Errorf("company not found: %w", err)
	}

	// Link the company to this user.
	company, err = r.Queries.SetCompanyAdminUser(ctx, db.SetCompanyAdminUserParams{
		AdminUserID: stringToUUID(claims.UserID),
		ID:          company.ID,
	})
	if err != nil {
		return nil, fmt.Errorf("failed to claim company: %w", err)
	}

	// Upgrade user role to COMPANY_ADMIN
	_, err = r.Queries.UpdateUserRole(ctx, db.UpdateUserRoleParams{
		ID:   stringToUUID(claims.UserID),
		Role: db.UserRoleCompanyAdmin,
	})
	if err != nil {
		return nil, fmt.Errorf("failed to upgrade user role: %w", err)
	}

	result := dbCompanyToGQL(company)
	r.populateCompanyDocuments(ctx, result, company.ID)
	return result, nil
}

// MyCompanyFinancialSummary is the resolver for the myCompanyFinancialSummary field.
func (r *queryResolver) MyCompanyFinancialSummary(ctx context.Context) (*model.CompanyFinancialSummary, error) {
	claims := auth.GetUserFromContext(ctx)
	if claims == nil {
		return nil, fmt.Errorf("not authenticated")
	}

	company, err := r.Queries.GetCompanyByAdminUserID(ctx, stringToUUID(claims.UserID))
	if err != nil {
		return nil, fmt.Errorf("company not found for user: %w", err)
	}

	summary, err := r.Queries.GetCompanyFinancialSummary(ctx, company.ID)
	if err != nil {
		return nil, fmt.Errorf("failed to get financial summary: %w", err)
	}

	return &model.CompanyFinancialSummary{
		CompletedBookings: int(summary.CompletedBookings),
		TotalRevenue:      numericToFloat(summary.TotalRevenue),
		TotalCommission:   numericToFloat(summary.TotalCommission),
		NetPayout:         numericToFloat(summary.NetPayout),
	}, nil
}

// MyCompanyWorkSchedule is the resolver for the myCompanyWorkSchedule field.
func (r *queryResolver) MyCompanyWorkSchedule(ctx context.Context) ([]*model.CompanyWorkSchedule, error) {
	claims := auth.GetUserFromContext(ctx)
	if claims == nil {
		return nil, fmt.Errorf("not authenticated")
	}

	company, err := r.Queries.GetCompanyByAdminUserID(ctx, stringToUUID(claims.UserID))
	if err != nil {
		return nil, fmt.Errorf("company not found for user: %w", err)
	}

	rows, err := r.Queries.ListCompanyWorkSchedule(ctx, company.ID)
	if err != nil {
		return nil, fmt.Errorf("failed to list work schedule: %w", err)
	}

	result := make([]*model.CompanyWorkSchedule, len(rows))
	for i, row := range rows {
		result[i] = &model.CompanyWorkSchedule{
			ID:        uuidToString(row.ID),
			DayOfWeek: int(row.DayOfWeek),
			StartTime: timeToString(row.StartTime),
			EndTime:   timeToString(row.EndTime),
			IsWorkDay: row.IsWorkDay,
		}
	}
	return result, nil
}

// Companies is the resolver for the companies field.
func (r *queryResolver) Companies(ctx context.Context, status *model.CompanyStatus, first *int, after *string) (*model.CompanyConnection, error) {
	claims := auth.GetUserFromContext(ctx)
	if claims == nil {
		return nil, fmt.Errorf("not authenticated")
	}

	limit := int32(20)
	if first != nil {
		limit = int32(*first)
	}
	offset := int32(0)
	if after != nil {
		fmt.Sscanf(*after, "%d", &offset)
	}

	var companies []db.Company
	var err error

	if status != nil {
		companies, err = r.Queries.ListCompaniesByStatus(ctx, db.ListCompaniesByStatusParams{
			Status: gqlCompanyStatusToDb(*status),
			Limit:  limit + 1,
			Offset: offset,
		})
	} else {
		companies, err = r.Queries.ListAllCompanies(ctx, db.ListAllCompaniesParams{
			Limit:  limit + 1,
			Offset: offset,
		})
	}
	if err != nil {
		return nil, fmt.Errorf("failed to list companies: %w", err)
	}

	hasNext := len(companies) > int(limit)
	if hasNext {
		companies = companies[:limit]
	}

	edges := make([]*model.Company, len(companies))
	for i, c := range companies {
		edges[i] = dbCompanyToGQL(c)
	}

	var endCursor *string
	if len(companies) > 0 {
		c := fmt.Sprintf("%d", offset+limit)
		endCursor = &c
	}

	return &model.CompanyConnection{
		Edges: edges,
		PageInfo: &model.PageInfo{
			HasNextPage: hasNext,
			EndCursor:   endCursor,
		},
		TotalCount: len(edges),
	}, nil
}

// Company is the resolver for the company field.
func (r *queryResolver) Company(ctx context.Context, id string) (*model.Company, error) {
	claims := auth.GetUserFromContext(ctx)
	if claims == nil {
		return nil, fmt.Errorf("not authenticated")
	}

	company, err := r.Queries.GetCompanyByID(ctx, stringToUUID(id))
	if err != nil {
		return nil, fmt.Errorf("company not found: %w", err)
	}

	result := dbCompanyToGQL(company)
	r.populateCompanyDocuments(ctx, result, company.ID)

	// Populate cleaners with their documents for admin view.
	if cleaners, err := r.Queries.ListCleanersByCompany(ctx, company.ID); err == nil {
		for _, c := range cleaners {
			profile := dbCleanerToGQL(c)
			if docs, err := r.Queries.ListCleanerDocuments(ctx, c.ID); err == nil {
				for _, d := range docs {
					profile.Documents = append(profile.Documents, dbCleanerDocToGQL(d))
				}
			}
			result.Cleaners = append(result.Cleaners, profile)
		}
	}

	return result, nil
}

// CompanyChatRooms is the resolver for the companyChatRooms field.
func (r *queryResolver) CompanyChatRooms(ctx context.Context) ([]*model.ChatRoom, error) {
	claims := auth.GetUserFromContext(ctx)
	if claims == nil {
		return nil, fmt.Errorf("not authenticated")
	}

	company, err := r.Queries.GetCompanyByAdminUserID(ctx, stringToUUID(claims.UserID))
	if err != nil {
		return nil, fmt.Errorf("company not found: %w", err)
	}

	rooms, err := r.Queries.ListChatRoomsByCompanyCleaners(ctx, company.ID)
	if err != nil {
		return nil, fmt.Errorf("failed to list company chat rooms: %w", err)
	}

	result := make([]*model.ChatRoom, len(rooms))
	for i, room := range rooms {
		gqlRoom := dbChatRoomToGQL(room)

		// Load participants.
		participants, err := r.Queries.ListChatParticipants(ctx, room.ID)
		if err == nil {
			var gqlParticipants []*model.ChatParticipant
			for _, p := range participants {
				user, err := r.Queries.GetUserByID(ctx, p.UserID)
				if err != nil {
					continue
				}
				gqlParticipants = append(gqlParticipants, &model.ChatParticipant{
					User:     dbUserToGQL(user),
					JoinedAt: timestamptzToTime(p.JoinedAt),
				})
			}
			gqlRoom.Participants = gqlParticipants
		}

		// Load last message.
		lastMsgRow, err := r.Queries.GetLastChatMessage(ctx, room.ID)
		if err == nil {
			lastMsg := dbChatMessageToGQL(lastMsgRow)
			sender, err := r.Queries.GetUserByID(ctx, lastMsgRow.SenderID)
			if err == nil {
				lastMsg.Sender = dbUserToGQL(sender)
			}
			gqlRoom.LastMessage = lastMsg
		}

		result[i] = gqlRoom
	}

	return result, nil
}

// PendingCompanyDocuments is the resolver for the pendingCompanyDocuments field.
func (r *queryResolver) PendingCompanyDocuments(ctx context.Context) ([]*model.CompanyDocument, error) {
	claims := auth.GetUserFromContext(ctx)
	if claims == nil || claims.Role != "global_admin" {
		return nil, fmt.Errorf("not authorized")
	}

	docs, err := r.Queries.ListPendingCompanyDocuments(ctx)
	if err != nil {
		return nil, fmt.Errorf("failed to list pending documents: %w", err)
	}

	result := make([]*model.CompanyDocument, len(docs))
	for i, d := range docs {
		result[i] = dbCompanyDocToGQL(d)
	}
	return result, nil
}
