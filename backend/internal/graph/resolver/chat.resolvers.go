package resolver

// This file will be automatically regenerated based on the schema, any resolver
// implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.86

import (
	"context"
	"fmt"
	"helpmeclean-backend/internal/auth"
	db "helpmeclean-backend/internal/db/generated"
	"helpmeclean-backend/internal/graph/model"

	"github.com/jackc/pgx/v5/pgtype"
)

// SendMessage is the resolver for the sendMessage field.
func (r *mutationResolver) SendMessage(ctx context.Context, roomID string, content string, messageType *string) (*model.ChatMessage, error) {
	claims := auth.GetUserFromContext(ctx)
	if claims == nil {
		return nil, fmt.Errorf("not authenticated")
	}

	msgType := "text"
	if messageType != nil {
		msgType = *messageType
	}

	msg, err := r.Queries.CreateChatMessage(ctx, db.CreateChatMessageParams{
		RoomID:      stringToUUID(roomID),
		SenderID:    stringToUUID(claims.UserID),
		Content:     content,
		MessageType: stringToTextVal(msgType),
	})
	if err != nil {
		return nil, fmt.Errorf("failed to send message: %w", err)
	}

	gqlMsg := dbChatMessageToGQL(msg)

	// Attach sender info.
	sender, err := r.Queries.GetUserByID(ctx, stringToUUID(claims.UserID))
	if err == nil {
		gqlMsg.Sender = dbUserToGQL(sender)
	}

	// Publish to subscribers.
	r.PubSub.Publish(roomID, gqlMsg)

	return gqlMsg, nil
}

// MarkMessagesAsRead is the resolver for the markMessagesAsRead field.
func (r *mutationResolver) MarkMessagesAsRead(ctx context.Context, roomID string) (bool, error) {
	claims := auth.GetUserFromContext(ctx)
	if claims == nil {
		return false, fmt.Errorf("not authenticated")
	}

	err := r.Queries.MarkMessagesRead(ctx, db.MarkMessagesReadParams{
		RoomID:   stringToUUID(roomID),
		SenderID: stringToUUID(claims.UserID),
	})
	if err != nil {
		return false, fmt.Errorf("failed to mark messages as read: %w", err)
	}

	return true, nil
}

// CreateAdminChatRoom is the resolver for the createAdminChatRoom field.
func (r *mutationResolver) CreateAdminChatRoom(ctx context.Context, userIds []string) (*model.ChatRoom, error) {
	claims := auth.GetUserFromContext(ctx)
	if claims == nil {
		return nil, fmt.Errorf("not authenticated")
	}

	// Allow global_admin and company_admin.
	if claims.Role != "global_admin" && claims.Role != "company_admin" {
		return nil, fmt.Errorf("not authorized")
	}

	if len(userIds) == 0 {
		return nil, fmt.Errorf("at least one user ID is required")
	}

	// Idempotency: check if a room with the exact same participants already exists.
	allParticipantIds := make([]pgtype.UUID, 0, len(userIds)+1)
	allParticipantIds = append(allParticipantIds, stringToUUID(claims.UserID))
	for _, uid := range userIds {
		allParticipantIds = append(allParticipantIds, stringToUUID(uid))
	}
	existing, err := r.Queries.FindChatRoomByExactParticipants(ctx, db.FindChatRoomByExactParticipantsParams{
		ParticipantIds:   allParticipantIds,
		ParticipantCount: int64(len(allParticipantIds)),
	})
	if err == nil {
		return dbChatRoomToGQL(existing), nil
	}

	// Create a support chat room (no booking associated).
	room, err := r.Queries.CreateChatRoom(ctx, db.CreateChatRoomParams{
		BookingID: pgtype.UUID{},
		RoomType:  "admin_support",
	})
	if err != nil {
		return nil, fmt.Errorf("failed to create chat room: %w", err)
	}

	// Add each target user as a participant.
	for _, uid := range userIds {
		_, err = r.Queries.AddChatParticipant(ctx, db.AddChatParticipantParams{
			RoomID: room.ID,
			UserID: stringToUUID(uid),
		})
		if err != nil {
			return nil, fmt.Errorf("failed to add user %s to chat room: %w", uid, err)
		}
	}

	// Add the admin (current user) as a participant.
	_, err = r.Queries.AddChatParticipant(ctx, db.AddChatParticipantParams{
		RoomID: room.ID,
		UserID: stringToUUID(claims.UserID),
	})
	if err != nil {
		return nil, fmt.Errorf("failed to add admin to chat room: %w", err)
	}

	// Send a system welcome message.
	_, _ = r.Queries.CreateChatMessage(ctx, db.CreateChatMessageParams{
		RoomID:      room.ID,
		SenderID:    stringToUUID(claims.UserID),
		Content:     "Bun venit! Aceasta este o conversatie de suport. Cum va putem ajuta?",
		MessageType: stringToTextVal("system"),
	})

	return dbChatRoomToGQL(room), nil
}

// OpenBookingChat is the resolver for the openBookingChat field.
func (r *mutationResolver) OpenBookingChat(ctx context.Context, bookingID string) (*model.ChatRoom, error) {
	claims := auth.GetUserFromContext(ctx)
	if claims == nil {
		return nil, fmt.Errorf("not authenticated")
	}

	// Check if a chat room already exists for this booking.
	existing, err := r.Queries.GetChatRoomByBookingID(ctx, stringToUUID(bookingID))
	if err == nil {
		return dbChatRoomToGQL(existing), nil
	}

	// Get the booking to find client + cleaner.
	booking, err := r.Queries.GetBookingByID(ctx, stringToUUID(bookingID))
	if err != nil {
		return nil, fmt.Errorf("booking not found: %w", err)
	}

	// Create a new chat room linked to this booking.
	room, err := r.Queries.CreateChatRoom(ctx, db.CreateChatRoomParams{
		BookingID: stringToUUID(bookingID),
		RoomType:  "booking",
	})
	if err != nil {
		return nil, fmt.Errorf("failed to create chat room: %w", err)
	}

	// Add the client as a participant.
	if booking.ClientUserID.Valid {
		_, _ = r.Queries.AddChatParticipant(ctx, db.AddChatParticipantParams{
			RoomID: room.ID,
			UserID: booking.ClientUserID,
		})
	}

	// Add the cleaner's user as a participant.
	if booking.CleanerID.Valid {
		cleaner, err := r.Queries.GetCleanerByID(ctx, booking.CleanerID)
		if err == nil && cleaner.UserID.Valid {
			_, _ = r.Queries.AddChatParticipant(ctx, db.AddChatParticipantParams{
				RoomID: room.ID,
				UserID: cleaner.UserID,
			})
		}
	}

	return dbChatRoomToGQL(room), nil
}

// MyChatRooms is the resolver for the myChatRooms field.
func (r *queryResolver) MyChatRooms(ctx context.Context) ([]*model.ChatRoom, error) {
	claims := auth.GetUserFromContext(ctx)
	if claims == nil {
		return nil, fmt.Errorf("not authenticated")
	}

	rooms, err := r.Queries.ListChatRoomsByUser(ctx, stringToUUID(claims.UserID))
	if err != nil {
		return nil, fmt.Errorf("failed to list chat rooms: %w", err)
	}

	result := make([]*model.ChatRoom, len(rooms))
	for i, room := range rooms {
		gqlRoom := dbChatRoomToGQL(room)

		// Load participants.
		participants, err := r.Queries.ListChatParticipants(ctx, room.ID)
		if err == nil {
			var gqlParticipants []*model.ChatParticipant
			for _, p := range participants {
				user, err := r.Queries.GetUserByID(ctx, p.UserID)
				if err != nil {
					continue
				}
				gqlParticipants = append(gqlParticipants, &model.ChatParticipant{
					User:     dbUserToGQL(user),
					JoinedAt: timestamptzToTime(p.JoinedAt),
				})
			}
			gqlRoom.Participants = gqlParticipants
		}

		// Load last message.
		lastMsgRow, err := r.Queries.GetLastChatMessage(ctx, room.ID)
		if err == nil {
			lastMsg := dbChatMessageToGQL(lastMsgRow)
			sender, err := r.Queries.GetUserByID(ctx, lastMsgRow.SenderID)
			if err == nil {
				lastMsg.Sender = dbUserToGQL(sender)
			}
			gqlRoom.LastMessage = lastMsg
		}

		result[i] = gqlRoom
	}

	return result, nil
}

// ChatRoom is the resolver for the chatRoom field.
func (r *queryResolver) ChatRoom(ctx context.Context, id string) (*model.ChatRoom, error) {
	claims := auth.GetUserFromContext(ctx)
	if claims == nil {
		return nil, fmt.Errorf("not authenticated")
	}

	room, err := r.Queries.GetChatRoomByID(ctx, stringToUUID(id))
	if err != nil {
		return nil, fmt.Errorf("chat room not found: %w", err)
	}

	gqlRoom := dbChatRoomToGQL(room)

	// Auto-join admin as participant if not already in the room.
	if claims.Role == "global_admin" {
		count, err := r.Queries.CheckChatParticipant(ctx, db.CheckChatParticipantParams{
			RoomID: room.ID,
			UserID: stringToUUID(claims.UserID),
		})
		if err == nil && count == 0 {
			_, _ = r.Queries.AddChatParticipant(ctx, db.AddChatParticipantParams{
				RoomID: room.ID,
				UserID: stringToUUID(claims.UserID),
			})
		}
	}

	// Load participants.
	participants, err := r.Queries.ListChatParticipants(ctx, room.ID)
	if err == nil {
		var gqlParticipants []*model.ChatParticipant
		for _, p := range participants {
			user, err := r.Queries.GetUserByID(ctx, p.UserID)
			if err != nil {
				continue
			}
			gqlParticipants = append(gqlParticipants, &model.ChatParticipant{
				User:     dbUserToGQL(user),
				JoinedAt: timestamptzToTime(p.JoinedAt),
			})
		}
		gqlRoom.Participants = gqlParticipants
	}

	// Load messages.
	messages, err := r.Queries.ListChatMessages(ctx, db.ListChatMessagesParams{
		RoomID: room.ID,
		Limit:  50,
		Offset: 0,
	})
	if err == nil {
		var gqlMessages []*model.ChatMessage
		for _, m := range messages {
			gqlMsg := dbChatMessageToGQL(m)
			sender, err := r.Queries.GetUserByID(ctx, m.SenderID)
			if err == nil {
				gqlMsg.Sender = dbUserToGQL(sender)
			}
			gqlMessages = append(gqlMessages, gqlMsg)
		}
		gqlRoom.Messages = &model.ChatMessageConnection{
			Edges: gqlMessages,
			PageInfo: &model.PageInfo{
				HasNextPage: false,
			},
		}
		if len(gqlMessages) > 0 {
			gqlRoom.LastMessage = gqlMessages[len(gqlMessages)-1]
		}
	}

	return gqlRoom, nil
}

// MessageSent is the resolver for the messageSent field.
func (r *subscriptionResolver) MessageSent(ctx context.Context, roomID string) (<-chan *model.ChatMessage, error) {
	claims := auth.GetUserFromContext(ctx)
	subscriberID := "anon"
	if claims != nil {
		subscriberID = claims.UserID
	}

	ch := r.PubSub.Subscribe(roomID, subscriberID)

	// Unsubscribe when the client disconnects.
	go func() {
		<-ctx.Done()
		r.PubSub.Unsubscribe(roomID, subscriberID)
	}()

	return ch, nil
}

// BookingUpdated is the resolver for the bookingUpdated field.
func (r *subscriptionResolver) BookingUpdated(ctx context.Context, bookingID string) (<-chan *model.Booking, error) {
	// TODO: Implement real-time subscription with WebSocket/pub-sub for production.
	ch := make(chan *model.Booking, 1)
	return ch, nil
}

// NotificationReceived is the resolver for the notificationReceived field.
func (r *subscriptionResolver) NotificationReceived(ctx context.Context) (<-chan *model.Notification, error) {
	// TODO: Implement real-time subscription with WebSocket/pub-sub for production.
	ch := make(chan *model.Notification, 1)
	return ch, nil
}
