package resolver

// This file will be automatically regenerated based on the schema, any resolver
// implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.86

import (
	"context"
	"fmt"

	db "helpmeclean-backend/internal/db/generated"
	"helpmeclean-backend/internal/graph/model"
	"helpmeclean-backend/internal/auth"
	"helpmeclean-backend/internal/personality"
)

// SubmitPersonalityAssessment is the resolver for the submitPersonalityAssessment field.
func (r *mutationResolver) SubmitPersonalityAssessment(ctx context.Context, answers []*model.PersonalityAnswerInput) (*model.PersonalityAssessment, error) {
	claims := auth.GetUserFromContext(ctx)
	if claims == nil {
		return nil, fmt.Errorf("not authenticated")
	}

	// Get the cleaner profile for this user.
	cleaner, err := r.Queries.GetCleanerByUserID(ctx, stringToUUID(claims.UserID))
	if err != nil {
		return nil, fmt.Errorf("cleaner profile not found: %w", err)
	}

	// Must be in PENDING_REVIEW status.
	if string(cleaner.Status) != "pending_review" {
		return nil, fmt.Errorf("assessment can only be taken during pending review")
	}

	// Check not already submitted.
	has, err := r.Queries.HasPersonalityAssessment(ctx, cleaner.ID)
	if err != nil {
		return nil, fmt.Errorf("failed to check existing assessment: %w", err)
	}
	if has {
		return nil, fmt.Errorf("personality assessment already completed")
	}

	// Convert input to scorer format.
	submitted := make([]personality.SubmittedAnswer, len(answers))
	for i, a := range answers {
		submitted[i] = personality.SubmittedAnswer{
			QuestionNumber: a.QuestionNumber,
			Response:       a.Response,
		}
	}

	// Score the assessment.
	result, err := personality.ScoreAssessment(submitted)
	if err != nil {
		return nil, fmt.Errorf("invalid assessment: %w", err)
	}

	// Use a transaction for atomic insert of assessment + answers.
	tx, err := r.Pool.Begin(ctx)
	if err != nil {
		return nil, fmt.Errorf("failed to begin transaction: %w", err)
	}
	defer tx.Rollback(ctx)

	qtx := r.Queries.WithTx(tx)

	// Insert the assessment.
	assessment, err := qtx.CreatePersonalityAssessment(ctx, db.CreatePersonalityAssessmentParams{
		CleanerID:           cleaner.ID,
		TrustScore:          int32(result.FacetScores["A1"].Score),
		MoralityScore:       int32(result.FacetScores["A2"].Score),
		AltruismScore:       int32(result.FacetScores["A3"].Score),
		OrderlinessScore:    int32(result.FacetScores["C2"].Score),
		DutifulnessScore:    int32(result.FacetScores["C3"].Score),
		SelfDisciplineScore: int32(result.FacetScores["C5"].Score),
		CautiousnessScore:   int32(result.FacetScores["C6"].Score),
		IntegrityAvg:        float64ToNumeric(result.IntegrityAvg),
		WorkQualityAvg:      float64ToNumeric(result.WorkQualityAvg),
		HasConcerns:         result.HasConcerns,
		FlaggedFacets:       result.FlaggedFacets,
	})
	if err != nil {
		return nil, fmt.Errorf("failed to save assessment: %w", err)
	}

	// Insert individual answers.
	for _, sa := range result.ScoredAnswers {
		err := qtx.CreatePersonalityAnswer(ctx, db.CreatePersonalityAnswerParams{
			AssessmentID:   assessment.ID,
			QuestionNumber: int32(sa.QuestionNumber),
			FacetCode:      sa.FacetCode,
			IsReverseKeyed: sa.IsReverseKeyed,
			RawResponse:    int32(sa.RawResponse),
			ScoredValue:    int32(sa.ScoredValue),
		})
		if err != nil {
			return nil, fmt.Errorf("failed to save answer %d: %w", sa.QuestionNumber, err)
		}
	}

	if err := tx.Commit(ctx); err != nil {
		return nil, fmt.Errorf("failed to commit: %w", err)
	}

	return dbPersonalityAssessmentToGQL(assessment), nil
}

// PersonalityQuestions is the resolver for the personalityQuestions field.
func (r *queryResolver) PersonalityQuestions(ctx context.Context) ([]*model.PersonalityQuestion, error) {
	questions := make([]*model.PersonalityQuestion, len(personality.Questions))
	for i, q := range personality.Questions {
		questions[i] = &model.PersonalityQuestion{
			Number:    q.Number,
			FacetCode: q.FacetCode,
			Text:      q.TextRO,
		}
	}
	return questions, nil
}

// MyPersonalityAssessment is the resolver for the myPersonalityAssessment field.
func (r *queryResolver) MyPersonalityAssessment(ctx context.Context) (*model.PersonalityAssessment, error) {
	claims := auth.GetUserFromContext(ctx)
	if claims == nil {
		return nil, fmt.Errorf("not authenticated")
	}

	cleaner, err := r.Queries.GetCleanerByUserID(ctx, stringToUUID(claims.UserID))
	if err != nil {
		return nil, nil // No cleaner profile → no assessment.
	}

	assessment, err := r.Queries.GetPersonalityAssessmentByCleanerID(ctx, cleaner.ID)
	if err != nil {
		return nil, nil // No assessment yet.
	}

	return dbPersonalityAssessmentToGQL(assessment), nil
}

// CleanerPersonalityAssessment is the resolver for the cleanerPersonalityAssessment field.
func (r *queryResolver) CleanerPersonalityAssessment(ctx context.Context, cleanerID string) (*model.PersonalityAssessment, error) {
	claims := auth.GetUserFromContext(ctx)
	if claims == nil || (claims.Role != "admin" && claims.Role != "company_admin") {
		return nil, fmt.Errorf("not authorized")
	}

	assessment, err := r.Queries.GetPersonalityAssessmentByCleanerID(ctx, stringToUUID(cleanerID))
	if err != nil {
		return nil, nil // No assessment yet.
	}

	return dbPersonalityAssessmentToGQL(assessment), nil
}

// dbPersonalityAssessmentToGQL converts a DB personality assessment to GraphQL model.
func dbPersonalityAssessmentToGQL(a db.PersonalityAssessment) *model.PersonalityAssessment {
	facetScores := []*model.PersonalityFacetScore{
		{FacetCode: "A1", FacetName: "Încredere", Score: int(a.TrustScore), MaxScore: 20, IsFlagged: a.TrustScore < 10},
		{FacetCode: "A2", FacetName: "Moralitate", Score: int(a.MoralityScore), MaxScore: 20, IsFlagged: a.MoralityScore < 10},
		{FacetCode: "A3", FacetName: "Altruism", Score: int(a.AltruismScore), MaxScore: 20, IsFlagged: a.AltruismScore < 10},
		{FacetCode: "C2", FacetName: "Ordine", Score: int(a.OrderlinessScore), MaxScore: 20, IsFlagged: a.OrderlinessScore < 10},
		{FacetCode: "C3", FacetName: "Responsabilitate", Score: int(a.DutifulnessScore), MaxScore: 20, IsFlagged: a.DutifulnessScore < 10},
		{FacetCode: "C5", FacetName: "Autodisciplină", Score: int(a.SelfDisciplineScore), MaxScore: 20, IsFlagged: a.SelfDisciplineScore < 10},
		{FacetCode: "C6", FacetName: "Prudență", Score: int(a.CautiousnessScore), MaxScore: 20, IsFlagged: a.CautiousnessScore < 10},
	}

	flaggedFacets := a.FlaggedFacets
	if flaggedFacets == nil {
		flaggedFacets = []string{}
	}

	return &model.PersonalityAssessment{
		ID:             uuidToString(a.ID),
		CleanerID:      uuidToString(a.CleanerID),
		FacetScores:    facetScores,
		IntegrityAvg:   numericToFloat(a.IntegrityAvg),
		WorkQualityAvg: numericToFloat(a.WorkQualityAvg),
		HasConcerns:    a.HasConcerns,
		FlaggedFacets:  flaggedFacets,
		CompletedAt:    timestamptzToTime(a.CompletedAt),
	}
}
